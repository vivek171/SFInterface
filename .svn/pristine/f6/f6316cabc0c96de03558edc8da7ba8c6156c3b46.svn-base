package com.htc.remedy.base;


import com.bmc.thirdparty.org.apache.commons.collections.map.HashedMap;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.htc.remedy.config.IndexerUtilities;
import com.htc.remedy.constants.Constants;
import com.htc.remedy.constants.SFInterfaceConstants;
import com.htc.remedy.controller.SFInterfaceWhooshController;
import com.htc.remedy.core.IndexerIntf;
import com.htc.remedy.core.IndexerUtil;
import com.htc.remedy.core.LucenceImpl;
import com.htc.remedy.domain.IndexerDomain;
import com.htc.remedy.model.*;
import com.htc.remedy.oauth.CustomAuthenticationManager;
import com.htc.remedy.services.SFInterfaceServices;
import com.microsoft.sqlserver.jdbc.SQLServerResultSet42;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.document.*;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.Term;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.Sort;
import org.apache.lucene.store.Directory;
import org.apache.lucene.util.BytesRef;
import org.codehaus.jackson.map.DeserializationConfig;
import org.codehaus.jackson.map.ObjectMapper;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.opensaml.core.config.InitializationException;
import org.opensaml.core.config.InitializationService;
import org.opensaml.core.xml.XMLObject;
import org.opensaml.core.xml.config.XMLObjectProviderRegistrySupport;
import org.opensaml.core.xml.io.Unmarshaller;
import org.opensaml.core.xml.io.UnmarshallerFactory;
import org.opensaml.core.xml.io.UnmarshallingException;
import org.opensaml.saml.saml2.core.Response;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.http.*;
import org.springframework.jdbc.core.*;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.endpoint.TokenEndpoint;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.w3c.dom.Element;
import org.xml.sax.SAXException;

import javax.servlet.http.HttpServletRequest;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.*;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.htc.remedy.constants.Constants.INDEXER_ALIAS_COLUMN_NAME_SK;
import static com.htc.remedy.constants.Constants.VOID;
import static com.htc.remedy.constants.SFInterfaceConstants.*;
import static com.htc.remedy.services.SFInterfaceServices.convertmapObject;
import static com.htc.remedy.services.SFInterfaceServices.createORUpdateEntitiess;
import static java.sql.Types.INTEGER;

@Service
@Component
public class SFInterfaceBase implements BaseModel {

    private static final Logger LOGGER = LogManager.getLogger(SFInterfaceWhooshController.class);

    private static
    ResourceLoader resourceLoader;

    private static
    IndexerUtil indexerUtil;

    private static
    SFInterfaceMessages sfInterfaceMessages;

    private static JmsTemplate jmsTemplate;

    private static
    TokenEndpoint tokenEndpoint;

    private static
    Gson gson;

    private static
    CustomAuthenticationManager authenticationManager;

    public static ZipOutputStream fileArchiver() throws FileNotFoundException {
        return new ZipOutputStream(new FileOutputStream(Constants.getBasePath()));
    }

    @Autowired
    public SFInterfaceBase(ResourceLoader resourceLoader, IndexerUtil indexerUtil, SFInterfaceMessages sfInterfaceMessages, JmsTemplate jmsTemplate
            , TokenEndpoint endpoint
            , Gson gson, CustomAuthenticationManager authenticationManager) throws FileNotFoundException {
        this.resourceLoader = resourceLoader;
        this.indexerUtil = indexerUtil;
        this.sfInterfaceMessages = sfInterfaceMessages;
        this.jmsTemplate = jmsTemplate;
        this.tokenEndpoint = endpoint;
        this.gson = gson;
        this.authenticationManager = authenticationManager;
    }

    public static List<Map<String, Object>> luceneSearchWithList(LQLSearch lqlSearch) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();

        try {
            Directory indexDir = indexerUtil.getIndexDirectory(lqlSearch.getIndexerPath(), lqlSearch.getIndexerName());
            IndexerIntf indexIntf = new LucenceImpl(indexDir);
            Boolean sortorder = Boolean.FALSE;
            if (StringUtils.isNotBlank(lqlSearch.getSortOrder()) && !lqlSearch.getSortOrder().equalsIgnoreCase(ASC))
                sortorder = Boolean.TRUE;
            Map<String, Object> docResult = indexIntf.searchDocumentWithLQL(lqlSearch.getQuery()
                    , lqlSearch.getCount() == NULL ? NUM_ZERO : lqlSearch.getCount(), lqlSearch.getSort(), lqlSearch.getLikeoperator()
                    , lqlSearch.getSortField(), lqlSearch.getRequiredColumns(), sortorder, lqlSearch.getPageno(), lqlSearch.getPagination());
            List<Document> documents = (List<Document>) docResult.get(DOCUMENT);

            if (documents != NULL && !documents.contains(ERROR) && documents.size() >= NUM_ZERO) {
                //document loop starts
                if (lqlSearch.getAlias() == null) {
                    lqlSearch.setAlias(new HashMap<>());
                }
                if (lqlSearch.getRequiredColumns() != NULL && lqlSearch.getRequiredColumns()[NUM_ZERO] != NULL) {
                    String[] requiredColumns = lqlSearch.getRequiredColumns();
                    for (String reqColumn : requiredColumns) {
                        if (documents.size() > NUM_ZERO && documents.get(NUM_ZERO).get(reqColumn) == NULL) {
                            return errorMessageHandler(reqColumn, "INFO.MESSAGE.INVALIDCOLUMNNAME");
                        }
                    }
                }
                result = documents.stream()
                        .map(document -> document.getFields()
                                .stream()
                                .collect(HashMap<String, Object>::new, (hashMap, field) ->
                                                hashMap.put(lqlSearch.getAlias().get(field.name()) == NULL ? field.name() : lqlSearch.getAlias().get(field.name())
                                                        , document.get(field.name()).equalsIgnoreCase(Constants.INDEXER_NULL_CHECK) ? NULL : document.get(field.name()))
                                        , HashMap::putAll)
                        )
                        .collect(Collectors.toList());

                //document loop ends
                if (result != NULL && result.size() > NUM_ZERO && result.get(NUM_ZERO) != NULL && result.get(NUM_ZERO).toString().contains(ERROR)) {
                    String errorMessage = result.get(NUM_ZERO).toString();
                    errorMessage = errorMessage.substring(errorMessage.indexOf(EQUAL) + NUM_ONE, errorMessage.length() - NUM_ONE);
                    if (errorMessage.equalsIgnoreCase(DOCID_SHOULD_BE_GREATER_THAN_ZERO)) {
                        return errorMessageHandler(lqlSearch.getIndexerName(), "INFO.MESSAGE.INDEXEREMPTY");
                    }
                }

                result = distinct(result, lqlSearch.getDistinctfield(), lqlSearch.getDistinct());

                if (lqlSearch.getPagination() != null && lqlSearch.getPagination() && result != NULL
                        && !result.contains(ERROR) && docResult.containsKey(TOTAL_COUNT) && Integer.parseInt(docResult.get(TOTAL_COUNT).toString()) > 0) {
                    return pagination(lqlSearch.getPageno(), lqlSearch.getCount(), result, docResult.get(TOTAL_COUNT).toString());
                }
                return result;
            } else if (documents.contains(ERROR)) {
                return errorMessageHandler(lqlSearch.getIndexerName(), documents.get(NUM_ZERO).toString());
            } else {
                return errorMessageHandler(lqlSearch.getIndexerName(), documents != NULL ? documents.toString() : "");
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            return errorMessageHandler(null, e.getMessage());
        }
    }

    public static List<Map<String, Object>> errorMessageHandler(String indexerName, String message) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> errorObject = new HashMap<>();
        if (message.equalsIgnoreCase("INFO.MESSAGE.INVALIDCOLUMNNAME") || message.equalsIgnoreCase("INFO.MESSAGE.INDEXEREMPTY")) {
            errorObject = SFInterfaceServices.getInfoMap(message, indexerName, null);
        } else if (StringUtils.isNotBlank(indexerName)) {
            errorObject.put(ERROR, indexerName + message);
        } else {
            errorObject.put(ERROR, message);
        }
        result.add(errorObject);
        return result;
    }

    public static List<Map<String, Object>> fetchWhooshRecords(String endpointName, String refdbquery, Sort sort, String[] selectedcolumns, String sortfield, String sortorder, String distinct, Map<String, String> fieldalias, int count, Boolean likeoperator, User user) {
        return fetchWhooshRecords(endpointName, refdbquery, sort, selectedcolumns, sortfield, sortorder, distinct, fieldalias, count, likeoperator, null, user);
    }

    public static List<Map<String, Object>> fetchWhooshRecords(String endpointName, String refdbquery, Sort sort, String[] selectedcolumns, String sortfield, String sortorder, String distinct, Map<String, String> fieldalias, int count, Boolean likeoperator, String disinctfield, User user) {
        return fetchWhooshRecords(endpointName, refdbquery, sort, selectedcolumns, sortfield, sortorder, distinct, fieldalias, count, likeoperator, disinctfield, 1, Boolean.FALSE, user);
    }

    public static List<Map<String, Object>> fetchWhooshRecords(String endpointName, String refdbquery, Sort sort, String[] selectedcolumns, String sortfield, String sortorder, String distinct, Map<String, String> fieldalias, int count, Boolean likeoperator, String disinctfield, Integer pageno, Boolean pagination, User user) {

        List<Map<String, Object>> jsonObjects = new ArrayList<>();
        LQLSearch lqlSearch = new LQLSearch();
        try {
            lqlSearch.setCount(count);
            lqlSearch.setIndexerName(endpointName);
            lqlSearch.setQuery(refdbquery);
            lqlSearch.setSort(sort);
            lqlSearch.setDistinct(distinct);
            lqlSearch.setSortField(sortfield);
            lqlSearch.setSortOrder(sortorder);
            lqlSearch.setRequiredColumns(selectedcolumns);
            lqlSearch.setAlias(fieldalias);
            lqlSearch.setLikeoperator(likeoperator);
            lqlSearch.setDistinctfield(disinctfield);
            lqlSearch.setPageno(pageno);
            lqlSearch.setPagination(pagination);
            lqlSearch.setIndexerPath(user.getClientInstance());
            return luceneSearchWithList(lqlSearch);
        } catch (Exception e) {
            jsonObjects = new ArrayList<>();
            Map<String, Object> jsonObject = new HashMap<>();
            jsonObject.put(ERROR, e.getMessage());
            jsonObjects.add(jsonObject);
        }
        return jsonObjects;
    }

    public static List<Map<String, Object>> fetchWhooshRecords(String endpointName, String refdbquery, Sort sort, String[] selectedcolumns, String sortfield, String sortorder, String distinct, Map<String, String> fieldalias, User user) {
        return fetchWhooshRecords(endpointName, refdbquery, sort, selectedcolumns, sortfield, sortorder, distinct, fieldalias, NUM_ZERO, Boolean.FALSE, user);
    }

    public static List<Map<String, Object>> fetchWhooshRecords(String endpointName, String refdbquery, Sort sort, String[] selectedcolumns, String sortfield, String sortorder, String distinct, Map<String, String> fieldalias, int count, User user) {
        return fetchWhooshRecords(endpointName, refdbquery, sort, selectedcolumns, sortfield, sortorder, distinct, fieldalias, count, Boolean.FALSE, user);
    }

    public static List<Map<String, Object>> runjdbcQuery(JdbcTemplate jdbcTemplate, String query) {
        return jdbcTemplate.query(query, new CustomRowMapper());
    }

    public static List<List<Map<String, Object>>> executeProcedure(JdbcTemplate jdbcTemplate, final String sql, String[] requiredColumns) {
        List<String> requiredColumnsResult = new ArrayList<>();
        if (requiredColumns != NULL && requiredColumns.length > NUM_ZERO) {
            for (String result : requiredColumns) {
                requiredColumnsResult.add(result);
            }
        }
        return jdbcTemplate.execute(new CallableStatementCreator() {
            @Override
            public CallableStatement createCallableStatement(Connection con) throws SQLException {
                return con.prepareCall(sql);
            }
        }, new CallableStatementCallback<List<List<Map<String, Object>>>>() {
            @Override
            public List<List<Map<String, Object>>> doInCallableStatement(CallableStatement cs) throws SQLException {
                boolean resultsAvailable;
                List<List<Map<String, Object>>> list = new ArrayList<List<Map<String, Object>>>();
                // while (resultsAvailable) {

                ResultSet resultSet = cs.executeQuery();
                List<Map<String, Object>> subList = new ArrayList<Map<String, Object>>();
                while (resultSet.next()) {
                    ResultSetMetaData meta = resultSet.getMetaData();
                    int colcount = meta.getColumnCount();
                    Map<String, Object> map = new LinkedHashMap<String, Object>();
                    //To get the selected fields
                    if (requiredColumnsResult != null && requiredColumnsResult.size() > NUM_ZERO) {

                        for (int i = 1; i <= colcount; i++) {
                            String name = meta.getColumnLabel(i);
                            if (requiredColumnsResult.contains(meta.getColumnLabel(i))) {
                                if (name.equalsIgnoreCase("NotificationData")) {
                                    if (isJSONValid(resultSet.getString(i)))
                                        map.put(name, gson.fromJson(resultSet.getString(i), Object.class));
                                    else
                                        map.put(name, resultSet.getString(i));
                                } else {
                                    map.put(name, resultSet.getString(i));
                                }
                            }
                        }
                        subList.add(map);

                    } else {
                        //To get all the fields
                        for (int i = 1; i <= colcount; i++) {
                            String name = meta.getColumnLabel(i);
                            if (name.equalsIgnoreCase("NotificationData")) {
                                if (isJSONValid(resultSet.getString(i)))
                                    map.put(name, gson.fromJson(resultSet.getString(i), Object.class));
                                else
                                    map.put(name, resultSet.getString(i));
                            } else {
                                map.put(name, resultSet.getString(i));
                            }
                        }
                        subList.add(map);
                    }
                }
                list.add(subList);
                while (cs.getMoreResults()) {
                    ResultSet resultSet2 = cs.getResultSet();
                    List<Map<String, Object>> subList2 = new ArrayList<Map<String, Object>>();
                    while (resultSet2.next()) {
                        ResultSetMetaData meta = resultSet2.getMetaData();
                        int colcount = meta.getColumnCount();
                        Map<String, Object> map = new HashMap<String, Object>();
                        for (int i = 1; i <= colcount; i++) {
                            String name = meta.getColumnLabel(i);
                            map.put(name, resultSet2.getString(i));
                        }

                        subList2.add(map);
                        list.add(subList2);
                    }
                }
                return list;
            }
        });
    }

    public static boolean isJSONValid(String test) {
        try {
            new JSONObject(test);
        } catch (JSONException ex) {
            // edited, to include @Arthur's comment
            // e.g. in case JSONArray is valid as well...
            try {
                new JSONArray(test);
            } catch (JSONException ex1) {
                return false;
            }
        }
        return true;
    }

    public static List<Map<String, Object>> runjdbcQueryWithSelectedColumns(JdbcTemplate jdbcTemplate, String query, String[] requiredColumns) {
        Map<String, Object> requiredColumnsResult = new HashMap<>();
        if (requiredColumns != NULL && requiredColumns.length > NUM_ZERO) {
            for (String result : requiredColumns) {
                requiredColumnsResult.put(result, result);
            }

            return jdbcTemplate.query(query, (resultSet, position) -> {
                int cCount = resultSet.getMetaData().getColumnCount();
                Map<String, Object> jsonObject = new HashMap<>();
                for (int i = 1; i <= cCount; i++) {
                    if (requiredColumnsResult.containsKey(resultSet.getMetaData().getColumnName(i))) {
                        jsonObject.put(resultSet.getMetaData().getColumnName(i), resultSet.getString(i));
                    }
                }
                return jsonObject;
            });
        } else {
            return SFInterfaceBase.runjdbcQuery(jdbcTemplate, query);
        }
    }

    public static List<Map<String, Object>> runjdbcQueryWithPagination(JdbcTemplate jdbcTemplate, String query, String[] requiredColumns
            , String sortFields, String sortOrder, String distinct, String distinctField, int pageNo, int recordCount, Boolean pagination) throws IOException {

        List<List<Map<String, Object>>> result = executeProcedure(jdbcTemplate, query, requiredColumns);
        List<Map<String, Object>> distinctResult = new ArrayList<>();
        if (requiredColumns != NULL && requiredColumns[NUM_ZERO] != NULL) {
            for (String reqColumn : requiredColumns) {
                if (result.size() > NUM_ZERO
                        && result.get(NUM_ZERO).size() > NUM_ZERO
                        && !result.get(NUM_ZERO).get(NUM_ZERO).containsKey(reqColumn)) {
                    distinctResult.add(SFInterfaceServices.getInfoMap("INFO.MESSAGE.INVALIDCOLUMNNAME", reqColumn, null));
                    return distinctResult;
                }
            }
        }

        if (result.size() > NUM_ZERO) {
            distinctResult = SFInterfaceBase.sortNDistinct(result.get(NUM_ZERO), sortFields, sortOrder, distinct, distinctField);
        }

        if (pagination != null && pagination && distinctResult != NULL
                && !distinctResult.contains(ERROR) && result.size() > NUM_ONE && result.get(1).get(0).containsKey(TOTAL_COUNT)
                && Integer.parseInt(result.get(1).get(0).get(TOTAL_COUNT).toString()) > NUM_ZERO) {
            return pagination(pageNo, recordCount, distinctResult, result.get(1).get(0).get(TOTAL_COUNT).toString());
        }

        return distinctResult;

    }

    public static List<Map<String, Object>> runjdbcQueryWithSelectedColumnsasModel(JdbcTemplate jdbcTemplate, String query, String[] requiredColumns) {
        Map<String, Object> requiredColumnsResult = new HashMap<>();
        if (requiredColumns != NULL && requiredColumns.length > NUM_ZERO) {
            for (String result : requiredColumns) {
                requiredColumnsResult.put(result, result);
            }

            return jdbcTemplate.query(query, (resultSet, position) -> {
                int cCount = resultSet.getMetaData().getColumnCount();
                Map<String, Object> jsonObject = new HashMap<>();
                for (int i = 1; i <= cCount; i++) {
                    if (requiredColumnsResult.containsKey(resultSet.getMetaData().getColumnName(i))) {
                        if (!resultSet.getMetaData().getColumnName(i).equalsIgnoreCase("NotificationData"))
                            jsonObject.put(resultSet.getMetaData().getColumnName(i), resultSet.getString(i));
                        else {
                            //  jsonObject.put(resultSet.getMetaData().getColumnName(i), resultSet.getString(i));
                            jsonObject.put(resultSet.getMetaData().getColumnName(i),
                                    gson.fromJson(resultSet.getString(i), Object.class));
                        }
                    }
                }
                return jsonObject;
            });
        } else {
            return SFInterfaceBase.runjdbcQuery(jdbcTemplate, query);
        }
    }

    public static List<String> fetchRequiredFieldsForBusinessFunction(String businessfunction) throws IOException {
        List<String> record = new ArrayList<>();
        Resource resource = resourceLoader.getResource(BUSINESS_FUNCTION_REQUIRED_FIELDS_JSON_PATH);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        JsonObject jsonObject = gson.fromJson(jsonstring, JsonObject.class);
        JsonElement supportFunction = (JsonElement) jsonObject.get(businessfunction);
        supportFunction.getAsJsonArray().forEach(jsonElement -> {
            record.add(jsonElement.getAsString());
        });
        return record;
    }

    public static Map<String, Object> fetchTicketJson(String businessfunctioncode) throws IOException {
        Resource resource = resourceLoader.getResource(BUSINESS_FUNCTION_TICKETS_REQUIRED_FIELDS_JSON_PATH);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        JsonObject jsonObject = gson.fromJson(jsonstring, JsonObject.class);
        JsonElement supportFunction = (JsonElement) jsonObject.get(businessfunctioncode);

        return gson.fromJson(supportFunction, Map.class);
    }

    public static JsonObject fetchTicketJsonfromPath(String jsonpath) throws IOException {
        Resource resource = resourceLoader.getResource(jsonpath);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        JsonObject jsonObject = gson.fromJson(jsonstring, JsonObject.class);
        return jsonObject;
    }

    public static JsonObject fetchIndexerJson(String indexerName) throws IOException {
        Resource resource = resourceLoader.getResource(INDEXER_JSON_PATH);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        JsonObject jsonObject = gson.fromJson(jsonstring, JsonObject.class);
        return jsonObject.get(indexerName).getAsJsonObject();
    }

    public static String fetchIndexerJsonfromPath(String indexerName, String resultsetkey) throws IOException {
        return fetchIndexerJson(indexerName).getAsJsonPrimitive(resultsetkey).getAsString();
    }


    public static String fetchIndexerJsonfromPath(String indexerName) throws IOException {
        return fetchIndexerJsonfromPath(indexerName, "resultset_key");
    }

    public static String fetchAlternateKeyIndexerJsonfromPath(String indexerName, String alternatekey) throws IOException {
        return fetchIndexerJson(indexerName).getAsJsonObject("alternate_key").get(alternatekey).getAsString();
    }

    public static String fetchValuefromJsonPath(String key) throws IOException {
        Resource resource = resourceLoader.getResource(CR_JSON_PATH);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        JsonObject jsonObject = gson.fromJson(jsonstring, JsonObject.class);
        JsonElement supportFunction = (JsonElement) jsonObject.get(key);
        return supportFunction.getAsString();
    }

    public static JsonElement fetchValuefromTableMappingStringresult(String endpointName, String key) throws IOException {
        Resource resource = resourceLoader.getResource(TABLE_MAPPING_JSON_PATH);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        JsonObject jsonObject = gson.fromJson(jsonstring, JsonObject.class);
        return jsonObject.get(endpointName).getAsJsonObject().get(key);
    }

    public static Map<String, Object> fetchValuefromTableMapping(String endpointName) throws IOException {
        Resource resource = resourceLoader.getResource(TABLE_MAPPING_JSON_PATH);   // fetch endpoints details from refdb
        String jsonstring = IOUtils.toString(resource.getInputStream(), UTF_8);
        return (Map<String, Object>) gson.fromJson(jsonstring, Map.class).get(endpointName);

    }

    public static String getDBQuery(String refdbquery, Map<String, String[]> params) {
        return params.keySet()
                .stream()
                .filter(stringEntry ->
                        stringEntry != null && params.get(stringEntry) != null && params.get(stringEntry)[NUM_ZERO] != null)
                .reduce(refdbquery, (tempquery, param) ->
                        tempquery.replaceAll(DOUBLE_OPEN_BRACE_WITH_BACKSLASH + param + DOUBLE_CLOSE_BRACE_WITH_BACKSLASH, StringEscapeUtils.escapeSql(params.get(param)[NUM_ZERO]))
                );
    }

    public static String generateWhooshQuery(Map<String, String[]> params) {
        return params.entrySet()
                .stream()
                .filter(stringEntry -> stringEntry.getKey() != null)
                .map(stringEntry -> stringEntry.getValue()[NUM_ZERO].indexOf(ASTERISK) > NUM_ZERO ?
                        stringEntry.getKey() + COLON + stringEntry.getValue()[NUM_ZERO] :
                        stringEntry.getKey() + COLON_WITH_BACKSLASH + stringEntry.getValue()[NUM_ZERO] + BACKSLASH
                )
                .collect(Collectors.joining(AND));
    }

    public static String generateWhooshQueryDynamic(Map<String, String[]> params) {
        return params.entrySet()
                .stream()
                .filter(stringEntry -> stringEntry.getKey() != null)
                .map(stringEntry -> {
                    if (stringEntry.getValue().length > 1) {
                        if (stringEntry.getKey().endsWith(ON) && stringEntry.getValue().length == 2) {
                            return stringEntry.getKey() + COLON + OPEN_SQUARE_BRACKET +
                                    Arrays.asList(stringEntry.getValue()).stream().map(s ->
                                            EMPTY + ESCAPE_CHARACTER + s + ESCAPE_CHARACTER + EMPTY
                                    )
                                            .collect(Collectors.joining(LUCENE_TO)) + CLOSE_SQUARE_BRACKET;
                        } else {
                            return OPEN_BRACKET + Arrays.asList(stringEntry.getValue()).stream().map(s -> s.indexOf(ASTERISK) >= NUM_ZERO ?
                                    stringEntry.getKey() + COLON + s :
                                    stringEntry.getKey() + COLON_WITH_BACKSLASH + s + BACKSLASH
                            )
                                    .collect(Collectors.joining(OR)) + CLOSE_BRACKET;
                        }
                    } else {
                        return EMPTY + Arrays.asList(stringEntry.getValue()).stream().map(s -> s.indexOf(ASTERISK) >= NUM_ZERO ?
                                stringEntry.getKey() + COLON + s :
                                stringEntry.getKey() + COLON_WITH_BACKSLASH + s + BACKSLASH
                        )
                                .collect(Collectors.joining(OR)) + EMPTY;
                    }
                })
                .collect(Collectors.joining(AND));
    }

    public static String generateWhooshQueryDynamicwithDefaultNULL(Map<String, String[]> params) {
        final int[] i = {0};
        return params.entrySet()
                .stream()
                .filter(stringEntry -> stringEntry.getKey() != null)
                .map(stringEntry -> {
                    if (i[0] == 0) {
                        i[0]++;
                        if (stringEntry.getValue().length > 1) {
                            if (stringEntry.getKey().endsWith(ON) && stringEntry.getValue().length == 2) {
                                return stringEntry.getKey() + COLON + OPEN_SQUARE_BRACKET +
                                        Arrays.asList(stringEntry.getValue()).stream().map(s ->
                                                EMPTY + ESCAPE_CHARACTER + s + ESCAPE_CHARACTER + EMPTY
                                        )
                                                .collect(Collectors.joining(LUCENE_TO)) + CLOSE_SQUARE_BRACKET;
                            } else {
                                return OPEN_BRACKET + Arrays.asList(stringEntry.getValue()).stream().map(s -> s.indexOf(ASTERISK) >= NUM_ZERO ?
                                        stringEntry.getKey() + COLON + s :
                                        stringEntry.getKey() + COLON_WITH_BACKSLASH + s + BACKSLASH
                                )
                                        .collect(Collectors.joining(OR)) + CLOSE_BRACKET;
                            }
                        } else {
                            return EMPTY + Arrays.asList(stringEntry.getValue()).stream().map(s -> s.indexOf(ASTERISK) >= NUM_ZERO ?
                                    stringEntry.getKey() + COLON + s :
                                    stringEntry.getKey() + COLON_WITH_BACKSLASH + s + BACKSLASH
                            )
                                    .collect(Collectors.joining(OR)) + EMPTY;
                        }
                    } else if (stringEntry.getValue().length > 1) {
                        i[0]++;
                        if (stringEntry.getKey().endsWith(ON) && stringEntry.getValue().length == 2) {
                            return stringEntry.getKey() + COLON + OPEN_SQUARE_BRACKET +
                                    Arrays.asList(stringEntry.getValue()).stream().map(s ->
                                            EMPTY + ESCAPE_CHARACTER + s + ESCAPE_CHARACTER + EMPTY
                                    )
                                            .collect(Collectors.joining(LUCENE_TO)) + CLOSE_SQUARE_BRACKET;
                        } else {
                            return OPEN_BRACKET + Arrays.asList(stringEntry.getValue()).stream().map(s -> s.indexOf(ASTERISK) >= NUM_ZERO ?
                                    stringEntry.getKey() + COLON + s + OR + stringEntry.getKey() + COLON + NULL_VALUE :
                                    stringEntry.getKey() + COLON_WITH_BACKSLASH + s + BACKSLASH + OR + stringEntry.getKey() + COLON + NULL_VALUE
                            )
                                    .collect(Collectors.joining(OR)) + CLOSE_BRACKET;
                        }
                    } else {

                        return EMPTY + OPEN_BRACKET + Arrays.asList(stringEntry.getValue()).stream().map(s -> s.indexOf(ASTERISK) >= NUM_ZERO ?
                                stringEntry.getKey() + COLON + s + OR + stringEntry.getKey() + COLON + NULL_VALUE :
                                stringEntry.getKey() + COLON_WITH_BACKSLASH + s + BACKSLASH + OR + stringEntry.getKey() + COLON + NULL_VALUE
                        )
                                .collect(Collectors.joining(OR)) + EMPTY + CLOSE_BRACKET;
                    }

                })
                .collect(Collectors.joining(AND));
    }

    public static String generateWhooshQueryWithLike(Map<String, String[]> params) {
        return params.entrySet()
                .stream()
                .filter(stringEntry -> stringEntry.getKey() != null)
                .map(stringEntry ->
                        OPEN_BRACKET + Arrays.asList(stringEntry.getValue()).stream().map(s -> (
                                        s.indexOf(ASTERISK) > NUM_ZERO
                                                || stringEntry.getKey().equalsIgnoreCase(LOGIN_ID)
                                                || stringEntry.getKey().endsWith(INDEXER_ALIAS_COLUMN_NAME_SK)
                                ) ?
                                        stringEntry.getKey() + COLON + ESCAPE_CHARACTER + s + ESCAPE_CHARACTER :
                                        stringEntry.getKey() + COLON + ESCAPE_CHARACTER + s + ESCAPE_CHARACTER + OR + stringEntry.getKey() + COLON + s + ASTERISK
                        ).collect(Collectors.joining(OR)) + CLOSE_BRACKET
                )
                .collect(Collectors.joining(AND));
    }

    public static String getWhooshQuery(String refdbquery, Map<String, String[]> params) {
        refdbquery = params.keySet()
                .stream()
                .reduce(refdbquery, (tempquery, param) ->
                        param.contains(ASTERISK) ?
                                tempquery.replaceAll(ESCAPE_CHARACTER + DOUBLE_OPEN_BRACE_WITH_BACKSLASH + param + DOUBLE_CLOSE_BRACE_WITH_BACKSLASH + ESCAPE_CHARACTER, QueryParser.escape(params.get(param)[NUM_ZERO]))
                                :
                                tempquery.replaceAll(DOUBLE_OPEN_BRACE_WITH_BACKSLASH + param + DOUBLE_CLOSE_BRACE_WITH_BACKSLASH, QueryParser.escape(params.get(param)[NUM_ZERO]))

                );
        return params.keySet()
                .stream()
                .reduce(refdbquery, (tempquery, param) ->
                        tempquery.contains(ESCAPE_CHARACTER + DOUBLE_OPEN_BRACE + param + DOUBLE_CLOSE_BRACE + ASTERISK + ESCAPE_CHARACTER) ?
                                tempquery.replaceAll(ESCAPE_CHARACTER + DOUBLE_OPEN_BRACE_WITH_BACKSLASH + param + DOUBLE_CLOSE_BRACE_WITH_BACKSLASH + "\\" + ASTERISK + ESCAPE_CHARACTER, QueryParser.escape(params.get(param)[NUM_ZERO] + ASTERISK))
                                :
                                tempquery.replaceAll(DOUBLE_OPEN_BRACE_WITH_BACKSLASH + param + DOUBLE_CLOSE_BRACE_WITH_BACKSLASH, QueryParser.escape(params.get(param)[NUM_ZERO]))

                );
    }

    public static List<Map<String, Object>> distinct(List<Map<String, Object>> result, String distinctfield, String distinct) {
        if (StringUtils.isNotBlank(distinctfield) && !distinctfield.equalsIgnoreCase(VOID)) {
            List<String> distinctfields = Arrays.asList(distinctfield.split(","));
            return result.stream()
                    //     .filter(eachresult -> StringUtils.isNotBlank((String) eachresult.get(distinctfield)))
                    .filter(distinctByKey(eachresult ->
                            distinctFieldValues(eachresult, distinctfields)
                    )).collect(Collectors.toList());
        }
        return result;
    }

    public static List distinctFieldValues(Map<String, Object> eachresult, List<String> distinctfields) {
        return distinctfields.stream().map(distinctfield -> eachresult.get(distinctfield)).collect(Collectors.toList());
    }

    public static List<Map<String, Object>> pagination(int pageNumber, int recordCount, List<Map<String, Object>> result, String totalRecord) throws IOException {
        int totalRecordCount = 0, totalPages = 0;
        Map<java.lang.String, java.lang.Object> totalRecords = new HashMap<>();
        List<Map<String, Object>> result1 = new ArrayList<>();
        int pageNo = pageNumber != NUM_ZERO ? pageNumber : ENDPOINT_DEFAULT_PAGENO;
        int count = recordCount != NUM_ZERO || recordCount > 10000 ? recordCount : 10000;

        totalRecordCount = Integer.parseInt(totalRecord);
        totalPages = totalRecordCount % count == 0 ? totalRecordCount / count : totalRecordCount / count + 1;
        totalRecords.put(TOTAL_COUNT, totalRecordCount);
        totalRecords.put(TOTAL_PAGES, totalPages);

        totalRecords.put(RECORD_COUNT, result.size());
        totalRecords.put(PAGE_NUM, pageNo);
        Map<String, Object> resultMap = new HashMap<>();
        resultMap.put(PAGINATION, totalRecords);
        if (pageNo > totalPages && result.size() <= NUM_ZERO) {
            result.add(SFInterfaceServices.getInfoMap("INFO.MESSAGE.INVALIDPAGENO", null, null));
            resultMap.put(RESULT, result);
            result1.add(resultMap);
            return result1;
        }
        resultMap.put(RESULT, result);
        result1.add(resultMap);
        return result1;
    }

    public static Map<String, Object> generateTicketNumber(JdbcTemplate refTemplate, String endpointName, String version, Map<String, Object> ticketFields, HttpServletRequest request, User user) throws IOException {

        Map<String, Object> queryObject = new LinkedHashMap<>();
        Map<String, Object> resultMap = new LinkedHashMap<>();
        String ticketNumber = "";
        String globalspName = "";

        try {
            Map<String, Object> endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpointName, version, SFInterfaceConstants.POST_METHOD, user);

            if (endPointDomain.size() > NUM_ZERO && !(endPointDomain.containsKey(ERRORCODE)) && StringUtils.isNotBlank(endPointDomain.get(QUERY).toString())) {

                String spName = endPointDomain.get(QUERY).toString();
                globalspName = spName;

                SqlParameter varString = new SqlParameter(Types.VARCHAR);

                List<SqlParameter> paramList = new ArrayList<SqlParameter>();
                paramList.add(varString);
                paramList.add(varString);
                paramList.add(varString);

                String procedureCall = CALL_PARAM_IN_PROCEDURE + spName + UNDERSCORE + ticketFields.get(MASTER_ACCOUNT_CODE) + QUESTION_MARKS_IN_GENERATETICKETNUMBER;

                try {
                    resultMap = refTemplate.call(new CallableStatementCreator() {
                        @Override
                        public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                            CallableStatement callableStatement = connection.prepareCall(procedureCall);
                            String busFuncSk = fetchbusinessfunction_sk(ticketFields, user);
                            callableStatement.setString(1, busFuncSk);
                            String accountSK = ticketFields.containsKey(ACCOUNT_SK) ? (String) ticketFields.get(ACCOUNT_SK) : (String) ticketFields.get(ACCOUNT);
                            callableStatement.setString(2, accountSK);
                            String masterAccountSK = ticketFields.containsKey(MASTER_ACCOUNT_SK) ? (String) ticketFields.get(MASTER_ACCOUNT_SK) : (String) ticketFields.get(MASTER_ACCOUNT);
                            callableStatement.setString(3, masterAccountSK);
                            return callableStatement;
                        }
                    }, paramList);
                } catch (Exception e) {
                    queryObject.put(ERROR, SFInterfaceServices.ISPExceptionHandler(e, null, endpointName).get(ERROR));
                    SFInterfaceLoggerBase.log(LOGGER, user.toString() + "Endpointname:" + " GenerateTicketNumber:" + "ProcedureName:" + globalspName + " Message:" + e.getMessage());
                }
                if (resultMap.containsKey(RESULT_SET_1)) {
                    List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                    Map<String, Object> ticketQueryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                    String ticket_Number = ticketQueryObject.get(TICKET_NUMBER).toString();
                    int digits = Integer.parseInt(ticketQueryObject.get(DIGITS).toString());
                    String seqNumber = StringUtils.leftPad(ticket_Number, digits, ZERO);
                    ticketNumber = (String) ticketQueryObject.get(PREFIX) + (String) ticketQueryObject.get(DELIMITER)
                            + (ticketQueryObject.get(ACC_CODE) != NULL ? (String) ticketQueryObject.get(ACC_CODE) : "") + seqNumber;
                    queryObject.put(TICKET_NUMBER, ticketNumber);
                    SFInterfaceLoggerBase.log(LOGGER, "Endpointname:" + " GenerateTicketNumber:" + "ProcedureName:" + globalspName + " Message:" + gson.toJson(queryList) + ticketNumber + user.toString());
                } else {
                    SFInterfaceLoggerBase.log(LOGGER, "Endpointname:" + " GenerateTicketNumber:" + "ProcedureName:" + globalspName + " Message:" + gson.toJson(resultMap) + user.toString());
                }
            }
        } catch (Exception e) {
            queryObject.put(ERROR, SFInterfaceServices.ISPExceptionHandler(e, null, endpointName).get(ERROR));
            SFInterfaceLoggerBase.log(LOGGER, "Endpointname:" + " GenerateTicketNumber:" + "ProcedureName:" + globalspName + " Message:" + gson.toJson(queryObject) + user.toString());
        }

        return queryObject;
    }

    private static String getValue(Object array) {
        if (StringUtils.isNotBlank((String) array)) {
            return array.toString();
        }
        return null;
    }

    private static String getDBValidatedValue(Object array, String datatype) {
        switch (datatype) {
            case DATATYPE_INTEGER: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return INTEGER_DEFAULT_VALUE;    //default value handling null values in integer
                }
            }
            case DATATYPE_VARCHAR: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return "";  //default value handling null values in varchar
                }
            }
            case DATATYPE_DATETIME: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return DATETIME_DEFAULT_VALUE;   //default value handling null values in datetime
                }
            }
            case DATATYPE_DATE: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return DATE_DEFAULT_VALUE;    //default value handling null values in date
                }
            }
            case DATATYPE_BIT: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return BIT_DEFAULT_VALUE;    //default value handling null values in bit
                }
            }
            case DATATYPE_CHAR: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return "";  //default value handling null values in char
                }
            }
            case DATATYPE_FLOAT: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return FLOAT_DEFAULT_VALUE;    //default value handling null values in float
                }
            }
            case DATATYPE_DECIMAL: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return DECIMAL_DEFAULT_VALUE;    //default value handling null values in decimal
                }
            }
            case DATATYPE_BIGINT: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return BIGINT_DEFAULT_VALUE;    //default value handling null values in bigint
                }
            }
            case DATATYPE_TIME: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return TIME_DEFAULT_VALUE;    //default value handling null values in time
                }
            }
            default: {
                if (StringUtils.isNotBlank((String) array)) {
                    return array.toString();
                } else {
                    return null;
                }
            }
        }
    }

    public static Map<String, Object> fetchEndpointDetails(String endpointName, String version, String apiType, User user) throws IOException {

        Map<String, Object> endPointDomain = new HashMap<>();

        String query = ENDPOINTNAME_WITH_COLON + endpointName + AND_APIVERSION_WITH_COLON + version
                + AND_OPEN_BRACKET_APITYPE_WITH_COLON + apiType + OR_APITYPE_COLON_BOTH_CLOSE_BRACKET;
        List<Map<String, Object>> endpointResultSet = SFInterfaceBase.fetchWhooshRecords(ENDPOINT_DETAILS, query, null, null
                , null, null, null, null, NUM_ZERO, Boolean.FALSE, user);
        if (endpointResultSet.size() == NUM_ONE) {
            endPointDomain = endpointResultSet.get(NUM_ZERO);
        } else {
            if (endpointResultSet.size() == NUM_ZERO) {
                endPointDomain = SFInterfaceServices.getErrorMap("ERROR.MESSAGE.ENDPOINTNOTFOUND", null, endpointName);
            } else if (endpointResultSet.size() > NUM_ONE) {
                endPointDomain = SFInterfaceServices.getInfoMap("INFO.MESSAGE.RETURNTOOMANYROWS", String.valueOf(endpointResultSet.size()), endpointName);
                String message = (String) endPointDomain.get(MESSAGE);
                endPointDomain.put(MESSAGE, endpointName + HYPHEN + message);
            }
        }

        return endPointDomain;
    }

    public static List<Map<String, Object>> fetchEndpointFields(String endpointsk, User user) {
        String query = ENDPOINTSK_WITH_COLON + endpointsk + "\" AND Status: \"1\" ";
        List<Map<String, Object>> endpointResultSet = SFInterfaceBase.fetchWhooshRecords(ENDPOINT_FIELDS, query, null, null
                , null, null, null, null, NUM_ZERO, Boolean.FALSE, user);
        return endpointResultSet;
    }


    public static File convertMultiPartToFile(MultipartFile file, String fileName, String filePath) throws IOException {
        File convFile = null;
        Path indexFile = Paths.get(filePath);
        if (!indexFile.toFile().exists()) {
            indexFile.toFile().mkdirs();
        }
        convFile = new File(filePath + fileName);
        FileOutputStream fos = new FileOutputStream(convFile);
        fos.write(file.getBytes());
        fos.close();
        return convFile;
    }

    public static String getFilePath(Map<String, String[]> ticketFields, User user) throws IOException {

        String filePath = "", account_sk = "", masterAccount = "", account = "";

        account_sk = ticketFields.get(ACCOUNT)[NUM_ZERO];
        List<Map<String, Object>> masterAccounts = fetchWhooshRecords(FETCH_ALL_ACCOUNTS, DOUBLE_ASTERISK, null, new String[]{ACCOUNT_SK, ACCOUNT, MASTER_ACCOUNT}
                , null, null, null, null, NUM_ZERO, Boolean.FALSE, user);

        for (int i = NUM_ZERO; i < masterAccounts.size(); i++) {
            Map<String, Object> master_Account = (Map<String, Object>) masterAccounts.get(i);
            if (master_Account.get(ACCOUNT_SK).toString().equalsIgnoreCase(account_sk)) {
                account = (String) master_Account.get(ACCOUNT);
                masterAccount = (String) master_Account.get(MASTER_ACCOUNT);
            }
        }

        if (!ticketFields.get(TICKET_NUMBER)[NUM_ZERO].isEmpty()) {
            if (ticketFields.get(TICKET_NUMBER)[NUM_ZERO].contains(INC)) {
                filePath = Constants.getRefDBfileattachmentpath() + masterAccount + DOUBLE_BACKSLASH + account + DOUBLE_BACKSLASH + INC + DOUBLE_BACKSLASH;
            } else if (ticketFields.get(TICKET_NUMBER)[NUM_ZERO].contains(SRT)) {
                filePath = Constants.getRefDBfileattachmentpath() + masterAccount + DOUBLE_BACKSLASH + account + DOUBLE_BACKSLASH + SRT + DOUBLE_BACKSLASH;
            } else if (ticketFields.get(TICKET_NUMBER)[NUM_ZERO].contains(SR)) {
                filePath = Constants.getRefDBfileattachmentpath() + masterAccount + DOUBLE_BACKSLASH + account + DOUBLE_BACKSLASH + SR + DOUBLE_BACKSLASH;
            } else if (ticketFields.get(TICKET_NUMBER)[NUM_ZERO].contains(SUP)) {
                filePath = Constants.getRefDBfileattachmentpath() + DOUBLE_BACKSLASH + ticketFields.get(BUSINESS_FUNC)[NUM_ZERO] + DOUBLE_BACKSLASH + ticketFields.get(TICKET_NUMBER)[NUM_ZERO];
            }
        }

        return filePath;
    }

    public static String getAttachments(org.springframework.web.multipart.MultipartHttpServletRequest multiPartRequest, Map<String, String[]> ticketFields, User user) throws IOException {

        String attachmentDetails = "";
        List<String> secure_attach = new ArrayList<>();

        if (ticketFields.containsKey(SECURE_PATIENT_ATTACHMENTS)) {
            secure_attach = Arrays.asList(ticketFields.get(SECURE_PATIENT_ATTACHMENTS)[NUM_ZERO].toString().split(COMMA));
        }

        if (StringUtils.isNotBlank(multiPartRequest.getContentType()) && multiPartRequest.getContentType().startsWith(MULTIPART_FORM_DATA)) {
            MultiValueMap<String, MultipartFile> attachments = multiPartRequest.getMultiFileMap();
            for (Map.Entry<String, List<MultipartFile>> stringListEntry : attachments.entrySet()) {
                for (MultipartFile multipartFile : stringListEntry.getValue()) {
                    if (StringUtils.isBlank(attachmentDetails)) {
                        if (secure_attach.size() > NUM_ZERO && secure_attach.contains(multipartFile.getOriginalFilename())) {
                            attachmentDetails = OPEN_BRACE + multipartFile.getOriginalFilename() + COMMA + multipartFile.getSize() + COMMA +
                                    FilenameUtils.getExtension(multipartFile.getOriginalFilename()) + COMMA + SECURE + COMMA +
                                    getFilePath(ticketFields, user) + DOUBLE_BACKSLASH + new SimpleDateFormat(DATETIME_FORMAT).format(new Date())
                                    + UNDERSCORE + multipartFile.getOriginalFilename() + CLOSE_BRACE;
                        } else {
                            attachmentDetails = OPEN_BRACE + multipartFile.getOriginalFilename() + COMMA + multipartFile.getSize() + COMMA +
                                    FilenameUtils.getExtension(multipartFile.getOriginalFilename()) + COMMA + NORMAL + COMMA +
                                    getFilePath(ticketFields, user) + DOUBLE_BACKSLASH + new SimpleDateFormat(DATETIME_FORMAT).format(new Date())
                                    + UNDERSCORE + multipartFile.getOriginalFilename() + CLOSE_BRACE;
                        }
                    } else {
                        if (secure_attach.size() > NUM_ZERO && secure_attach.contains(multipartFile.getOriginalFilename())) {
                            attachmentDetails = attachmentDetails + SINGLE_PIPE + OPEN_BRACE + multipartFile.getOriginalFilename() + COMMA +
                                    multipartFile.getSize() + COMMA + FilenameUtils.getExtension(multipartFile.getOriginalFilename()) + COMMA + SECURE + COMMA +
                                    getFilePath(ticketFields, user) + DOUBLE_BACKSLASH + new SimpleDateFormat(DATETIME_FORMAT).format(new Date())
                                    + UNDERSCORE + multipartFile.getOriginalFilename() + CLOSE_BRACE;
                        } else {
                            attachmentDetails = attachmentDetails + SINGLE_PIPE + OPEN_BRACE + multipartFile.getOriginalFilename() + COMMA +
                                    multipartFile.getSize() + COMMA + FilenameUtils.getExtension(multipartFile.getOriginalFilename()) + COMMA + NORMAL + COMMA +
                                    getFilePath(ticketFields, user) + DOUBLE_BACKSLASH + new SimpleDateFormat(DATETIME_FORMAT).format(new Date())
                                    + UNDERSCORE + multipartFile.getOriginalFilename() + CLOSE_BRACE;
                        }
                    }
                }
            }
        }

        return attachmentDetails;
    }

    public static <Resultset> Map<File, byte[]> postToFileServer(MultipartHttpServletRequest multiPartRequest, Map<String, String[]> ticketFields, String attachmentDetails, User user) throws IOException {

        Map<File, byte[]> attach = new TreeMap<>();
        File newFile = null;
        String filePath = "";
        String[] attachDetails = attachmentDetails.split(CLOSE_BRACE);

        if (StringUtils.isNotBlank(multiPartRequest.getContentType()) && multiPartRequest.getContentType().startsWith(MULTIPART_FORM_DATA)) {
            MultiValueMap<String, MultipartFile> attachments = multiPartRequest.getMultiFileMap();
            for (Map.Entry<String, List<MultipartFile>> stringListEntry : attachments.entrySet()) {
                File[] files = new File[stringListEntry.getValue().size() + NUM_ONE];
                int i = NUM_ZERO;
                for (MultipartFile multipartFile : stringListEntry.getValue()) {
                    for (String attach_Details : attachDetails) {
                        attach_Details = attach_Details.substring(NUM_ONE);
                        String[] attachment = attach_Details.split(COMMA);
                        if (attachment[NUM_ZERO].equalsIgnoreCase(multipartFile.getOriginalFilename())) {
                            newFile = SFInterfaceBase.convertMultiPartToFile(multipartFile, new File(attachment[NUM_FOUR]).getName(), getFilePath(ticketFields, user));
                            attach.put(newFile, multipartFile.getBytes());
                            files[i] = newFile;
                            i++;
                        }
                    }
                }
            }
        }

        return attach;
    }

    public static Boolean deleteFilesInFileServer(Map<File, byte[]> deleteFiles) throws IOException {

        ZipEntry e = null;
        Set<Map.Entry<File, byte[]>> delFiles = deleteFiles.entrySet();

        if (deleteFiles.size() > NUM_ZERO) {
            for (Map.Entry<File, byte[]> file : deleteFiles.entrySet()) {

                findFileName(file.getKey().getName());

                //writing file data to archive folder
                byte[] data = file.getValue();
                fileArchiver().write(data, NUM_ZERO, data.length);
                fileArchiver().closeEntry();

                //after writing the data, delete the file in 'server' path
                File del = file.getKey();
                if (del.exists()) {
                    del.delete();
                }

                //to remove the folder, if it doesn't contain any files
                Path deleteFilePath = Paths.get(FilenameUtils.getFullPath(String.valueOf(del)));
                if (deleteFilePath.toFile().listFiles().length == NUM_ZERO) {
                    deleteDirectory(del);
                }
            }
        }

        return true;
    }

    private static void findFileName(String file_NametoZip) throws IOException {

        try {
            fileArchiver().putNextEntry(new ZipEntry(file_NametoZip));
        } catch (Exception ex) {
            String fileNametoZip = DUPLICATE + file_NametoZip;
            findFileName(fileNametoZip);
        }
    }

    public static void deleteDirectory(File dir) throws IOException {

        File directory = new File(FilenameUtils.getFullPath(String.valueOf(dir)));
        FileUtils.deleteDirectory(directory);

    }

    public static Boolean deleteAttachments(Map<String, String[]> ticketFields, Map<String, Object> delAttach) throws IOException {

        Map<File, byte[]> delFiles = new HashMap<>();
        String[] attach = delAttach.get(DELETED_ATTACHMENTS).toString().split(CLOSE_BRACE);
        String fileName = "", filePath = "", filePathToDelete = "";

        for (String deleteAttach : attach) {
            if (deleteAttach.contains(CLOSE_BRACE)) {
                deleteAttach = deleteAttach.substring(NUM_ONE, deleteAttach.length() - NUM_ONE);
            } else {
                deleteAttach = deleteAttach.substring(NUM_ONE);
            }
            String[] keyValuePairs = deleteAttach.split(COMMA);
            for (String pair : keyValuePairs) {
                String[] entry = pair.split(EQUAL);
                Map<String, String> map = new HashMap<>();
                map.put(entry[NUM_ZERO].trim(), entry[NUM_ONE].trim());
                if (map.containsKey(FILE_PATH)) {
                    filePath = map.get(FILE_PATH);
                    filePathToDelete = filePath + DOUBLE_BACKSLASH;

                    //to write in archive, read the content from the file to be deleted
                    byte[] fileContent = null;
                    File file = new File(filePathToDelete);
                    fileContent = Files.readAllBytes(Paths.get(String.valueOf(file)));

                    delFiles.put(new File(filePathToDelete), fileContent);
                    filePathToDelete = null;
                }
            }
        }

        if (delFiles.size() > NUM_ZERO) {
            deleteFilesInFileServer(delFiles);
            return true;
        } else {
            return false;
        }
    }

   /* public static Map<String, Object> getResultSet(JdbcTemplate refTemplate, String endpointName, String loginID) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        String sqlQuery = "";
        String qualificationString = AND + Constants.LoginID + EQUAL_AND_QUESTION_MARK;

        try {
            List<IndexerDomain> indexerDomains = lucIndexerRepo.findByStatussk(Constants.INDEXER_STATUS_SK);

            if (indexerDomains.size() > NUM_ZERO) {

                for (IndexerDomain indexerDomain : indexerDomains) {
                    if (endpointName.equalsIgnoreCase(indexerDomain.getName())) {
                        sqlQuery = indexerDomain.getQuery();
                    }
                }
                sqlQuery = sqlQuery + qualificationString;
                SqlParameter varString = new SqlParameter(Types.VARCHAR);
                List<SqlParameter> paramList = new ArrayList<SqlParameter>();
                paramList.add(varString);
                Map<String, Object> resultMap = new LinkedHashMap<>();
                try {
                    String finalSqlQuery = sqlQuery;
                    resultMap = refTemplate.call(new CallableStatementCreator() {
                        @Override
                        public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                            CallableStatement callableStatement = connection.prepareCall(finalSqlQuery);
                            callableStatement.setString(NUM_ONE, loginID);
                            return callableStatement;
                        }
                    }, paramList);
                } catch (Exception e) {
                    SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                    queryObject.put(ERROR_MESSAGE, SFInterfaceServices.ISPExceptionHandler(e, null, endpointName).get(ERROR));
                }

                if (resultMap.containsKey(RESULT_SET_1)) {
                    List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                    if (queryList.size() > NUM_ZERO) {
                        for (int i = NUM_ZERO; i < queryList.size(); i++) {
                            if (i == NUM_ZERO) {
                                queryObject.put(RESULT_SET, (Map<String, Object>) queryList.get(i));
                            } else {
                                Map<String, Object> queryResult = (Map<String, Object>) queryList.get(i);
                                queryObject.put(RESULT_SET, queryObject.get(RESULT_SET) + "" + queryResult);
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject.put(ERROR_MESSAGE, SFInterfaceServices.ISPExceptionHandler(e, null, endpointName).get(ERROR));
        }

        return queryObject;
    }*/

    public static Map<String, Object> getCountofSupportGroups(List<Map<String, Object>> result) {

        Map<String, Object> resultSet = new HashMap<>();
        String GroupName = "";

        for (Map<String, Object> results : result) {
            if (StringUtils.isBlank(GroupName)) {
                GroupName = (String) results.get(GROUP_NAME);
            } else {
                GroupName = GroupName + COMMA + (String) results.get(GROUP_NAME);
            }
        }

        resultSet.put(GROUP_NAME, GroupName);
        resultSet.put(COUNT_OF_SUPPORT_GROUP, result.size());

        return resultSet;
    }

    public static Map<String, Object> isValidAccounts(String accountCode, String masterAccountCode, String masterAccountsk, String accountsk, User user) {
        Map<String, Object> response = new HashMap<>();
        String accountQuery = "";
        if (StringUtils.isNotBlank(accountCode)) {
            accountQuery = ACCOUNT_WITH_COLON + accountCode + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(masterAccountCode)) {
            if (StringUtils.isNotBlank(accountQuery))
                accountQuery += AND + MASTERACCOUNT_WITH_COLON + masterAccountCode + ESCAPE_CHARACTER;
            else
                accountQuery = MASTERACCOUNT_WITH_COLON + masterAccountCode + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(masterAccountsk)) {
            if (StringUtils.isNotBlank(accountQuery))
                accountQuery += AND + MASTERACCOUNTSK_WITH_COLON + masterAccountsk + ESCAPE_CHARACTER;
            else
                accountQuery = MASTERACCOUNTSK_WITH_COLON + masterAccountsk + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(accountsk)) {
            if (StringUtils.isNotBlank(accountQuery))
                accountQuery += AND + ACCOUNT_SK + COLON + ESCAPE_CHARACTER + accountsk + ESCAPE_CHARACTER;
            else
                accountQuery = ACCOUNT_SK + COLON + ESCAPE_CHARACTER + accountsk + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(accountQuery)) {
            List<Map<String, Object>> accountList = SFInterfaceBase.fetchWhooshRecords(ACCOUNT, accountQuery, null, null, null, null, null, null
                    , NUM_ZERO, Boolean.FALSE, user);
            if (accountList.size() > NUM_ZERO && !accountList.contains(ERROR)) {
                if (!user.getClient().equalsIgnoreCase(CTS)) {
                    List<Map<String, Object>> useraccessibleaccountList = SFInterfaceBase.fetchWhooshRecords(ACCOUNT, MASTER_ACCOUNT + COLON + user.getMasterclient() + MASTER_ACCOUNT + COLON + CTS,
                            null, new String[]{ACCOUNT}, null, null, null, null
                            , NUM_ZERO, Boolean.FALSE, user);
                    Boolean notmatch = accountList.stream().anyMatch(account -> {
                        return !useraccessibleaccountList.parallelStream().anyMatch(useraccount -> account.get(ACCOUNT).toString().equalsIgnoreCase(useraccount.get(ACCOUNT).toString()));
                    });
                    if (!notmatch) {
                        response.put("AccountValid", "true");
                        response.put("message", "true");
                        return response;
                    } else {
                        response.put("AccountValid", "false");
                        response.put("message", "Invalid Account");
                        return response;
                    }
                    // response.put("AccountValid", "true");
                } else {
                    response.put("AccountValid", "true");
                    response.put("message", "true");
                    return response;
                }
            }
        }
        response.put("AccountValid", "false");
        response.put("message", "Account Not Present");
        return response;
    }

    public static Boolean isValidAccount(String accountCode, String masterAccountCode, String masterAccountsk, String accountsk, User user) {
        String accountQuery = "";
        if (StringUtils.isNotBlank(accountCode)) {
            accountQuery = ACCOUNT_WITH_COLON + accountCode + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(masterAccountCode)) {
            if (StringUtils.isNotBlank(accountQuery))
                accountQuery += AND + MASTERACCOUNT_WITH_COLON + masterAccountCode + ESCAPE_CHARACTER;
            else
                accountQuery = MASTERACCOUNT_WITH_COLON + masterAccountCode + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(masterAccountsk)) {
            if (StringUtils.isNotBlank(accountQuery))
                accountQuery += AND + MASTERACCOUNTSK_WITH_COLON + masterAccountsk + ESCAPE_CHARACTER;
            else
                accountQuery = MASTERACCOUNTSK_WITH_COLON + masterAccountsk + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(accountsk)) {
            if (StringUtils.isNotBlank(accountQuery))
                accountQuery += AND + ACCOUNT_SK + COLON + ESCAPE_CHARACTER + accountsk + ESCAPE_CHARACTER;
            else
                accountQuery = ACCOUNT_SK + COLON + ESCAPE_CHARACTER + accountsk + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(accountQuery)) {
            List<Map<String, Object>> accountList = SFInterfaceBase.fetchWhooshRecords(ACCOUNT, accountQuery, null, null, null, null, null, null
                    , NUM_ZERO, Boolean.FALSE, user);
            if (accountList.size() > NUM_ZERO && !accountList.contains(ERROR)) {
               /* if (!user.getClient().equalsIgnoreCase(CTS)) {
                    List<Map<String, Object>> useraccessibleaccountList = SFInterfaceBase.fetchWhooshRecords(ACCOUNT, MASTER_ACCOUNT + COLON + user.getMasterclient() + MASTER_ACCOUNT + COLON + CTS,
                            null, new String[]{ACCOUNT}, null, null, null, null
                            , NUM_ZERO, Boolean.FALSE, user);
                    Boolean notmatch = accountList.stream().anyMatch(account -> {
                        return !useraccessibleaccountList.parallelStream().anyMatch(useraccount -> account.get(ACCOUNT).toString().equalsIgnoreCase(useraccount.get(ACCOUNT).toString()));
                    });
                    return Boolean.FALSE;
                }*/
                return Boolean.TRUE;
            }
        }
        return Boolean.FALSE;
    }

    public static Boolean isValidUser(String userSK, String loginID, User user) {
        String userQuery = "";
        if (StringUtils.isNotBlank(userSK)) {
            userQuery = USER_SK_WITH_COLON + userSK + ESCAPE_CHARACTER;
        }
        if (StringUtils.isNotBlank(loginID)) {
            if (StringUtils.isNotBlank(userQuery))
                userQuery += AND + OPEN_BRACKET + LOGINID_WITH_COLON + loginID + ESCAPE_CHARACTER + OR + NETWORK_LOGIN + COLON + loginID + OR + REFID_3 + COLON + loginID + OR + REFID_4 + COLON + loginID + CLOSE_BRACKET;
            else
                userQuery = OPEN_BRACKET + LOGINID_WITH_COLON + loginID + ESCAPE_CHARACTER + OR + NETWORK_LOGIN + COLON + loginID + OR + REFID_3 + COLON + loginID + OR + REFID_4 + COLON + loginID + CLOSE_BRACKET;
        }

        if (StringUtils.isNotBlank(userQuery)) {
            List<Map<String, Object>> userList = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, userQuery, null
                    , null, null, null, null, null, NUM_ZERO, Boolean.FALSE, user);
            if (userList.size() > NUM_ZERO && !userList.contains(ERROR)) {
                return Boolean.TRUE;
            }
        }

        return Boolean.FALSE;
    }

    public static Map<String, Object> createIndexer(IndexWritersModel writerModel, String indexername, String query, String indexerkey
            , JdbcTemplate template) throws IOException {
        writerModel.setAvailable(false);
        writerModel.getIndexWriter().deleteAll();
        Map<String, Object> indexerStatusResult = new HashMap<>();
        try {
            template.query(query, new RowCallbackHandler() {
                @Override
                public void processRow(ResultSet resultSet) throws SQLException {
                    int columnCount = resultSet.getMetaData().getColumnCount();
                    do {
                        Document doc = new Document();
                        for (int irow = 1; irow <= columnCount; irow++) {
                            if (resultSet.getMetaData().getColumnName(irow).equalsIgnoreCase(indexerkey)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow), Field.Store.YES));
                                if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_INT) || resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_SK)) {
                                    doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : Integer.parseInt(resultSet.getString(irow).trim())));
                                } else {
                                    doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                                }
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow).replace(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT, ""), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow).replace(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT, ""), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_INT) || resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_SK)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : Integer.parseInt(resultSet.getString(irow).trim())));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(INDEXER_ALIAS_COLUMN_NAME_ON)
                                    && resultSet.getMetaData().getColumnType(irow) == Types.TIMESTAMP
                                    && resultSet.getMetaData().getColumnTypeName(irow).equalsIgnoreCase(DATETIME)
                            ) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getDate(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : ((SQLServerResultSet42) resultSet).getDateTime(irow).getTime()));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(INDEXER_ALIAS_COLUMN_NAME_ON)
                                    && resultSet.getMetaData().getColumnType(irow) == Types.TIMESTAMP) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getDate(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : resultSet.getDate(irow).getTime()));
                            } else if (resultSet.getMetaData().getColumnType(irow) == INTEGER || resultSet.getMetaData().getColumnType(irow) == Types.BIT || resultSet.getMetaData().getColumnType(irow) == Types.BIGINT) {
                                doc.add(new TextField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            } else {
                                doc.add(new TextField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            }
                        }
                        try {
                            writerModel.getIndexWriter().addDocument(doc);
                        } catch (IOException e) {
                            SFInterfaceLoggerBase.exception(LOGGER, INDEX_NAME + COLON + indexername, e);
                            try {
                                indexerStatusResult.put(RESPONSE, (String) SFInterfaceServices.ISPExceptionHandler(e, null, null).get(ERROR));
                            } catch (IOException ioException) {
                                SFInterfaceLoggerBase.exception(LOGGER, null, ioException);
                            }
                        }
                    } while (resultSet.next());

                    indexerStatusResult.put(RESPONSE, SUCCESS);
                }
            });

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, INDEX_NAME + COLON + indexername, e);
            indexerStatusResult.put(RESPONSE, (String) SFInterfaceServices.ISPExceptionHandler(e, null, null).get(ERROR));
        } finally {
            if (writerModel.getIndexWriter() != NULL) {
                writerModel.getIndexWriter().commit();
                writerModel.setAvailable(true);
            }
        }
        return indexerStatusResult;
    }

    public static Boolean updateindexer(IndexWriter writer, String indexername, String query, String indexerkey, JdbcTemplate template, String[] ticketid, User user) throws Exception {
        Boolean returnStatus = Boolean.FALSE;
        Map<String, String[]> params = new HashMap<>();
        if (indexername.equalsIgnoreCase(INDEXERNAME_FETCH_INCIDENT)) {
            IndexerDomain indexerDomain = IndexerUtilities.findByNameAndStatussk(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), INDEXERNAME_FULL_TEXT_SEARCH);
            params.put(BUSINESS_FUNCTION_CODE, new String[]{INCIDENTS});
            params.put(TICKET, ticketid);
            getDBQuery(indexerDomain.getQuery(), params);
            updateindexer(SFInterfaceConnectionBase.fetchIndexerWriterModal(user, INDEXERNAME_FULL_TEXT_SEARCH).getIndexWriter(), INDEXERNAME_FULL_TEXT_SEARCH, getDBQuery(indexerDomain.getQuery(), params),
                    indexerDomain.getIndexerkeyaliasname(), template, Boolean.TRUE, ticketid);

        } else if (indexername.equalsIgnoreCase(INDEXERNAME_FETCH_SERVICE_REQUEST)) {
            IndexerDomain indexerDomain = IndexerUtilities.findByNameAndStatussk(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), INDEXERNAME_FULL_TEXT_SEARCH);
            params.put(BUSINESS_FUNCTION_CODE, new String[]{SR});
            params.put(TICKET, ticketid);
            getDBQuery(indexerDomain.getQuery(), params);
            updateindexer(SFInterfaceConnectionBase.fetchIndexerWriterModal(user, INDEXERNAME_FULL_TEXT_SEARCH).getIndexWriter(), INDEXERNAME_FULL_TEXT_SEARCH, getDBQuery(indexerDomain.getQuery(), params),
                    indexerDomain.getIndexerkeyaliasname(), template, Boolean.TRUE, ticketid);
        } else if (indexername.equalsIgnoreCase(INDEXERNAME_FETCH_SERVICE_REQUEST_TASK)) {
            IndexerDomain indexerDomain = IndexerUtilities.findByNameAndStatussk(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), INDEXERNAME_FULL_TEXT_SEARCH);
            params.put(BUSINESS_FUNCTION_CODE, new String[]{SRT});
            params.put(TICKET, ticketid);
            getDBQuery(indexerDomain.getQuery(), params);
            updateindexer(SFInterfaceConnectionBase.fetchIndexerWriterModal(user, INDEXERNAME_FULL_TEXT_SEARCH).getIndexWriter(), INDEXERNAME_FULL_TEXT_SEARCH, getDBQuery(indexerDomain.getQuery(), params),
                    indexerDomain.getIndexerkeyaliasname(), template, Boolean.TRUE, ticketid);
        }
        returnStatus = updateindexer(writer, indexername, query, indexerkey, template, Boolean.TRUE, ticketid);
        SFInterfaceLoggerBase.log(LOGGER, "Indexer Sync- Indexername:" + indexername + " TicketID:" + (ticketid != null ? Arrays.asList(ticketid).toString() : NA) + " Status:" + returnStatus);
        return returnStatus;
    }

    public static Boolean updateindexer(IndexWriter writer, String indexername, String query, String indexerkey, JdbcTemplate template, Boolean checkindexer, String[] ticketID) throws IOException {

        Boolean IndexerStatus = Boolean.TRUE;
        List<String> tempticketID = new ArrayList<>();
        try {
            template.query(query, new RowCallbackHandler() {
                @Override
                public void processRow(ResultSet resultSet) throws SQLException {
                    int columnCount = resultSet.getMetaData().getColumnCount();
                    do {
                        Document doc = new Document();
                        String indexerkeyvalue = "";
                        for (int irow = 1; irow <= columnCount; irow++) {
                            if (resultSet.getMetaData().getColumnName(irow).equalsIgnoreCase(indexerkey)) {
                                indexerkeyvalue = resultSet.getString(irow);
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), indexerkeyvalue, Field.Store.YES));
                                if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_INT) || resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_SK)) {
                                    doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : Integer.parseInt(resultSet.getString(irow).trim())));
                                } else {
                                    doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                                }
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow).replace(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT, ""), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow).replace(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT, ""), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_INT) || resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_SK)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : Integer.parseInt(resultSet.getString(irow).trim())));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(INDEXER_ALIAS_COLUMN_NAME_ON)
                                    && resultSet.getMetaData().getColumnType(irow) == Types.TIMESTAMP
                                    && resultSet.getMetaData().getColumnTypeName(irow).equalsIgnoreCase(DATETIME)
                            ) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getDate(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : ((SQLServerResultSet42) resultSet).getDateTime(irow).getTime()));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(INDEXER_ALIAS_COLUMN_NAME_ON)
                                    && resultSet.getMetaData().getColumnType(irow) == Types.TIMESTAMP) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getDate(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : resultSet.getDate(irow).getTime()));
                            } else if (resultSet.getMetaData().getColumnType(irow) == INTEGER || resultSet.getMetaData().getColumnType(irow) == Types.BIT || resultSet.getMetaData().getColumnType(irow) == Types.BIGINT) {
                                doc.add(new TextField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            } else {
                                doc.add(new TextField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            }
                        }
                        try {
                            writer.updateDocument(new Term(indexerkey, indexerkeyvalue), doc);
                            //    writer.updateDocument(new Term())
                            tempticketID.add(indexerkeyvalue);
                            SFInterfaceLoggerBase.log(LOGGER, "Indexer:" + indexername + " record has been updated:" + indexerkeyvalue);
                        } catch (IOException e) {
                            SFInterfaceLoggerBase.exception(LOGGER, INDEX_NAME + COLON + indexername, e);
                        }
                        //indexerIntf.addDocumentWithoutCommit(writer, entries);
                    } while (resultSet.next());
                }
            });

            List<String> unavailable = Arrays.asList(ticketID).stream()
                    .filter(e -> !tempticketID.contains(e))
                    .collect(Collectors.toList());
            unavailable.stream().forEach(s -> {
                try {
                    writer.deleteDocuments(new Term(indexerkey, s));
                    SFInterfaceLoggerBase.log(LOGGER, "Indexer:" + indexername + " record has been deleted:" + s);
                } catch (IOException e) {
                }
            });
        } catch (Exception e) {
            IndexerStatus = Boolean.FALSE;
            SFInterfaceLoggerBase.exception(LOGGER, INDEX_NAME + COLON + indexername, e);
        } finally {
            if (writer != NULL) {
                writer.commit();
            }
        }
        return IndexerStatus;
    }

    /*public static Boolean updateindexer(IndexWriter writer, String indexername, String query, String indexerkey, JdbcTemplate template, Boolean checkindexer, String[] ticketID) throws IOException {

        Boolean IndexerStatus = Boolean.TRUE;
        List<String> tempticketID = new ArrayList<>();
        try {
            template.query(query, new RowCallbackHandler() {
                @Override
                public void processRow(ResultSet resultSet) throws SQLException {
                    int columnCount = resultSet.getMetaData().getColumnCount();
                    do {
                        Document doc = new Document();
                        String indexerkeyvalue = "";
                        for (int irow = 1; irow <= columnCount; irow++) {
                            if (resultSet.getMetaData().getColumnName(irow).equalsIgnoreCase(indexerkey)) {
                                indexerkeyvalue = resultSet.getString(irow);
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), indexerkeyvalue, Field.Store.YES));
                                if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_INT) || resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_SK)) {
                                    doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : Integer.parseInt(resultSet.getString(irow).trim())));
                                } else {
                                    doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                                }
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow).replace(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT, ""), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow).replace(Constants.INDEXER_ALIAS_COLUMN_NAME_EXACT, ""), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_INT) || resultSet.getMetaData().getColumnName(irow).endsWith(Constants.INDEXER_ALIAS_COLUMN_NAME_SK)) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : Integer.parseInt(resultSet.getString(irow).trim())));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(INDEXER_ALIAS_COLUMN_NAME_ON)
                                    && resultSet.getMetaData().getColumnType(irow) == Types.TIMESTAMP
                                    && resultSet.getMetaData().getColumnTypeName(irow).equalsIgnoreCase(DATETIME)
                            ) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getDate(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : ((SQLServerResultSet42) resultSet).getDateTime(irow).getTime()));
                            } else if (resultSet.getMetaData().getColumnName(irow).endsWith(INDEXER_ALIAS_COLUMN_NAME_ON)
                                    && resultSet.getMetaData().getColumnType(irow) == Types.TIMESTAMP) {
                                doc.add(new StringField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow), Field.Store.YES));
                                doc.add(new SortedNumericDocValuesField(resultSet.getMetaData().getColumnName(irow), resultSet.getDate(irow) == null ? Constants.INDEXER_NULL_INT_CHECK : resultSet.getDate(irow).getTime()));
                            } else if (resultSet.getMetaData().getColumnType(irow) == INTEGER || resultSet.getMetaData().getColumnType(irow) == Types.BIT || resultSet.getMetaData().getColumnType(irow) == Types.BIGINT) {
                                doc.add(new TextField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            } else {
                                doc.add(new TextField(resultSet.getMetaData().getColumnName(irow), resultSet.getString(irow) == null ? Constants.INDEXER_NULL_CHECK : resultSet.getString(irow).trim(), Field.Store.YES));
                                doc.add(new SortedDocValuesField(resultSet.getMetaData().getColumnName(irow), new BytesRef(resultSet.getString(irow) == null ? Constants.INDEXER_SORT_NULL_CHECK : resultSet.getString(irow).trim())));
                            }
                        }
                        try {
                            writer.updateDocument(new Term(indexerkey, indexerkeyvalue), doc);
                            //    writer.updateDocument(new Term())
                            tempticketID.add(indexerkeyvalue);
                            SFInterfaceLoggerBase.log(LOGGER, "Indexer:" + indexername + " record has been updated:" + indexerkeyvalue);
                        } catch (IOException e) {
                            SFInterfaceLoggerBase.exception(LOGGER, INDEX_NAME + COLON + indexername, e);
                        }
                        //indexerIntf.addDocumentWithoutCommit(writer, entries);
                    } while (resultSet.next());
                }
            });

            List<String> unavailable = Arrays.asList(ticketID).stream()
                    .filter(e -> !tempticketID.contains(e))
                    .collect(Collectors.toList());
            unavailable.stream().forEach(s -> {
                try {
                    writer.deleteDocuments(new Term(indexerkey, s));
                    SFInterfaceLoggerBase.log(LOGGER, "Indexer:" + indexername + " record has been deleted:" + s);
                } catch (IOException e) {
                }
            });
        } catch (Exception e) {
            IndexerStatus = Boolean.FALSE;
            SFInterfaceLoggerBase.exception(LOGGER, INDEX_NAME + COLON + indexername, e);
        } finally {
            if (writer != NULL) {
                writer.commit();
            }
        }
        return IndexerStatus;
    }*/

    public static CustomWhooshModel generateWhooshModel(Map<String, String[]> params1, User user) {
        return generateWhooshModel(params1, Boolean.FALSE, null, user);
    }

    public static CustomWhooshModel generateWhooshModel(Map<String, String[]> params1, String endpoint_sk, User user) {
        return generateWhooshModel(params1, Boolean.FALSE, endpoint_sk, user);
    }

    public static CustomWhooshModel generateWhooshModel(Map<String, String[]> params1, Boolean dynamic, String endpoint_sk, User user) {
        return generateWhooshModel(params1, dynamic, endpoint_sk, Boolean.FALSE, user);
    }

    public static CustomWhooshModel generateWhooshModel(Map<String, String[]> params1, Boolean dynamic, String endpoint_sk, Boolean whooshlike, User user) {
        return generateWhooshModel(params1, dynamic, endpoint_sk, Boolean.FALSE, Boolean.FALSE, user);
    }

    public static CustomWhooshModel generateWhooshModel(Map<String, String[]> params1, Boolean dynamic, String endpoint_sk, Boolean whooshlike, Boolean defaultnull, User user) {

        CustomWhooshModel customWhooshModel = new CustomWhooshModel();
        Map<String, String[]> params = new HashMap<>();
        int count = NUM_ZERO, pageno = NUM_ONE;

        for (Map.Entry<String, String[]> stringEntry : params1.entrySet()) {
            if (!stringEntry.getKey().equalsIgnoreCase(PAGE_NUMBER) && !stringEntry.getKey().equalsIgnoreCase(COUNT)
                    && !stringEntry.getKey().equalsIgnoreCase(DISTINCTFIELD) && !stringEntry.getValue()[NUM_ZERO].equalsIgnoreCase(VOID)
                    && !stringEntry.getKey().equalsIgnoreCase(SORTFIELD) && !stringEntry.getKey().equalsIgnoreCase(SORTORDER)
                    && !stringEntry.getKey().equalsIgnoreCase(Constants.SELECTEDFIELDS) && !stringEntry.getKey().equalsIgnoreCase(DISTINCT) && !stringEntry.getKey().equalsIgnoreCase(DEFAULT_JSON)) {
                params.put(stringEntry.getKey(), stringEntry.getValue());
            }
        }
        String[] requiredColumns = null;
        Sort sort = new Sort();
        String sortorder = ASC;
        String sortfields = null;
        String distinctfield = null;
        String distinct = "";

        Map<String, String> fieldaliass = new HashMap<>();
        if (params1.containsKey(SORTFIELD) && !params1.get(SORTFIELD)[NUM_ZERO].equalsIgnoreCase(VOID)) {
            if (params1.containsKey(SORTORDER)) {
                sortorder = params1.get(SORTORDER)[NUM_ZERO];
            }
            sortfields = params1.get(SORTFIELD)[NUM_ZERO];
        }

        if (params1.containsKey(DISTINCT)) {
            distinct = params1.get(DISTINCT)[NUM_ZERO].toString();
            if (params1.containsKey(DISTINCTFIELD)) {
                distinctfield = params1.get(DISTINCTFIELD)[NUM_ZERO];
            } else {
                distinctfield = params1.get(SORTFIELD)[NUM_ZERO];
            }
        }

        if (params.containsKey(LINK_NAME)) {
            params.remove(LINK_NAME);
        }
        count = params1.containsKey(COUNT) ? Integer.parseInt(params1.get(COUNT)[NUM_ZERO].toString()) : count;
        pageno = params1.containsKey(PAGE_NUMBER) ? Integer.parseInt(params1.get(PAGE_NUMBER)[NUM_ZERO].toString()) : pageno;

        List<String> selectedcolumns = new ArrayList<>();
        if (params1.containsKey(Constants.SELECTEDFIELDS)) {
            if (!params1.get(Constants.SELECTEDFIELDS)[NUM_ZERO].equalsIgnoreCase(VOID)) {
                for (String s : params1.get(Constants.SELECTEDFIELDS)) {
                    for (String s1 : Arrays.asList(s.split(COMMA))) {
                        selectedcolumns.add(s1);
                    }
                }
                requiredColumns = selectedcolumns.toArray(new String[]{});
            }
        } else {
            if (StringUtils.isNotBlank(endpoint_sk)) {
                List<Map<String, Object>> endpointFields = SFInterfaceBase.fetchEndpointFields(endpoint_sk, user);
                if (endpointFields.size() > NUM_ZERO && !endpointFields.get(NUM_ZERO).containsKey(ERRORCODE) && !endpointFields.get(NUM_ZERO).containsKey(INFOCODE)) {
                    for (Map<String, Object> fields : endpointFields) {
                        selectedcolumns.add(fields.get(FIELD_NAME).toString());
                        fieldaliass.put((String) fields.get(FIELD_NAME), (String) fields.get(ALIAS_NAME));
                        requiredColumns = selectedcolumns.toArray(new String[]{});
                    }
                }
            }
        }

        String query = "";
        if (defaultnull)
            query = generateWhooshQueryDynamicwithDefaultNULL(params);
        else if (dynamic)
            query = generateWhooshQueryDynamic(params);
        else if (whooshlike)
            query = generateWhooshQueryWithLike(params);
        else
            query = generateWhooshQuery(params);
        customWhooshModel.setDistinct(distinct);
        customWhooshModel.setQuery(query);
        customWhooshModel.setRequiredColumns(requiredColumns);
        customWhooshModel.setSort(sort);
        customWhooshModel.setSortfields(sortfields);
        customWhooshModel.setSortorder(sortorder);
        customWhooshModel.setParams(params);
        customWhooshModel.setFieldaliass(fieldaliass);
        customWhooshModel.setDistinctfield(distinctfield);
        customWhooshModel.setCount(count);
        customWhooshModel.setPageno(pageno);

        return customWhooshModel;
    }

    public static CustomWhooshModel generateWhooshModelForSP(Map<String, String[]> params1) {

        CustomWhooshModel customWhooshModel = new CustomWhooshModel();
        Map<String, String[]> params = new HashMap<>();
        int count = NUM_ZERO, pageno = NUM_ONE;

        for (Map.Entry<String, String[]> stringEntry : params1.entrySet()) {
            if (!stringEntry.getKey().equalsIgnoreCase(DISTINCTFIELD) && !stringEntry.getValue()[NUM_ZERO].equalsIgnoreCase(VOID)
                    && !stringEntry.getKey().equalsIgnoreCase(SORTFIELD) && !stringEntry.getKey().equalsIgnoreCase(SORTORDER)
                    && !stringEntry.getKey().equalsIgnoreCase(Constants.SELECTEDFIELDS) && !stringEntry.getKey().equalsIgnoreCase(DISTINCT)
                    && !stringEntry.getKey().equalsIgnoreCase(DEFAULT_JSON)) {
                params.put(stringEntry.getKey(), stringEntry.getValue());
            }
        }
        String[] requiredColumns = null;
        Sort sort = new Sort();
        String sortorder = ASC;
        String sortfields = null;
        String distinctfield = null;
        String distinct = "";

        Map<String, String> fieldaliass = new HashMap<>();
        if (params1.containsKey(SORTFIELD) && !params1.get(SORTFIELD)[NUM_ZERO].equalsIgnoreCase(VOID)) {
            if (params1.containsKey(SORTORDER)) {
                sortorder = params1.get(SORTORDER)[NUM_ZERO];
            }
            sortfields = params1.get(SORTFIELD)[NUM_ZERO];
        }

        if (params1.containsKey(DISTINCT)) {
            distinct = params1.get(DISTINCT)[NUM_ZERO].toString();
            if (params1.containsKey(DISTINCTFIELD)) {
                distinctfield = params1.get(DISTINCTFIELD)[NUM_ZERO];
            } else {
                distinctfield = params1.get(SORTFIELD)[NUM_ZERO];
            }
        }

        List<String> selectedcolumns = new ArrayList<>();
        if (params1.containsKey(Constants.SELECTEDFIELDS)) {
            if (!params1.get(Constants.SELECTEDFIELDS)[NUM_ZERO].equalsIgnoreCase(VOID)) {
                for (String s : params1.get(Constants.SELECTEDFIELDS)) {
                    for (String s1 : Arrays.asList(s.split(COMMA))) {
                        selectedcolumns.add(s1);
                    }
                }
                requiredColumns = selectedcolumns.toArray(new String[]{});
            }
        }
        count = params1.containsKey(COUNT) ? Integer.parseInt(params1.get(COUNT)[NUM_ZERO].toString()) : count;
        pageno = params1.containsKey(PAGE_NUMBER) ? Integer.parseInt(params1.get(PAGE_NUMBER)[NUM_ZERO].toString()) : pageno;

        customWhooshModel.setDistinct(distinct);
        customWhooshModel.setRequiredColumns(requiredColumns);
        customWhooshModel.setSort(sort);
        customWhooshModel.setSortfields(sortfields);
        customWhooshModel.setSortorder(sortorder);
        customWhooshModel.setParams(params);
        customWhooshModel.setDistinctfield(distinctfield);
        customWhooshModel.setPageno(pageno);
        customWhooshModel.setCount(count);

        return customWhooshModel;
    }

    public static CustomWhooshModel generateWhooshModelWithLike(Map<String, String[]> params1, User user) {
        return generateWhooshModel(params1, Boolean.FALSE, null, Boolean.TRUE, user);
    }

    public static Map<String, String[]> generateWhooshParams(Map<String, String[]> params) {

        Map<String, String[]> whooshParams = new HashedMap();
        whooshParams = params;

        if (params.containsKey(Constants.SELECTEDFIELDS)) {
            String[] selectedFields = params.get(Constants.SELECTEDFIELDS);
            whooshParams.put(Constants.SELECTEDFIELDS, new String[]{selectedFields[NUM_ZERO]});
        }
        if (params.containsKey(SORTFIELD)) {
            String[] sortField = params.get(SORTFIELD);
            whooshParams.put(SORTFIELD, new String[]{sortField[NUM_ZERO]});
        }
        if (params.containsKey(DISTINCT)) {
            String[] distinct = params.get(DISTINCT);
            whooshParams.put(DISTINCT, new String[]{distinct[NUM_ZERO]});
        }

        return whooshParams;
    }

    public static UserAccountNGroup fetchUserAccountNGroupforProblemManager(String[] problemManager, User user) throws Exception {
        UserAccountNGroup userAccountAGroup = new UserAccountNGroup();
        List<Map<String, Object>> results = new ArrayList<>();

        try {
            String profilequery = Arrays.stream(problemManager)
                    .map(s -> USER_SK + COLON + ESCAPE_CHARACTER + s + ESCAPE_CHARACTER)
                    .collect(Collectors.joining(OR));
            results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, profilequery, null
                    , new String[]{USER_SK, MASTER_ACCOUNT, ACCOUNT}, ACCOUNT, ASC, TRUE, null, NUM_ZERO, Boolean.FALSE, user);

            if (!results.contains(ERROR) && !results.isEmpty()) {
                String user_sk = results.get(NUM_ZERO).get(USER_SK).toString();
                String Account = results.get(NUM_ZERO).get(ACCOUNT).toString();
                String MasterAccount = results.get(NUM_ZERO).get(MASTER_ACCOUNT).toString();
                userAccountAGroup.setPrimaryAccount(Account);
                results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS, profilequery, null, new String[]{ACCOUNT, MASTER_ACCOUNT, GROUP_NAME, FUNCTIONAL_TYPE}, GROUP_NAME, null
                        , TRUE, null, NUM_ZERO, Boolean.FALSE, user);

                results.stream().forEach(result -> {
                    if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(CLIENT)) {
                        userAccountAGroup.getUserAccounts().add(result);
                    } else if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(SUPPORT)
                            || result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(NOTIFICATION)) {
                        userAccountAGroup.getUserGroups().add(result);
                    } else if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(PERMISSION)) {
                        userAccountAGroup.getUserPermission().add(result);
                        if (result.get(GROUP_NAME).toString().equalsIgnoreCase(Constants.USER_Administrator_CODE))
                            userAccountAGroup.setAdministrator(Boolean.TRUE);
                        else if (result.get(GROUP_NAME).toString().equalsIgnoreCase(Constants.USER_CSS_CODE))
                            userAccountAGroup.setCSS(Boolean.TRUE);
                    }
                });

                if (userAccountAGroup.getAdministrator() || userAccountAGroup.getCSS()) {
                    userAccountAGroup.setUserAccounts(SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, STATUS + COLON + STATUS_VALUE_ACTIVE
                            , null, new String[]{MASTER_ACCOUNT, ACCOUNT, ACCOUNT_CODE_NAME, MASTER_ACCOUNT_CODE_NAME}, ACCOUNT, ASC, TRUE, null
                            , NUM_ZERO, Boolean.FALSE, user));
                } else {
                    String accountQuery = "";
                    if (!userAccountAGroup.getUserAccounts().isEmpty()) {
                        accountQuery = OPEN_BRACKET + userAccountAGroup.getUserAccounts()
                                .stream()
                                .map(stringObjectMap -> ACCOUNT + COLON + stringObjectMap.get(GROUP_NAME) +
                                        OR + MASTER_ACCOUNT + COLON + stringObjectMap.get(GROUP_NAME))
                                .collect(Collectors.joining(OR));
                        accountQuery += OR + ACCOUNT + COLON + Account + OR + MASTER_ACCOUNT + COLON + MasterAccount + CLOSE_BRACKET +
                                AND + STATUS + COLON + STATUS_VALUE_ACTIVE;

                    } else {
                        accountQuery = OPEN_BRACKET + ACCOUNT + COLON + Account + OR + MASTER_ACCOUNT + COLON + MasterAccount + CLOSE_BRACKET +
                                AND + STATUS + COLON + STATUS_VALUE_ACTIVE;
                    }

                    results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, accountQuery
                            , null, new String[]{MASTER_ACCOUNT, ACCOUNT, ACCOUNT_CODE_NAME, MASTER_ACCOUNT_CODE_NAME}, ACCOUNT, ASC, TRUE, null
                            , NUM_ZERO, Boolean.FALSE, user);
                    userAccountAGroup.getUserAccounts().addAll(results);
                }
            } else {
                userAccountAGroup.setUserAccounts(new ArrayList<>());
                throw new Exception(sfInterfaceMessages.get("INFO.MESSAGE.INVALIDUSER"));
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            throw new Exception(e.getLocalizedMessage());
        }

        return userAccountAGroup;
    }

    public static UserAccountNGroup fetchUserAccountNGroup(String loginID, String userSK, User user) throws Exception {

        UserAccountNGroup userAccountAGroup = new UserAccountNGroup();
        List<Map<String, Object>> results = new ArrayList<>();

        try {
            String profilequery = "";
            if (userSK != null) {
                profilequery = USER_SK + COLON + ESCAPE_CHARACTER + userSK + ESCAPE_CHARACTER;
            } else {
                profilequery = LOGINID_WITH_COLON + loginID + ESCAPE_CHARACTER;
            }
            results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, profilequery, null
                    , new String[]{USER_SK, MASTER_ACCOUNT, ACCOUNT, FULL_NAME}, ACCOUNT, ASC, TRUE, null, NUM_ZERO, Boolean.FALSE, user);

            if (!results.contains(ERROR) && !results.isEmpty()) {
                String user_sk = results.get(NUM_ZERO).get(USER_SK).toString();
                String Account = results.get(NUM_ZERO).get(ACCOUNT).toString();
                String MasterAccount = results.get(NUM_ZERO).get(MASTER_ACCOUNT).toString();
                userAccountAGroup.setUser_sk(user_sk);
                userAccountAGroup.setFull_name(results.get(NUM_ZERO).get(FULL_NAME).toString());
                userAccountAGroup.setPrimaryAccount(Account);
                userAccountAGroup.setPrimaryMasterAccount(MasterAccount);
                results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS, USER_SK + COLON
                                + user_sk, null, new String[]{ACCOUNT, MASTER_ACCOUNT, GROUP_NAME, FUNCTIONAL_TYPE, ACCOUNT_GROUP_SK}, GROUP_NAME, null
                        , TRUE, null, NUM_ZERO, Boolean.FALSE, user);

                results.stream().forEach(result -> {
                    if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(CLIENT)) {
                        userAccountAGroup.getUserAccounts().add(result);
                    } else if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(SUPPORT)
                            || result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(NOTIFICATION)) {
                        userAccountAGroup.getUserGroups().add(result);
                    } else if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(PERMISSION)) {
                        userAccountAGroup.getUserPermission().add(result);
                        if (result.get(GROUP_NAME).toString().equalsIgnoreCase(Constants.USER_Administrator_CODE))
                            userAccountAGroup.setAdministrator(Boolean.TRUE);
                        else if (result.get(GROUP_NAME).toString().equalsIgnoreCase(Constants.USER_CSS_CODE))
                            userAccountAGroup.setCSS(Boolean.TRUE);
                    }
                });

                userAccountAGroup.setAccountGroup_sk(results.parallelStream()
                        .map(stringObjectMap -> (String) stringObjectMap.get(ACCOUNT_GROUP_SK))
                        .collect(Collectors.toList()));

                if (userAccountAGroup.getAdministrator() || userAccountAGroup.getCSS()) {
                    userAccountAGroup.setUserAccounts(SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, STATUS + COLON + STATUS_VALUE_ACTIVE
                            , null, new String[]{MASTER_ACCOUNT, ACCOUNT, ACCOUNT_CODE_NAME, MASTER_ACCOUNT_CODE_NAME}, ACCOUNT, ASC, TRUE, null
                            , NUM_ZERO, Boolean.FALSE, user));
                } else {
                    String accountQuery = "";
                    if (!userAccountAGroup.getUserAccounts().isEmpty()) {
                        accountQuery = OPEN_BRACKET + userAccountAGroup.getUserAccounts()
                                .stream()
                                .map(stringObjectMap -> ACCOUNT + COLON + stringObjectMap.get(GROUP_NAME) +
                                        OR + MASTER_ACCOUNT + COLON + stringObjectMap.get(GROUP_NAME))
                                .collect(Collectors.joining(OR));
                        accountQuery += OR + ACCOUNT + COLON + Account + OR + MASTER_ACCOUNT + COLON + MasterAccount + CLOSE_BRACKET +
                                AND + STATUS + COLON + STATUS_VALUE_ACTIVE;

                    } else {
                        accountQuery = OPEN_BRACKET + ACCOUNT + COLON + Account + OR + MASTER_ACCOUNT + COLON + MasterAccount + CLOSE_BRACKET +
                                AND + STATUS + COLON + STATUS_VALUE_ACTIVE;
                    }

                    results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, accountQuery
                            , null, new String[]{MASTER_ACCOUNT, ACCOUNT, ACCOUNT_CODE_NAME, MASTER_ACCOUNT_CODE_NAME}, ACCOUNT, ASC, TRUE, null
                            , NUM_ZERO, Boolean.FALSE, user);
                    userAccountAGroup.getUserAccounts().addAll(results);
                }
            } else {
                userAccountAGroup.setUserAccounts(new ArrayList<>());
                throw new Exception(sfInterfaceMessages.get("INFO.MESSAGE.INVALIDUSER"));
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            throw new Exception(e.getLocalizedMessage());
        }

        return userAccountAGroup;
    }

    public static UserAccountNGroup fetchUserAccountNGroup1(String loginID, String userSK, User user) throws Exception {

        UserAccountNGroup userAccountAGroup = new UserAccountNGroup();
        List<Map<String, Object>> results = new ArrayList<>();

        try {
            String profilequery = "";
            if (userSK != null) {
                profilequery = USER_SK + COLON + ESCAPE_CHARACTER + userSK + ESCAPE_CHARACTER;
            } else {
                profilequery = LOGINID_WITH_COLON + loginID + ESCAPE_CHARACTER;
            }
            results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, profilequery, null
                    , new String[]{USER_SK, MASTER_ACCOUNT, ACCOUNT}, ACCOUNT, ASC, TRUE, null, NUM_ZERO, Boolean.FALSE, user);

            if (!results.contains(ERROR) && !results.isEmpty()) {
                String user_sk = results.get(NUM_ZERO).get(USER_SK).toString();
                String Account = results.get(NUM_ZERO).get(ACCOUNT).toString();
                String MasterAccount = results.get(NUM_ZERO).get(MASTER_ACCOUNT).toString();
                userAccountAGroup.setPrimaryAccount(Account);
                userAccountAGroup.setPrimaryMasterAccount(MasterAccount);
                results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS, USER_SK + COLON
                                + user_sk, null, new String[]{ACCOUNT, MASTER_ACCOUNT, GROUP_NAME, GROUP_CODE, FUNCTIONAL_TYPE}, GROUP_NAME, null
                        , TRUE, null, NUM_ZERO, Boolean.FALSE, user);

                results.stream().forEach(result -> {
                    if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(CLIENT)) {
                        userAccountAGroup.getUserAccounts().add(result);
                    } else if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(SUPPORT)
                            || result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(NOTIFICATION)) {
                        userAccountAGroup.getUserGroups().add(result);
                    } else if (result.get(FUNCTIONAL_TYPE).toString().equalsIgnoreCase(PERMISSION)) {
                        userAccountAGroup.getUserPermission().add(result);
                        if (result.get(GROUP_NAME).toString().equalsIgnoreCase(Constants.USER_Administrator_CODE))
                            userAccountAGroup.setAdministrator(Boolean.TRUE);
                        else if (result.get(GROUP_NAME).toString().equalsIgnoreCase(Constants.USER_CSS_CODE))
                            userAccountAGroup.setCSS(Boolean.TRUE);
                    }
                });

                if (userAccountAGroup.getAdministrator() || userAccountAGroup.getCSS()) {
                    userAccountAGroup.setUserAccounts(SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, STATUS + COLON + STATUS_VALUE_ACTIVE
                            , null, new String[]{MASTER_ACCOUNT, ACCOUNT, ACCOUNT_CODE_NAME, MASTER_ACCOUNT_CODE_NAME}, ACCOUNT, ASC, TRUE, null
                            , NUM_ZERO, Boolean.FALSE, user));
                } else {
                    String accountQuery = "";
                    if (!userAccountAGroup.getUserAccounts().isEmpty()) {
                        accountQuery = OPEN_BRACKET + userAccountAGroup.getUserAccounts()
                                .stream()
                                .map(stringObjectMap -> ACCOUNT + COLON + stringObjectMap.get(GROUP_NAME) +
                                        OR + MASTER_ACCOUNT + COLON + stringObjectMap.get(GROUP_NAME))
                                .collect(Collectors.joining(OR));
                        accountQuery += OR + ACCOUNT + COLON + Account + OR + MASTER_ACCOUNT + COLON + MasterAccount + CLOSE_BRACKET +
                                AND + STATUS + COLON + STATUS_VALUE_ACTIVE;

                    } else {
                        accountQuery = OPEN_BRACKET + ACCOUNT + COLON + Account + OR + MASTER_ACCOUNT + COLON + MasterAccount + CLOSE_BRACKET +
                                AND + STATUS + COLON + STATUS_VALUE_ACTIVE;
                    }

                    results = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, accountQuery
                            , null, new String[]{MASTER_ACCOUNT, ACCOUNT, ACCOUNT_CODE_NAME, MASTER_ACCOUNT_CODE_NAME}, ACCOUNT, ASC, TRUE, null
                            , NUM_ZERO, Boolean.FALSE, user);
                    userAccountAGroup.getUserAccounts().addAll(results);
                }
            } else {
                userAccountAGroup.setUserAccounts(new ArrayList<>());
                throw new Exception(sfInterfaceMessages.get("INFO.MESSAGE.INVALIDUSER"));
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            throw new Exception(e.getLocalizedMessage());
        }

        return userAccountAGroup;
    }

    public static UserAccountNGroup fetchUserAccountNGroup(String loginID, User user) throws Exception {
        return fetchUserAccountNGroup(loginID, loginID, user);
    }

    public static Map<String, Object> getResultFromDB(JdbcTemplate refTemplate, String dynamicQuery) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                String finalSqlQuery = dynamicQuery;
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(finalSqlQuery);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, null, e);
                queryObject.put(ERROR_MESSAGE, SFInterfaceServices.ISPExceptionHandler(e, null, null).get(ERROR));
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            queryObject.put(ERROR_MESSAGE, SFInterfaceServices.ISPExceptionHandler(e, null, null).get(ERROR));
        }

        return queryObject;
    }

    public static Map<String, Object> createIncidentTicket(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            //String procedureCall = "{call " + spName + " (?" + StringUtils.rightPad("", 118, ",?") + ")}";
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 214); // 108 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(3, params.containsKey(PARENT) ? getValue(params.get(PARENT)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(6, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(7, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(8, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(9, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(10, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(11, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(12, params.containsKey(CTI) ? getValue(params.get(CTI)) : null);
                        callableStatement.setString(13, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(14, params.containsKey(PROJECT) ? getValue(params.get(PROJECT)) : null);
                        callableStatement.setString(15, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(16, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(17, params.containsKey(RAISED_BY) ? getValue(params.get(RAISED_BY)) : null);
                        callableStatement.setString(18, params.containsKey(VENDOR) ? getValue(params.get(VENDOR)) : null);
                        callableStatement.setString(19, params.containsKey(IMPACT) ? getValue(params.get(IMPACT)) : null);
                        callableStatement.setString(20, params.containsKey(SEVERITY) ? getValue(params.get(SEVERITY)) : null);
                        callableStatement.setString(21, params.containsKey(CONTACT_TYPE_SK) ? getValue(params.get(CONTACT_TYPE_SK)) : null);
                        callableStatement.setString(22, params.containsKey(TRIAGE_GROUP) ? getValue(params.get(TRIAGE_GROUP)) : null);
                        callableStatement.setString(23, params.containsKey(BUS_ORG) ? getValue(params.get(BUS_ORG)) : null);
                        callableStatement.setString(24, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(25, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(26, params.containsKey(PROBLEM_MANAGER) ? getValue(params.get(PROBLEM_MANAGER)) : null);
                        callableStatement.setString(27, params.containsKey(CASE_TYPE) ? getValue(params.get(CASE_TYPE)) : null);
                        callableStatement.setString(28, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(29, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(30, params.containsKey(RESOLUTION) ? getValue(params.get(RESOLUTION)) : null);
                        callableStatement.setString(31, params.containsKey(BUSINESS_PHONE) ? getValue(params.get(BUSINESS_PHONE)) : null);
                        callableStatement.setString(32, params.containsKey(BUSINESS_PHONE_EXT) ? getValue(params.get(BUSINESS_PHONE_EXT)) : null);
                        callableStatement.setString(33, params.containsKey(MOBILE) ? getValue(params.get(MOBILE)) : null);
                        callableStatement.setString(34, params.containsKey(PAGER) ? getValue(params.get(PAGER)) : null);
                        callableStatement.setString(35, params.containsKey(PAGER_PIN) ? getValue(params.get(PAGER_PIN)) : null);
                        callableStatement.setString(36, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(37, params.containsKey(REASON) ? getValue(params.get(REASON)) : null);
                        callableStatement.setString(38, params.containsKey(ONSITE_CALL) ? getValue(params.get(ONSITE_CALL)) : null);
                        callableStatement.setString(39, params.containsKey(TIME_SPENT_IN_MINUTES) ? getValue(params.get(TIME_SPENT_IN_MINUTES)) : null);
                        callableStatement.setString(40, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(41, params.containsKey(FORM_BUILDER_ID) ? getValue(params.get(FORM_BUILDER_ID)) : null);
                        callableStatement.setString(42, params.containsKey(TOTAL_COST) ? getValue(params.get(TOTAL_COST)) : null);
                        callableStatement.setString(43, params.containsKey(COST_CENTER) ? getValue(params.get(COST_CENTER)) : null);
                        callableStatement.setString(44, params.containsKey(SD_PROVIDED_DETAILS) ? getValue(params.get(SD_PROVIDED_DETAILS)) : null);
                        callableStatement.setString(45, params.containsKey(BUS_EMAILID) ? getValue(params.get(BUS_EMAILID)) : null);
                        callableStatement.setString(46, params.containsKey(ASSET_TAG) ? getValue(params.get(ASSET_TAG)) : null);
                        callableStatement.setString(47, params.containsKey(COMPUTER_NAME) ? getValue(params.get(COMPUTER_NAME)) : null);
                        callableStatement.setString(48, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(49, params.containsKey(RDY_MAPPING) ? getValue(params.get(RDY_MAPPING)) : null);
                        callableStatement.setString(50, params.containsKey(BUS_HOURS_TO_RESOLVE) ? getValue(params.get(BUS_HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(51, params.containsKey(HOURS_TO_RESOLVE) ? getValue(params.get(HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(52, params.containsKey(CONVERTED_TO) ? getValue(params.get(CONVERTED_TO)) : null);
                        callableStatement.setString(53, params.containsKey(IS_AUTO_CLOSE) ? getValue(params.get(IS_AUTO_CLOSE)) : null);
                        callableStatement.setString(54, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);
                        callableStatement.setString(55, params.containsKey(NON_SLA_ISSUE_REASON) ? getValue(params.get(NON_SLA_ISSUE_REASON)) : null);
                        callableStatement.setString(56, params.containsKey(CONTACT_TYPE) ? getValue(params.get(CONTACT_TYPE)) : null);
                        callableStatement.setString(57, params.containsKey(IS_VERIFIED_INFO) ? getValue(params.get(IS_VERIFIED_INFO)) : null);
                        callableStatement.setString(58, params.containsKey(NO_ARTICLE_REASON) ? getValue(params.get(NO_ARTICLE_REASON)) : null);
                        callableStatement.setString(59, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(60, params.containsKey(ASSIGNED_ON) ? getValue(params.get(ASSIGNED_ON)) : null);
                        callableStatement.setString(61, params.containsKey(ACKNOWLEDGED_ON) ? getValue(params.get(ACKNOWLEDGED_ON)) : null);
                        callableStatement.setString(62, params.containsKey(PENDING_ON) ? getValue(params.get(PENDING_ON)) : null);
                        callableStatement.setString(63, params.containsKey(PENDING_OFF) ? getValue(params.get(PENDING_OFF)) : null);
                        callableStatement.setString(64, params.containsKey(REOPENED_ON) ? getValue(params.get(REOPENED_ON)) : null);
                        callableStatement.setString(65, params.containsKey(RESOLVED_BY) ? getValue(params.get(RESOLVED_BY)) : null);
                        callableStatement.setString(66, params.containsKey(RESOLVED_ON) ? getValue(params.get(RESOLVED_ON)) : null);
                        callableStatement.setString(67, params.containsKey(CLOSED_ON) ? getValue(params.get(CLOSED_ON)) : null);
                        callableStatement.setString(68, params.containsKey(FIRST_ACK_ON) ? getValue(params.get(FIRST_ACK_ON)) : null);
                        callableStatement.setString(69, params.containsKey(FIRST_ASSIGNED_ON) ? getValue(params.get(FIRST_ASSIGNED_ON)) : null);
                        callableStatement.setString(70, params.containsKey(CONVERTED_FROM) ? getValue(params.get(CONVERTED_FROM)) : null);
                        callableStatement.setString(71, params.containsKey(WORK_STARTED_ON) ? getValue(params.get(WORK_STARTED_ON)) : null);
                        callableStatement.setString(72, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(73, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(74, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(75, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(76, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(77, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(78, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(79, params.containsKey(ATTRIBUTE_8) ? getValue(params.get(ATTRIBUTE_8)) : null);
                        callableStatement.setString(80, params.containsKey(ATTRIBUTE_9) ? getValue(params.get(ATTRIBUTE_9)) : null);
                        callableStatement.setString(81, params.containsKey(ATTRIBUTE_10) ? getValue(params.get(ATTRIBUTE_10)) : null);
                        callableStatement.setString(82, params.containsKey(ATTRIBUTE_11) ? getValue(params.get(ATTRIBUTE_11)) : null);
                        callableStatement.setString(83, params.containsKey(ATTRIBUTE_12) ? getValue(params.get(ATTRIBUTE_12)) : null);
                        callableStatement.setString(84, params.containsKey(ATTRIBUTE_13) ? getValue(params.get(ATTRIBUTE_13)) : null);
                        callableStatement.setString(85, params.containsKey(ATTRIBUTE_14) ? getValue(params.get(ATTRIBUTE_14)) : null);
                        callableStatement.setString(86, params.containsKey(ATTRIBUTE_15) ? getValue(params.get(ATTRIBUTE_15)) : null);
                        callableStatement.setString(87, params.containsKey(ATTRIBUTE_16) ? getValue(params.get(ATTRIBUTE_16)) : null);
                        callableStatement.setString(88, params.containsKey(ATTRIBUTE_17) ? getValue(params.get(ATTRIBUTE_17)) : null);
                        callableStatement.setString(89, params.containsKey(ATTRIBUTE_18) ? getValue(params.get(ATTRIBUTE_18)) : null);
                        callableStatement.setString(90, params.containsKey(ATTRIBUTE_19) ? getValue(params.get(ATTRIBUTE_19)) : null);
                        callableStatement.setString(91, params.containsKey(ATTRIBUTE_20) ? getValue(params.get(ATTRIBUTE_20)) : null);
                        callableStatement.setString(92, params.containsKey(SF_PROCESS_ID) ? getValue(params.get(SF_PROCESS_ID)) : null);
                        callableStatement.setString(93, params.containsKey(SF_FORM_ID) ? getValue(params.get(SF_FORM_ID)) : null);
                        callableStatement.setString(94, params.containsKey(SF_SUBMISSION_ID) ? getValue(params.get(SF_SUBMISSION_ID)) : null);
                        callableStatement.setString(95, params.containsKey(AUX_CONTACT) ? getValue(params.get(AUX_CONTACT)) : null);
                        callableStatement.setString(96, params.containsKey(WRK_DESCRIPTION) ? getValue(params.get(WRK_DESCRIPTION)) : null);
                        callableStatement.setString(97, params.containsKey(NOTIFY_OWNER) ? getValue(params.get(NOTIFY_OWNER)) : null);
                        callableStatement.setString(98, params.containsKey(WORKNOTE_TYPE) ? getValue(params.get(WORKNOTE_TYPE)) : null);
                        callableStatement.setString(99, params.containsKey(WORKNOTES_UPDATE_TYPE) ? getValue(params.get(WORKNOTES_UPDATE_TYPE)) : null);
                        callableStatement.setString(100, params.containsKey(WORKNOTES_QUEUE) ? getValue(params.get(WORKNOTES_QUEUE)) : null);
                        callableStatement.setString(101, params.containsKey(FLR_ACHIEVED) ? getValue(params.get(FLR_ACHIEVED)) : null);
                        callableStatement.setString(102, params.containsKey(FLR_POSSIBLE) ? getValue(params.get(FLR_POSSIBLE)) : null);
                        callableStatement.setString(103, params.containsKey(IS_SD_PROVIDE_DETAILS) ? getValue(params.get(IS_SD_PROVIDE_DETAILS)) : null);
                        callableStatement.setString(104, params.containsKey(EXTERNALTICKETID) ? getValue(params.get(EXTERNALTICKETID)) : null);
                        callableStatement.setString(105, params.containsKey(CATEGORY_SK) ? getValue(params.get(CATEGORY_SK)) : null);
                        callableStatement.setString(106, params.containsKey(TYPE_SK) ? getValue(params.get(TYPE_SK)) : null);
                        callableStatement.setString(107, params.containsKey(ITEM_SK) ? getValue(params.get(ITEM_SK)) : null);
                        callableStatement.setString(108, params.containsKey(OFFLINE_UNIQUE_ID) ? getValue(params.get(OFFLINE_UNIQUE_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createSRTicket(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            //String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 120);
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 216);//108 Parameters


            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(3, params.containsKey(PARENT) ? getValue(params.get(PARENT)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(6, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(7, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(8, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(9, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(10, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(11, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(12, params.containsKey(CTI) ? getValue(params.get(CTI)) : null);
                        callableStatement.setString(13, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(14, params.containsKey(PROJECT) ? getValue(params.get(PROJECT)) : null);
                        callableStatement.setString(15, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(16, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(17, params.containsKey(RAISED_BY) ? getValue(params.get(RAISED_BY)) : null);
                        callableStatement.setString(18, params.containsKey(VENDOR) ? getValue(params.get(VENDOR)) : null);
                        callableStatement.setString(19, params.containsKey(IMPACT) ? getValue(params.get(IMPACT)) : null);
                        callableStatement.setString(20, params.containsKey(SEVERITY) ? getValue(params.get(SEVERITY)) : null);
                        callableStatement.setString(21, params.containsKey(CONTACT_TYPE_SK) ? getValue(params.get(CONTACT_TYPE_SK)) : null);
                        callableStatement.setString(22, params.containsKey(TRIAGE_GROUP) ? getValue(params.get(TRIAGE_GROUP)) : null);
                        callableStatement.setString(23, params.containsKey(BUS_ORG) ? getValue(params.get(BUS_ORG)) : null);
                        callableStatement.setString(24, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(25, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(26, params.containsKey(PROBLEM_MANAGER) ? getValue(params.get(PROBLEM_MANAGER)) : null);
                        callableStatement.setString(27, params.containsKey(CASE_TYPE) ? getValue(params.get(CASE_TYPE)) : null);
                        callableStatement.setString(28, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(29, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(30, params.containsKey(RESOLUTION) ? getValue(params.get(RESOLUTION)) : null);
                        callableStatement.setString(31, params.containsKey(BUSINESS_PHONE) ? getValue(params.get(BUSINESS_PHONE)) : null);
                        callableStatement.setString(32, params.containsKey(BUSINESS_PHONE_EXT) ? getValue(params.get(BUSINESS_PHONE_EXT)) : null);
                        callableStatement.setString(33, params.containsKey(MOBILE) ? getValue(params.get(MOBILE)) : null);
                        callableStatement.setString(34, params.containsKey(PAGER) ? getValue(params.get(PAGER)) : null);
                        callableStatement.setString(35, params.containsKey(PAGER_PIN) ? getValue(params.get(PAGER_PIN)) : null);
                        callableStatement.setString(36, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(37, params.containsKey(REASON) ? getValue(params.get(REASON)) : null);
                        callableStatement.setString(38, params.containsKey(ONSITE_CALL) ? getValue(params.get(ONSITE_CALL)) : null);
                        callableStatement.setString(39, params.containsKey(TIME_SPENT_IN_MINUTES) ? getValue(params.get(TIME_SPENT_IN_MINUTES)) : null);
                        callableStatement.setString(40, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(41, params.containsKey(FORM_BUILDER_ID) ? getValue(params.get(FORM_BUILDER_ID)) : null);
                        callableStatement.setString(42, params.containsKey(TOTAL_COST) ? getValue(params.get(TOTAL_COST)) : null);
                        callableStatement.setString(43, params.containsKey(COST_CENTER) ? getValue(params.get(COST_CENTER)) : null);
                        callableStatement.setString(44, params.containsKey(SD_PROVIDED_DETAILS) ? getValue(params.get(SD_PROVIDED_DETAILS)) : null);
                        callableStatement.setString(45, params.containsKey(BUS_EMAILID) ? getValue(params.get(BUS_EMAILID)) : null);
                        callableStatement.setString(46, params.containsKey(ASSET_TAG) ? getValue(params.get(ASSET_TAG)) : null);
                        callableStatement.setString(47, params.containsKey(COMPUTER_NAME) ? getValue(params.get(COMPUTER_NAME)) : null);
                        callableStatement.setString(48, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(49, params.containsKey(RDY_MAPPING) ? getValue(params.get(RDY_MAPPING)) : null);
                        callableStatement.setString(50, params.containsKey(BUS_HOURS_TO_RESOLVE) ? getValue(params.get(BUS_HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(51, params.containsKey(HOURS_TO_RESOLVE) ? getValue(params.get(HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(52, params.containsKey(CONVERTED_TO) ? getValue(params.get(CONVERTED_TO)) : null);
                        callableStatement.setString(53, params.containsKey(IS_AUTO_CLOSE) ? getValue(params.get(IS_AUTO_CLOSE)) : null);
                        callableStatement.setString(54, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);
                        callableStatement.setString(55, params.containsKey(NON_SLA_ISSUE_REASON) ? getValue(params.get(NON_SLA_ISSUE_REASON)) : null);
                        callableStatement.setString(56, params.containsKey(CONTACT_TYPE) ? getValue(params.get(CONTACT_TYPE)) : null);
                        callableStatement.setString(57, params.containsKey(IS_VERIFIED_INFO) ? getValue(params.get(IS_VERIFIED_INFO)) : null);
                        callableStatement.setString(58, params.containsKey(NO_ARTICLE_REASON) ? getValue(params.get(NO_ARTICLE_REASON)) : null);
                        callableStatement.setString(59, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(60, params.containsKey(ASSIGNED_ON) ? getValue(params.get(ASSIGNED_ON)) : null);
                        callableStatement.setString(61, params.containsKey(ACKNOWLEDGED_ON) ? getValue(params.get(ACKNOWLEDGED_ON)) : null);
                        callableStatement.setString(62, params.containsKey(PENDING_ON) ? getValue(params.get(PENDING_ON)) : null);
                        callableStatement.setString(63, params.containsKey(PENDING_OFF) ? getValue(params.get(PENDING_OFF)) : null);
                        callableStatement.setString(64, params.containsKey(REOPENED_ON) ? getValue(params.get(REOPENED_ON)) : null);
                        callableStatement.setString(65, params.containsKey(RESOLVED_BY) ? getValue(params.get(RESOLVED_BY)) : null);
                        callableStatement.setString(66, params.containsKey(RESOLVED_ON) ? getValue(params.get(RESOLVED_ON)) : null);
                        callableStatement.setString(67, params.containsKey(CLOSED_ON) ? getValue(params.get(CLOSED_ON)) : null);
                        callableStatement.setString(68, params.containsKey(FIRST_ACK_ON) ? getValue(params.get(FIRST_ACK_ON)) : null);
                        callableStatement.setString(69, params.containsKey(FIRST_ASSIGNED_ON) ? getValue(params.get(FIRST_ASSIGNED_ON)) : null);
                        callableStatement.setString(70, params.containsKey(CONVERTED_FROM) ? getValue(params.get(CONVERTED_FROM)) : null);
                        callableStatement.setString(71, params.containsKey(WORK_STARTED_ON) ? getValue(params.get(WORK_STARTED_ON)) : null);
                        callableStatement.setString(72, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(73, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(74, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(75, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(76, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(77, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(78, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(79, params.containsKey(ATTRIBUTE_8) ? getValue(params.get(ATTRIBUTE_8)) : null);
                        callableStatement.setString(80, params.containsKey(ATTRIBUTE_9) ? getValue(params.get(ATTRIBUTE_9)) : null);
                        callableStatement.setString(81, params.containsKey(ATTRIBUTE_10) ? getValue(params.get(ATTRIBUTE_10)) : null);
                        callableStatement.setString(82, params.containsKey(ATTRIBUTE_11) ? getValue(params.get(ATTRIBUTE_11)) : null);
                        callableStatement.setString(83, params.containsKey(ATTRIBUTE_12) ? getValue(params.get(ATTRIBUTE_12)) : null);
                        callableStatement.setString(84, params.containsKey(ATTRIBUTE_13) ? getValue(params.get(ATTRIBUTE_13)) : null);
                        callableStatement.setString(85, params.containsKey(ATTRIBUTE_14) ? getValue(params.get(ATTRIBUTE_14)) : null);
                        callableStatement.setString(86, params.containsKey(ATTRIBUTE_15) ? getValue(params.get(ATTRIBUTE_15)) : null);
                        callableStatement.setString(87, params.containsKey(ATTRIBUTE_16) ? getValue(params.get(ATTRIBUTE_16)) : null);
                        callableStatement.setString(88, params.containsKey(ATTRIBUTE_17) ? getValue(params.get(ATTRIBUTE_17)) : null);
                        callableStatement.setString(89, params.containsKey(ATTRIBUTE_18) ? getValue(params.get(ATTRIBUTE_18)) : null);
                        callableStatement.setString(90, params.containsKey(ATTRIBUTE_19) ? getValue(params.get(ATTRIBUTE_19)) : null);
                        callableStatement.setString(91, params.containsKey(ATTRIBUTE_20) ? getValue(params.get(ATTRIBUTE_20)) : null);
                        callableStatement.setString(92, params.containsKey(USERS) ? getValue(params.get(USERS)) : null);
                        callableStatement.setString(93, params.containsKey(SF_PROCESS_ID) ? getValue(params.get(SF_PROCESS_ID)) : null);
                        callableStatement.setString(94, params.containsKey(SF_FORM_ID) ? getValue(params.get(SF_FORM_ID)) : null);
                        callableStatement.setString(95, params.containsKey(SF_SUBMISSION_ID) ? getValue(params.get(SF_SUBMISSION_ID)) : null);
                        callableStatement.setString(96, params.containsKey(AUX_CONTACT) ? getValue(params.get(AUX_CONTACT)) : null);
                        callableStatement.setString(97, params.containsKey(WRK_DESCRIPTION) ? getValue(params.get(WRK_DESCRIPTION)) : null);
                        callableStatement.setString(98, params.containsKey(NOTIFY_OWNER) ? getValue(params.get(NOTIFY_OWNER)) : null);
                        callableStatement.setString(99, params.containsKey(WORKNOTE_TYPE) ? getValue(params.get(WORKNOTE_TYPE)) : null);
                        callableStatement.setString(100, params.containsKey(WORKNOTES_UPDATE_TYPE) ? getValue(params.get(WORKNOTES_UPDATE_TYPE)) : null);
                        callableStatement.setString(101, params.containsKey(WORKNOTES_QUEUE) ? getValue(params.get(WORKNOTES_QUEUE)) : null);
                        callableStatement.setString(102, params.containsKey(FLR_ACHIEVED) ? getValue(params.get(FLR_ACHIEVED)) : null);
                        callableStatement.setString(103, params.containsKey(FLR_POSSIBLE) ? getValue(params.get(FLR_POSSIBLE)) : null);
                        callableStatement.setString(104, params.containsKey(IS_SD_PROVIDE_DETAILS) ? getValue(params.get(IS_SD_PROVIDE_DETAILS)) : null);
                        callableStatement.setString(105, params.containsKey(EXTERNALTICKETID) ? getValue(params.get(EXTERNALTICKETID)) : null);
                        callableStatement.setString(106, params.containsKey(CATEGORY_SK) ? getValue(params.get(CATEGORY_SK)) : null);
                        callableStatement.setString(107, params.containsKey(TYPE_SK) ? getValue(params.get(TYPE_SK)) : null);
                        callableStatement.setString(108, params.containsKey(ITEM_SK) ? getValue(params.get(ITEM_SK)) : null);
                        callableStatement.setString(109, params.containsKey(OFFLINE_UNIQUE_ID) ? getValue(params.get(OFFLINE_UNIQUE_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject.put(ERROR_MESSAGE, SFInterfaceServices.ISPExceptionHandler(e, null, endpointName).get(ERROR));
        }

        return queryObject;
    }

    public static Map<String, Object> createSRTTicket(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 72); // 37 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(TASK_ID) ? getValue(params.get(TASK_ID)) : null);
                        callableStatement.setString(4, params.containsKey(SERVICEREQUEST_SK) ? getValue(params.get(SERVICEREQUEST_SK)) : null);
                        callableStatement.setString(5, params.containsKey(PARENT) ? getValue(params.get(PARENT)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(TASK_NAME) ? getValue(params.get(TASK_NAME)) : null);
                        callableStatement.setString(8, params.containsKey(TASK_DETAILS) ? getValue(params.get(TASK_DETAILS)) : null);
                        callableStatement.setString(9, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(10, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(11, params.containsKey(TASK_SEQUENCE) ? getValue(params.get(TASK_SEQUENCE)) : null);
                        callableStatement.setString(12, params.containsKey(FORM_BUILDER_ID) ? getValue(params.get(FORM_BUILDER_ID)) : null);
                        callableStatement.setString(13, params.containsKey(CLONED_SK) ? getValue(params.get(CLONED_SK)) : null);
                        callableStatement.setString(14, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(15, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);
                        callableStatement.setString(16, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(17, params.containsKey(ASSIGNED_ON) ? getValue(params.get(ASSIGNED_ON)) : null);
                        callableStatement.setString(18, params.containsKey(COMPLELTED_ON) ? getValue(params.get(COMPLELTED_ON)) : null);
                        callableStatement.setString(19, params.containsKey(IS_AUTO_CLOSE) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(20, params.containsKey(GRP_CHG_COUNT) ? getValue(params.get(GRP_CHG_COUNT)) : null);
                        callableStatement.setString(21, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(22, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(23, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(24, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(25, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(26, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(27, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(28, params.containsKey(ATTRIBUTE_8) ? getValue(params.get(ATTRIBUTE_8)) : null);
                        callableStatement.setString(29, params.containsKey(ATTRIBUTE_9) ? getValue(params.get(ATTRIBUTE_9)) : null);
                        callableStatement.setString(30, params.containsKey(ATTRIBUTE_10) ? getValue(params.get(ATTRIBUTE_10)) : null);
                        callableStatement.setString(31, params.containsKey(SF_PROCESS_ID) ? getValue(params.get(SF_PROCESS_ID)) : null);
                        callableStatement.setString(32, params.containsKey(SF_FORM_ID) ? getValue(params.get(SF_FORM_ID)) : null);
                        callableStatement.setString(33, params.containsKey(SF_SUBMISSION_ID) ? getValue(params.get(SF_SUBMISSION_ID)) : null);
                        callableStatement.setString(34, params.containsKey(IAM_ACTION) ? getValue(params.get(IAM_ACTION)) : null);
                        callableStatement.setString(35, params.containsKey(WRK_DESCRIPTION) ? getValue(params.get(WRK_DESCRIPTION)) : null);
                        callableStatement.setString(36, params.containsKey(NOTIFY_OWNER) ? getValue(params.get(NOTIFY_OWNER)) : null);
                        callableStatement.setString(37, params.containsKey(WORKNOTE_TYPE) ? getValue(params.get(WORKNOTE_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateIncidentTicket(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            //String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 174);
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 238); //119 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();

            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, getValue(params.get(TICKETSK)));
                        callableStatement.setString(3, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(PARENT) ? getDBValidatedValue(params.get(PARENT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(6, params.containsKey(ASSIGNED_INDIVIDUAL) ? getDBValidatedValue(params.get(ASSIGNED_INDIVIDUAL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(ASSIGNED_GROUP) ? getDBValidatedValue(params.get(ASSIGNED_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(BUILDING) ? getDBValidatedValue(params.get(BUILDING), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(DEPARTMENT) ? getDBValidatedValue(params.get(DEPARTMENT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(FLOOR) ? getDBValidatedValue(params.get(FLOOR), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(SUITE) ? getDBValidatedValue(params.get(SUITE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(13, params.containsKey(CTI) ? getDBValidatedValue(params.get(CTI), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(PRIORITY) ? getDBValidatedValue(params.get(PRIORITY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(PROJECT) ? getDBValidatedValue(params.get(PROJECT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(17, params.containsKey(ALERT_STATUS) ? getDBValidatedValue(params.get(ALERT_STATUS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(18, params.containsKey(RAISED_BY) ? getValue(params.get(RAISED_BY)) : null);
                        callableStatement.setString(19, params.containsKey(VENDOR) ? getDBValidatedValue(params.get(VENDOR), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(IMPACT) ? getDBValidatedValue(params.get(IMPACT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(21, params.containsKey(SEVERITY) ? getDBValidatedValue(params.get(SEVERITY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(22, params.containsKey(CONTACT_TYPE_SK) ? getDBValidatedValue(params.get(CONTACT_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(23, params.containsKey(BUS_ORG) ? getDBValidatedValue(params.get(BUS_ORG), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(QUEUE) ? getDBValidatedValue(params.get(QUEUE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(25, params.containsKey(PENDING_REASON) ? getDBValidatedValue(params.get(PENDING_REASON), DATATYPE_INTEGER) : null);
                        callableStatement.setString(26, params.containsKey(PROBLEM_MANAGER) ? getDBValidatedValue(params.get(PROBLEM_MANAGER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(27, params.containsKey(CASE_TYPE) ? getDBValidatedValue(params.get(CASE_TYPE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(28, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(29, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(30, params.containsKey(RESOLUTION) ? getDBValidatedValue(params.get(RESOLUTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(31, params.containsKey(BUSINESS_PHONE) ? getDBValidatedValue(params.get(BUSINESS_PHONE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(32, params.containsKey(BUSINESS_PHONE_EXT) ? getDBValidatedValue(params.get(BUSINESS_PHONE_EXT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(33, params.containsKey(MOBILE) ? getDBValidatedValue(params.get(MOBILE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(34, params.containsKey(PAGER) ? getDBValidatedValue(params.get(PAGER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(35, params.containsKey(PAGER_PIN) ? getDBValidatedValue(params.get(PAGER_PIN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(36, params.containsKey(OFFICE) ? getDBValidatedValue(params.get(OFFICE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(37, params.containsKey(PENDING_TIME) ? getDBValidatedValue(params.get(PENDING_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(38, params.containsKey(REASON) ? getDBValidatedValue(params.get(REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(39, params.containsKey(ONSITE_CALL) ? getDBValidatedValue(params.get(ONSITE_CALL), DATATYPE_BIT) : null);
                        callableStatement.setString(40, params.containsKey(TIME_SPENT_IN_MINUTES) ? getDBValidatedValue(params.get(TIME_SPENT_IN_MINUTES), DATATYPE_INTEGER) : null);
                        callableStatement.setString(41, params.containsKey(ASSIGNED_ON) ? getDBValidatedValue(params.get(ASSIGNED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(42, params.containsKey(ACKNOWLEDGED_ON) ? getDBValidatedValue(params.get(ACKNOWLEDGED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(43, params.containsKey(PENDING_ON) ? getDBValidatedValue(params.get(PENDING_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(44, params.containsKey(PENDING_OFF) ? getDBValidatedValue(params.get(PENDING_OFF), DATATYPE_DATETIME) : null);
                        callableStatement.setString(45, params.containsKey(REOPENED_ON) ? getDBValidatedValue(params.get(REOPENED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(46, params.containsKey(FLR_ACHIEVED) ? getDBValidatedValue(params.get(FLR_ACHIEVED), DATATYPE_BIT) : null);
                        callableStatement.setString(47, params.containsKey(FLR_POSSIBLE) ? getDBValidatedValue(params.get(FLR_POSSIBLE), DATATYPE_BIT) : null);
                        callableStatement.setString(48, params.containsKey(RESOLVED_BY) ? getDBValidatedValue(params.get(RESOLVED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(49, params.containsKey(RESOLVED_ON) ? getDBValidatedValue(params.get(RESOLVED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(50, params.containsKey(CLOSED_ON) ? getDBValidatedValue(params.get(CLOSED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(51, params.containsKey(IS_REOPENED) ? getDBValidatedValue(params.get(IS_REOPENED), DATATYPE_BIT) : null);
                        callableStatement.setString(52, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(53, params.containsKey(FORM_BUILDER_ID) ? getDBValidatedValue(params.get(FORM_BUILDER_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(54, params.containsKey(TOTAL_COST) ? getDBValidatedValue(params.get(TOTAL_COST), DATATYPE_FLOAT) : null);
                        callableStatement.setString(55, params.containsKey(COST_CENTER) ? getDBValidatedValue(params.get(COST_CENTER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(56, params.containsKey(IS_SD_CAN_RESOLVE) ? getDBValidatedValue(params.get(IS_SD_CAN_RESOLVE), DATATYPE_BIT) : null);
                        callableStatement.setString(57, params.containsKey(SD_RESOLVED_COMMENTS) ? getDBValidatedValue(params.get(SD_RESOLVED_COMMENTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(58, params.containsKey(IS_SD_ASSIGNED_WRONG_GROUP) ? getDBValidatedValue(params.get(IS_SD_ASSIGNED_WRONG_GROUP), DATATYPE_BIT) : null);
                        callableStatement.setString(59, params.containsKey(SD_ASSIGNED_WRONG_GROUP_COMMENTS) ? getDBValidatedValue(params.get(SD_ASSIGNED_WRONG_GROUP_COMMENTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(60, params.containsKey(IS_SD_PROVIDE_DETAILS) ? getDBValidatedValue(params.get(IS_SD_PROVIDE_DETAILS), DATATYPE_BIT) : null);
                        callableStatement.setString(61, params.containsKey(SD_PROVIDED_DETAILS) ? getDBValidatedValue(params.get(SD_PROVIDED_DETAILS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(62, params.containsKey(BUS_EMAILID) ? getDBValidatedValue(params.get(BUS_EMAILID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(63, params.containsKey(ASSET_TAG) ? getDBValidatedValue(params.get(ASSET_TAG), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(64, params.containsKey(COMPUTER_NAME) ? getDBValidatedValue(params.get(COMPUTER_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(65, params.containsKey(TITLE) ? getDBValidatedValue(params.get(TITLE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(66, params.containsKey(RDY_MAPPING) ? getDBValidatedValue(params.get(RDY_MAPPING), DATATYPE_INTEGER) : null);
                        callableStatement.setString(67, params.containsKey(PREV_ASSIGNED_INDIVIDUAL) ? getDBValidatedValue(params.get(PREV_ASSIGNED_INDIVIDUAL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(68, params.containsKey(PREV_ASSIGNED_GROUP) ? getDBValidatedValue(params.get(PREV_ASSIGNED_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(69, params.containsKey(FIRST_ACK_ON) ? getDBValidatedValue(params.get(FIRST_ACK_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(70, params.containsKey(FIRST_ASSIGNED_ON) ? getDBValidatedValue(params.get(FIRST_ASSIGNED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(71, params.containsKey(VOID_BY) ? getDBValidatedValue(params.get(VOID_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(72, params.containsKey(VOID_ON) ? getDBValidatedValue(params.get(VOID_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(73, params.containsKey(BUS_HOURS_TO_RESOLVE) ? getDBValidatedValue(params.get(BUS_HOURS_TO_RESOLVE), DATATYPE_DECIMAL) : null);
                        callableStatement.setString(74, params.containsKey(HOURS_TO_RESOLVE) ? getDBValidatedValue(params.get(HOURS_TO_RESOLVE), DATATYPE_DECIMAL) : null);
                        callableStatement.setString(75, params.containsKey(CONVERTED_TO) ? getDBValidatedValue(params.get(CONVERTED_TO), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(76, params.containsKey(IS_AUTO_CLOSE) ? getDBValidatedValue(params.get(IS_AUTO_CLOSE), DATATYPE_BIT) : null);
                        callableStatement.setString(77, params.containsKey(TICKET_TYPE) ? getDBValidatedValue(params.get(TICKET_TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(78, params.containsKey(CONVERTED_FROM) ? getDBValidatedValue(params.get(CONVERTED_FROM), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(79, params.containsKey(GRP_CHG_COUNT) ? getDBValidatedValue(params.get(GRP_CHG_COUNT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(80, params.containsKey(PAUSE_SLA) ? getDBValidatedValue(params.get(PAUSE_SLA), DATATYPE_BIT) : null);
                        callableStatement.setString(81, params.containsKey(NON_SLA_ISSUE_REASON) ? getDBValidatedValue(params.get(NON_SLA_ISSUE_REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(82, params.containsKey(WORK_STARTED_ON) ? getDBValidatedValue(params.get(WORK_STARTED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(83, params.containsKey(CONTACT_TYPE) ? getDBValidatedValue(params.get(CONTACT_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(84, params.containsKey(IS_VERIFIED_INFO) ? getDBValidatedValue(params.get(IS_VERIFIED_INFO), DATATYPE_BIT) : null);
                        callableStatement.setString(85, params.containsKey(NO_ARTICLE_REASON) ? getDBValidatedValue(params.get(NO_ARTICLE_REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(86, params.containsKey(TRIAGE_GROUP) ? getDBValidatedValue(params.get(TRIAGE_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(87, params.containsKey(ATTRIBUTE_1) ? getDBValidatedValue(params.get(ATTRIBUTE_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(88, params.containsKey(ATTRIBUTE_2) ? getDBValidatedValue(params.get(ATTRIBUTE_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(89, params.containsKey(ATTRIBUTE_3) ? getDBValidatedValue(params.get(ATTRIBUTE_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(90, params.containsKey(ATTRIBUTE_4) ? getDBValidatedValue(params.get(ATTRIBUTE_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(91, params.containsKey(ATTRIBUTE_5) ? getDBValidatedValue(params.get(ATTRIBUTE_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(92, params.containsKey(ATTRIBUTE_6) ? getDBValidatedValue(params.get(ATTRIBUTE_6), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(93, params.containsKey(ATTRIBUTE_7) ? getDBValidatedValue(params.get(ATTRIBUTE_7), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(94, params.containsKey(ATTRIBUTE_8) ? getDBValidatedValue(params.get(ATTRIBUTE_8), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(95, params.containsKey(ATTRIBUTE_9) ? getDBValidatedValue(params.get(ATTRIBUTE_9), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(96, params.containsKey(ATTRIBUTE_10) ? getDBValidatedValue(params.get(ATTRIBUTE_10), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(97, params.containsKey(ATTRIBUTE_11) ? getDBValidatedValue(params.get(ATTRIBUTE_11), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(98, params.containsKey(ATTRIBUTE_12) ? getDBValidatedValue(params.get(ATTRIBUTE_12), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(99, params.containsKey(ATTRIBUTE_13) ? getDBValidatedValue(params.get(ATTRIBUTE_13), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(100, params.containsKey(ATTRIBUTE_14) ? getDBValidatedValue(params.get(ATTRIBUTE_14), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(101, params.containsKey(ATTRIBUTE_15) ? getDBValidatedValue(params.get(ATTRIBUTE_15), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(102, params.containsKey(ATTRIBUTE_16) ? getDBValidatedValue(params.get(ATTRIBUTE_16), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(103, params.containsKey(ATTRIBUTE_17) ? getDBValidatedValue(params.get(ATTRIBUTE_17), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(104, params.containsKey(ATTRIBUTE_18) ? getDBValidatedValue(params.get(ATTRIBUTE_18), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(105, params.containsKey(ATTRIBUTE_19) ? getDBValidatedValue(params.get(ATTRIBUTE_19), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(106, params.containsKey(ATTRIBUTE_20) ? getDBValidatedValue(params.get(ATTRIBUTE_20), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(107, params.containsKey(SF_PROCESS_ID) ? getDBValidatedValue(params.get(SF_PROCESS_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(108, params.containsKey(SF_FORM_ID) ? getDBValidatedValue(params.get(SF_FORM_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(109, params.containsKey(SF_SUBMISSION_ID) ? getDBValidatedValue(params.get(SF_SUBMISSION_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(110, params.containsKey(AUX_CONTACT) ? getDBValidatedValue(params.get(AUX_CONTACT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(111, params.containsKey(WRK_DESCRIPTION) ? getValue(params.get(WRK_DESCRIPTION)) : null);
                        callableStatement.setString(112, params.containsKey(NOTIFY_OWNER) ? getValue(params.get(NOTIFY_OWNER)) : null);
                        callableStatement.setString(113, params.containsKey(WORKNOTES_UPDATE_TYPE) ? getValue(params.get(WORKNOTES_UPDATE_TYPE)) : null);
                        callableStatement.setString(114, params.containsKey(WORKNOTE_TYPE) ? getValue(params.get(WORKNOTE_TYPE)) : null);
                        callableStatement.setString(115, params.containsKey(WORKNOTES_QUEUE) ? getValue(params.get(WORKNOTES_QUEUE)) : null);
                        callableStatement.setString(116, params.containsKey(EXTERNALTICKETID) ? getDBValidatedValue(params.get(EXTERNALTICKETID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(117, params.containsKey(CATEGORY_SK) ? getDBValidatedValue(params.get(CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(118, params.containsKey(TYPE_SK) ? getDBValidatedValue(params.get(TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(119, params.containsKey(ITEM_SK) ? getDBValidatedValue(params.get(ITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(120, params.containsKey(OFFLINE_UNIQUE_ID) ? getDBValidatedValue(params.get(OFFLINE_UNIQUE_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSRTicket(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        Map<String, Object> attach = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 240);//120 Parameters


            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();

            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, getValue(params.get(TICKETSK)));
                        callableStatement.setString(3, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(PARENT) ? getDBValidatedValue(params.get(PARENT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(6, params.containsKey(ASSIGNED_INDIVIDUAL) ? getDBValidatedValue(params.get(ASSIGNED_INDIVIDUAL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(ASSIGNED_GROUP) ? getDBValidatedValue(params.get(ASSIGNED_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(BUILDING) ? getDBValidatedValue(params.get(BUILDING), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(DEPARTMENT) ? getDBValidatedValue(params.get(DEPARTMENT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(FLOOR) ? getDBValidatedValue(params.get(FLOOR), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(SUITE) ? getDBValidatedValue(params.get(SUITE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(13, params.containsKey(CTI) ? getDBValidatedValue(params.get(CTI), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(PRIORITY) ? getDBValidatedValue(params.get(PRIORITY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(PROJECT) ? getDBValidatedValue(params.get(PROJECT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(17, params.containsKey(ALERT_STATUS) ? getDBValidatedValue(params.get(ALERT_STATUS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(18, params.containsKey(RAISED_BY) ? getValue(params.get(RAISED_BY)) : null);
                        callableStatement.setString(19, params.containsKey(VENDOR) ? getDBValidatedValue(params.get(VENDOR), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(IMPACT) ? getDBValidatedValue(params.get(IMPACT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(21, params.containsKey(SEVERITY) ? getDBValidatedValue(params.get(SEVERITY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(22, params.containsKey(CONTACT_TYPE_SK) ? getDBValidatedValue(params.get(CONTACT_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(23, params.containsKey(BUS_ORG) ? getDBValidatedValue(params.get(BUS_ORG), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(QUEUE) ? getDBValidatedValue(params.get(QUEUE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(25, params.containsKey(PENDING_REASON) ? getDBValidatedValue(params.get(PENDING_REASON), DATATYPE_INTEGER) : null);
                        callableStatement.setString(26, params.containsKey(PROBLEM_MANAGER) ? getDBValidatedValue(params.get(PROBLEM_MANAGER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(27, params.containsKey(CASE_TYPE) ? getDBValidatedValue(params.get(CASE_TYPE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(28, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(29, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(30, params.containsKey(RESOLUTION) ? getDBValidatedValue(params.get(RESOLUTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(31, params.containsKey(BUSINESS_PHONE) ? getDBValidatedValue(params.get(BUSINESS_PHONE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(32, params.containsKey(BUSINESS_PHONE_EXT) ? getDBValidatedValue(params.get(BUSINESS_PHONE_EXT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(33, params.containsKey(MOBILE) ? getDBValidatedValue(params.get(MOBILE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(34, params.containsKey(PAGER) ? getDBValidatedValue(params.get(PAGER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(35, params.containsKey(PAGER_PIN) ? getDBValidatedValue(params.get(PAGER_PIN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(36, params.containsKey(OFFICE) ? getDBValidatedValue(params.get(OFFICE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(37, params.containsKey(PENDING_TIME) ? getDBValidatedValue(params.get(PENDING_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(38, params.containsKey(REASON) ? getDBValidatedValue(params.get(REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(39, params.containsKey(ONSITE_CALL) ? getDBValidatedValue(params.get(ONSITE_CALL), DATATYPE_BIT) : null);
                        callableStatement.setString(40, params.containsKey(TIME_SPENT_IN_MINUTES) ? getDBValidatedValue(params.get(TIME_SPENT_IN_MINUTES), DATATYPE_INTEGER) : null);
                        callableStatement.setString(41, params.containsKey(ASSIGNED_ON) ? getDBValidatedValue(params.get(ASSIGNED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(42, params.containsKey(ACKNOWLEDGED_ON) ? getDBValidatedValue(params.get(ACKNOWLEDGED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(43, params.containsKey(PENDING_ON) ? getDBValidatedValue(params.get(PENDING_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(44, params.containsKey(PENDING_OFF) ? getDBValidatedValue(params.get(PENDING_OFF), DATATYPE_DATETIME) : null);
                        callableStatement.setString(45, params.containsKey(REOPENED_ON) ? getDBValidatedValue(params.get(REOPENED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(46, params.containsKey(FLR_ACHIEVED) ? getDBValidatedValue(params.get(FLR_ACHIEVED), DATATYPE_BIT) : null);
                        callableStatement.setString(47, params.containsKey(FLR_POSSIBLE) ? getDBValidatedValue(params.get(FLR_POSSIBLE), DATATYPE_BIT) : null);
                        callableStatement.setString(48, params.containsKey(RESOLVED_BY) ? getDBValidatedValue(params.get(RESOLVED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(49, params.containsKey(RESOLVED_ON) ? getDBValidatedValue(params.get(RESOLVED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(50, params.containsKey(CLOSED_ON) ? getDBValidatedValue(params.get(CLOSED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(51, params.containsKey(IS_REOPENED) ? getDBValidatedValue(params.get(IS_REOPENED), DATATYPE_BIT) : null);
                        callableStatement.setString(52, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(53, params.containsKey(FORM_BUILDER_ID) ? getDBValidatedValue(params.get(FORM_BUILDER_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(54, params.containsKey(TOTAL_COST) ? getDBValidatedValue(params.get(TOTAL_COST), DATATYPE_FLOAT) : null);
                        callableStatement.setString(55, params.containsKey(COST_CENTER) ? getDBValidatedValue(params.get(COST_CENTER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(56, params.containsKey(IS_SD_CAN_RESOLVE) ? getDBValidatedValue(params.get(IS_SD_CAN_RESOLVE), DATATYPE_BIT) : null);
                        callableStatement.setString(57, params.containsKey(SD_RESOLVED_COMMENTS) ? getDBValidatedValue(params.get(SD_RESOLVED_COMMENTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(58, params.containsKey(IS_SD_ASSIGNED_WRONG_GROUP) ? getDBValidatedValue(params.get(IS_SD_ASSIGNED_WRONG_GROUP), DATATYPE_BIT) : null);
                        callableStatement.setString(59, params.containsKey(SD_ASSIGNED_WRONG_GROUP_COMMENTS) ? getDBValidatedValue(params.get(SD_ASSIGNED_WRONG_GROUP_COMMENTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(60, params.containsKey(IS_SD_PROVIDE_DETAILS) ? getDBValidatedValue(params.get(IS_SD_PROVIDE_DETAILS), DATATYPE_BIT) : null);
                        callableStatement.setString(61, params.containsKey(SD_PROVIDED_DETAILS) ? getDBValidatedValue(params.get(SD_PROVIDED_DETAILS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(62, params.containsKey(BUS_EMAILID) ? getDBValidatedValue(params.get(BUS_EMAILID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(63, params.containsKey(ASSET_TAG) ? getDBValidatedValue(params.get(ASSET_TAG), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(64, params.containsKey(COMPUTER_NAME) ? getDBValidatedValue(params.get(COMPUTER_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(65, params.containsKey(TITLE) ? getDBValidatedValue(params.get(TITLE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(66, params.containsKey(RDY_MAPPING) ? getDBValidatedValue(params.get(RDY_MAPPING), DATATYPE_INTEGER) : null);
                        callableStatement.setString(67, params.containsKey(PREV_ASSIGNED_INDIVIDUAL) ? getDBValidatedValue(params.get(PREV_ASSIGNED_INDIVIDUAL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(68, params.containsKey(PREV_ASSIGNED_GROUP) ? getDBValidatedValue(params.get(PREV_ASSIGNED_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(69, params.containsKey(FIRST_ACK_ON) ? getDBValidatedValue(params.get(FIRST_ACK_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(70, params.containsKey(FIRST_ASSIGNED_ON) ? getDBValidatedValue(params.get(FIRST_ASSIGNED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(71, params.containsKey(VOID_BY) ? getDBValidatedValue(params.get(VOID_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(72, params.containsKey(VOID_ON) ? getDBValidatedValue(params.get(VOID_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(73, params.containsKey(BUS_HOURS_TO_RESOLVE) ? getDBValidatedValue(params.get(BUS_HOURS_TO_RESOLVE), DATATYPE_DECIMAL) : null);
                        callableStatement.setString(74, params.containsKey(HOURS_TO_RESOLVE) ? getDBValidatedValue(params.get(HOURS_TO_RESOLVE), DATATYPE_DECIMAL) : null);
                        callableStatement.setString(75, params.containsKey(USERS) ? getDBValidatedValue(params.get(USERS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(76, params.containsKey(CONVERTED_TO) ? getDBValidatedValue(params.get(CONVERTED_TO), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(77, params.containsKey(IS_AUTO_CLOSE) ? getDBValidatedValue(params.get(IS_AUTO_CLOSE), DATATYPE_BIT) : null);
                        callableStatement.setString(78, params.containsKey(TICKET_TYPE) ? getDBValidatedValue(params.get(TICKET_TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(79, params.containsKey(CONVERTED_FROM) ? getDBValidatedValue(params.get(CONVERTED_FROM), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(80, params.containsKey(GRP_CHG_COUNT) ? getDBValidatedValue(params.get(GRP_CHG_COUNT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(81, params.containsKey(PAUSE_SLA) ? getDBValidatedValue(params.get(PAUSE_SLA), DATATYPE_BIT) : null);
                        callableStatement.setString(82, params.containsKey(NON_SLA_ISSUE_REASON) ? getDBValidatedValue(params.get(NON_SLA_ISSUE_REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(83, params.containsKey(WORK_STARTED_ON) ? getDBValidatedValue(params.get(WORK_STARTED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(84, params.containsKey(CONTACT_TYPE) ? getDBValidatedValue(params.get(CONTACT_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(85, params.containsKey(IS_VERIFIED_INFO) ? getDBValidatedValue(params.get(IS_VERIFIED_INFO), DATATYPE_BIT) : null);
                        callableStatement.setString(86, params.containsKey(NO_ARTICLE_REASON) ? getDBValidatedValue(params.get(NO_ARTICLE_REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(87, params.containsKey(TRIAGE_GROUP) ? getDBValidatedValue(params.get(TRIAGE_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(88, params.containsKey(ATTRIBUTE_1) ? getDBValidatedValue(params.get(ATTRIBUTE_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(89, params.containsKey(ATTRIBUTE_2) ? getDBValidatedValue(params.get(ATTRIBUTE_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(90, params.containsKey(ATTRIBUTE_3) ? getDBValidatedValue(params.get(ATTRIBUTE_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(91, params.containsKey(ATTRIBUTE_4) ? getDBValidatedValue(params.get(ATTRIBUTE_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(92, params.containsKey(ATTRIBUTE_5) ? getDBValidatedValue(params.get(ATTRIBUTE_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(93, params.containsKey(ATTRIBUTE_6) ? getDBValidatedValue(params.get(ATTRIBUTE_6), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(94, params.containsKey(ATTRIBUTE_7) ? getDBValidatedValue(params.get(ATTRIBUTE_7), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(95, params.containsKey(ATTRIBUTE_8) ? getDBValidatedValue(params.get(ATTRIBUTE_8), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(96, params.containsKey(ATTRIBUTE_9) ? getDBValidatedValue(params.get(ATTRIBUTE_9), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(97, params.containsKey(ATTRIBUTE_10) ? getDBValidatedValue(params.get(ATTRIBUTE_10), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(98, params.containsKey(ATTRIBUTE_11) ? getDBValidatedValue(params.get(ATTRIBUTE_11), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(99, params.containsKey(ATTRIBUTE_12) ? getDBValidatedValue(params.get(ATTRIBUTE_12), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(100, params.containsKey(ATTRIBUTE_13) ? getDBValidatedValue(params.get(ATTRIBUTE_13), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(101, params.containsKey(ATTRIBUTE_14) ? getDBValidatedValue(params.get(ATTRIBUTE_14), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(102, params.containsKey(ATTRIBUTE_15) ? getDBValidatedValue(params.get(ATTRIBUTE_15), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(103, params.containsKey(ATTRIBUTE_16) ? getDBValidatedValue(params.get(ATTRIBUTE_16), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(104, params.containsKey(ATTRIBUTE_17) ? getDBValidatedValue(params.get(ATTRIBUTE_17), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(105, params.containsKey(ATTRIBUTE_18) ? getDBValidatedValue(params.get(ATTRIBUTE_18), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(106, params.containsKey(ATTRIBUTE_19) ? getDBValidatedValue(params.get(ATTRIBUTE_19), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(107, params.containsKey(ATTRIBUTE_20) ? getDBValidatedValue(params.get(ATTRIBUTE_20), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(108, params.containsKey(SF_PROCESS_ID) ? getDBValidatedValue(params.get(SF_PROCESS_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(109, params.containsKey(SF_FORM_ID) ? getDBValidatedValue(params.get(SF_FORM_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(110, params.containsKey(SF_SUBMISSION_ID) ? getDBValidatedValue(params.get(SF_SUBMISSION_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(111, params.containsKey(AUX_CONTACT) ? getDBValidatedValue(params.get(AUX_CONTACT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(112, params.containsKey(WRK_DESCRIPTION) ? getValue(params.get(WRK_DESCRIPTION)) : null);
                        callableStatement.setString(113, params.containsKey(NOTIFY_OWNER) ? getValue(params.get(NOTIFY_OWNER)) : null);
                        callableStatement.setString(114, params.containsKey(WORKNOTES_UPDATE_TYPE) ? getValue(params.get(WORKNOTES_UPDATE_TYPE)) : null);
                        callableStatement.setString(115, params.containsKey(WORKNOTE_TYPE) ? getValue(params.get(WORKNOTE_TYPE)) : null);
                        callableStatement.setString(116, params.containsKey(WORKNOTES_QUEUE) ? getValue(params.get(WORKNOTES_QUEUE)) : null);
                        callableStatement.setString(117, params.containsKey(EXTERNALTICKETID) ? getDBValidatedValue(params.get(EXTERNALTICKETID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(118, params.containsKey(CATEGORY_SK) ? getDBValidatedValue(params.get(CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(119, params.containsKey(TYPE_SK) ? getDBValidatedValue(params.get(TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(120, params.containsKey(ITEM_SK) ? getDBValidatedValue(params.get(ITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(121, params.containsKey(OFFLINE_UNIQUE_ID) ? getDBValidatedValue(params.get(OFFLINE_UNIQUE_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSRTTicket(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 78);


            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, getValue(params.get(TICKETSK)));
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(TASK_ID) ? getDBValidatedValue(params.get(TASK_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(SERVICEREQUEST_SK) ? getValue(params.get(SERVICEREQUEST_SK)) : null);
                        callableStatement.setString(6, params.containsKey(PARENT) ? getDBValidatedValue(params.get(PARENT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(TASK_NAME) ? getValue(params.get(TASK_NAME)) : null);
                        callableStatement.setString(9, params.containsKey(TASK_DETAILS) ? getValue(params.get(TASK_DETAILS)) : null);
                        callableStatement.setString(10, params.containsKey(ASSIGNED_GROUP) ? getDBValidatedValue(params.get(ASSIGNED_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(ASSIGNED_INDIVIDUAL) ? getDBValidatedValue(params.get(ASSIGNED_INDIVIDUAL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(TASK_SEQUENCE) ? getValue(params.get(TASK_SEQUENCE)) : null);
                        callableStatement.setString(13, params.containsKey(FORM_BUILDER_ID) ? getDBValidatedValue(params.get(FORM_BUILDER_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(CLONED_SK) ? getDBValidatedValue(params.get(CLONED_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(PENDING_REASON) ? getDBValidatedValue(params.get(PENDING_REASON), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(ASSIGNED_ON) ? getDBValidatedValue(params.get(ASSIGNED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(18, params.containsKey(COMPLELTED_ON) ? getDBValidatedValue(params.get(COMPLELTED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(19, params.containsKey(PREV_ASSIGNED_INDIVIDUAL) ? getDBValidatedValue(params.get(PREV_ASSIGNED_INDIVIDUAL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(PREV_ASSIGNED_GROUP) ? getDBValidatedValue(params.get(PREV_ASSIGNED_GROUP), DATATYPE_INTEGER) : null);
                        callableStatement.setString(21, params.containsKey(IS_AUTO_CLOSE) ? getDBValidatedValue(params.get(IS_AUTO_CLOSE), DATATYPE_BIT) : null);
                        callableStatement.setString(22, params.containsKey(TICKET_TYPE) ? getDBValidatedValue(params.get(TICKET_TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(23, params.containsKey(GRP_CHG_COUNT) ? getDBValidatedValue(params.get(GRP_CHG_COUNT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(ATTRIBUTE_1) ? getDBValidatedValue(params.get(ATTRIBUTE_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(25, params.containsKey(ATTRIBUTE_2) ? getDBValidatedValue(params.get(ATTRIBUTE_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(26, params.containsKey(ATTRIBUTE_3) ? getDBValidatedValue(params.get(ATTRIBUTE_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(27, params.containsKey(ATTRIBUTE_4) ? getDBValidatedValue(params.get(ATTRIBUTE_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(28, params.containsKey(ATTRIBUTE_5) ? getDBValidatedValue(params.get(ATTRIBUTE_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(29, params.containsKey(ATTRIBUTE_6) ? getDBValidatedValue(params.get(ATTRIBUTE_6), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(30, params.containsKey(ATTRIBUTE_7) ? getDBValidatedValue(params.get(ATTRIBUTE_7), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(31, params.containsKey(ATTRIBUTE_8) ? getDBValidatedValue(params.get(ATTRIBUTE_8), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(32, params.containsKey(ATTRIBUTE_9) ? getDBValidatedValue(params.get(ATTRIBUTE_9), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(33, params.containsKey(ATTRIBUTE_10) ? getDBValidatedValue(params.get(ATTRIBUTE_10), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(34, params.containsKey(SF_PROCESS_ID) ? getDBValidatedValue(params.get(SF_PROCESS_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(35, params.containsKey(SF_FORM_ID) ? getDBValidatedValue(params.get(SF_FORM_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(36, params.containsKey(SF_SUBMISSION_ID) ? getDBValidatedValue(params.get(SF_SUBMISSION_ID), DATATYPE_INTEGER) : null);
                        callableStatement.setString(37, params.containsKey(IAM_ACTION) ? getDBValidatedValue(params.get(IAM_ACTION), DATATYPE_CHAR) : null);
                        callableStatement.setString(38, params.containsKey(WRK_DESCRIPTION) ? getValue(params.get(WRK_DESCRIPTION)) : null);
                        callableStatement.setString(39, params.containsKey(NOTIFY_OWNER) ? getValue(params.get(NOTIFY_OWNER)) : null);
                        callableStatement.setString(40, params.containsKey(WORKNOTE_TYPE) ? getValue(params.get(WORKNOTE_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createIncidentDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 48);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKETSK)));
                        callableStatement.setString(2, params.containsKey(ALT_USER_SK) ? getValue(params.get(ALT_USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ALT_IS_SYSTEM_USER) ? getValue(params.get(ALT_IS_SYSTEM_USER)) : null);
                        callableStatement.setString(4, params.containsKey(ALT_FIRSTNAME) ? getValue(params.get(ALT_FIRSTNAME)) : null);
                        callableStatement.setString(5, params.containsKey(ALT_LASTNAME) ? getValue(params.get(ALT_LASTNAME)) : null);
                        callableStatement.setString(6, params.containsKey(ALT_EMAIL_ADDRESS) ? getValue(params.get(ALT_EMAIL_ADDRESS)) : null);
                        callableStatement.setString(7, params.containsKey(ALT_BUILDING) ? getValue(params.get(ALT_BUILDING)) : null);
                        callableStatement.setString(8, params.containsKey(ALT_DEPARTMENT) ? getValue(params.get(ALT_DEPARTMENT)) : null);
                        callableStatement.setString(9, params.containsKey(ALT_FLOOR) ? getValue(params.get(ALT_FLOOR)) : null);
                        callableStatement.setString(10, params.containsKey(ALT_SUITE) ? getValue(params.get(ALT_SUITE)) : null);
                        callableStatement.setString(11, params.containsKey(ALT_OFFICE) ? getValue(params.get(ALT_OFFICE)) : null);
                        callableStatement.setString(12, params.containsKey(ALT_PHONE) ? getValue(params.get(ALT_PHONE)) : null);
                        callableStatement.setString(13, params.containsKey(ALT_PHONEEXT) ? getValue(params.get(ALT_PHONEEXT)) : null);
                        callableStatement.setString(14, params.containsKey(ALT_STATUS) ? getValue(params.get(ALT_STATUS)) : null);
                        callableStatement.setString(15, params.containsKey(ALT_REFID2) ? getValue(params.get(ALT_REFID2)) : null);
                        callableStatement.setString(16, params.containsKey(ALT_ACCOUNT_SK) ? getValue(params.get(ALT_ACCOUNT_SK)) : null);
                        callableStatement.setString(17, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(18, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(19, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(20, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(21, params.containsKey(KB_TICKET_MAPPING) ? getValue(params.get(KB_TICKET_MAPPING)) : null);
                        callableStatement.setString(22, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(23, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(24, params.containsKey(KB_ARTICLE_LOG) ? getValue(params.get(KB_ARTICLE_LOG)) : null);
                        callableStatement.setString(25, params.containsKey(MASTER_TYPE) ? getValue(params.get(MASTER_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createSRDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 48);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKETSK)));
                        callableStatement.setString(2, params.containsKey(ALT_USER_SK) ? getValue(params.get(ALT_USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ALT_IS_SYSTEM_USER) ? getValue(params.get(ALT_IS_SYSTEM_USER)) : null);
                        callableStatement.setString(4, params.containsKey(ALT_FIRSTNAME) ? getValue(params.get(ALT_FIRSTNAME)) : null);
                        callableStatement.setString(5, params.containsKey(ALT_LASTNAME) ? getValue(params.get(ALT_LASTNAME)) : null);
                        callableStatement.setString(6, params.containsKey(ALT_EMAIL_ADDRESS) ? getValue(params.get(ALT_EMAIL_ADDRESS)) : null);
                        callableStatement.setString(7, params.containsKey(ALT_BUILDING) ? getValue(params.get(ALT_BUILDING)) : null);
                        callableStatement.setString(8, params.containsKey(ALT_DEPARTMENT) ? getValue(params.get(ALT_DEPARTMENT)) : null);
                        callableStatement.setString(9, params.containsKey(ALT_FLOOR) ? getValue(params.get(ALT_FLOOR)) : null);
                        callableStatement.setString(10, params.containsKey(ALT_SUITE) ? getValue(params.get(ALT_SUITE)) : null);
                        callableStatement.setString(11, params.containsKey(ALT_OFFICE) ? getValue(params.get(ALT_OFFICE)) : null);
                        callableStatement.setString(12, params.containsKey(ALT_PHONE) ? getValue(params.get(ALT_PHONE)) : null);
                        callableStatement.setString(13, params.containsKey(ALT_PHONEEXT) ? getValue(params.get(ALT_PHONEEXT)) : null);
                        callableStatement.setString(14, params.containsKey(ALT_STATUS) ? getValue(params.get(ALT_STATUS)) : null);
                        callableStatement.setString(15, params.containsKey(ALT_REFID2) ? getValue(params.get(ALT_REFID2)) : null);
                        callableStatement.setString(16, params.containsKey(ALT_ACCOUNT_SK) ? getValue(params.get(ALT_ACCOUNT_SK)) : null);
                        callableStatement.setString(17, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(18, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(19, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(20, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(21, params.containsKey(KB_TICKET_MAPPING) ? getValue(params.get(KB_TICKET_MAPPING)) : null);
                        callableStatement.setString(22, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(23, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(24, params.containsKey(KB_ARTICLE_LOG) ? getValue(params.get(KB_ARTICLE_LOG)) : null);
                        callableStatement.setString(25, params.containsKey(MASTER_TYPE) ? getValue(params.get(MASTER_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createSRTaskDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKETSK)));
                        callableStatement.setString(2, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(3, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(4, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(5, params.containsKey(KB_TICKET_MAPPING) ? getValue(params.get(KB_TICKET_MAPPING)) : null);
                        callableStatement.setString(6, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(7, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(8, params.containsKey(KB_ARTICLE_LOG) ? getValue(params.get(KB_ARTICLE_LOG)) : null);
                        callableStatement.setString(9, params.containsKey(MASTER_TYPE) ? getValue(params.get(MASTER_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateIncidentDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 56);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, getValue(params.get(TICKETSK)));
                        callableStatement.setString(2, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(4, params.containsKey(ALT_USER_SK) ? getDBValidatedValue(params.get(ALT_USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ALT_IS_SYSTEM_USER) ? getValue(params.get(ALT_IS_SYSTEM_USER)) : null);
                        callableStatement.setString(6, params.containsKey(ALT_FIRSTNAME) ? getDBValidatedValue(params.get(ALT_FIRSTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(ALT_LASTNAME) ? getDBValidatedValue(params.get(ALT_LASTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(ALT_EMAIL_ADDRESS) ? getDBValidatedValue(params.get(ALT_EMAIL_ADDRESS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(ALT_BUILDING) ? getDBValidatedValue(params.get(ALT_BUILDING), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(ALT_DEPARTMENT) ? getDBValidatedValue(params.get(ALT_DEPARTMENT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(11, params.containsKey(ALT_FLOOR) ? getDBValidatedValue(params.get(ALT_FLOOR), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(ALT_SUITE) ? getDBValidatedValue(params.get(ALT_SUITE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(ALT_OFFICE) ? getDBValidatedValue(params.get(ALT_OFFICE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(ALT_PHONE) ? getDBValidatedValue(params.get(ALT_PHONE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(ALT_PHONEEXT) ? getDBValidatedValue(params.get(ALT_PHONEEXT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(ALT_STATUS) ? getDBValidatedValue(params.get(ALT_STATUS), DATATYPE_BIT) : null);
                        callableStatement.setString(17, params.containsKey(ALT_REFID2) ? getDBValidatedValue(params.get(ALT_REFID2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(ALT_ACCOUNT_SK) ? getDBValidatedValue(params.get(ALT_ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(SECURE_INFO_SK) ? getValue(params.get(SECURE_INFO_SK)) : null);
                        callableStatement.setString(20, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(21, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(22, params.containsKey(DELETE_ATTACHMENT_SK) ? getValue(convertDeleteAttachment_sk(params.get(DELETE_ATTACHMENT_SK))) : null);
                        callableStatement.setString(23, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(24, params.containsKey(KB_TICKET_MAPPING) ? getValue(params.get(KB_TICKET_MAPPING)) : null);
                        callableStatement.setString(25, params.containsKey(KB_ARTICLE_LOG) ? getValue(params.get(KB_ARTICLE_LOG)) : null);
                        callableStatement.setString(26, params.containsKey(MASTER_TYPE) ? getValue(params.get(MASTER_TYPE)) : null);
                        callableStatement.setString(27, params.containsKey(ALT_CONTACT_SK) ? getValue(params.get(ALT_CONTACT_SK)) : null);
                        callableStatement.setString(28, params.containsKey(ROOT_CAUSE) ? getValue(params.get(ROOT_CAUSE)) : null);
                        callableStatement.setString(29, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static Map<String, Object> updateServiceRequestDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 56);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKETSK)));
                        callableStatement.setString(2, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(IS_ALTERNATE_USER) ? getValue(params.get(IS_ALTERNATE_USER)) : null);
                        callableStatement.setString(4, params.containsKey(ALT_USER_SK) ? getDBValidatedValue(params.get(ALT_USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ALT_IS_SYSTEM_USER) ? getValue(params.get(ALT_IS_SYSTEM_USER)) : null);
                        callableStatement.setString(6, params.containsKey(ALT_FIRSTNAME) ? getDBValidatedValue(params.get(ALT_FIRSTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(ALT_LASTNAME) ? getDBValidatedValue(params.get(ALT_LASTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(ALT_EMAIL_ADDRESS) ? getDBValidatedValue(params.get(ALT_EMAIL_ADDRESS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(ALT_BUILDING) ? getDBValidatedValue(params.get(ALT_BUILDING), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(ALT_DEPARTMENT) ? getDBValidatedValue(params.get(ALT_DEPARTMENT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(11, params.containsKey(ALT_FLOOR) ? getDBValidatedValue(params.get(ALT_FLOOR), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(ALT_SUITE) ? getDBValidatedValue(params.get(ALT_SUITE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(ALT_OFFICE) ? getDBValidatedValue(params.get(ALT_OFFICE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(ALT_PHONE) ? getDBValidatedValue(params.get(ALT_PHONE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(ALT_PHONEEXT) ? getDBValidatedValue(params.get(ALT_PHONEEXT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(ALT_STATUS) ? getDBValidatedValue(params.get(ALT_STATUS), DATATYPE_BIT) : null);
                        callableStatement.setString(17, params.containsKey(ALT_REFID2) ? getDBValidatedValue(params.get(ALT_REFID2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(ALT_ACCOUNT_SK) ? getDBValidatedValue(params.get(ALT_ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(SECURE_INFO_SK) ? getValue(params.get(SECURE_INFO_SK)) : null);
                        callableStatement.setString(20, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(21, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(22, params.containsKey(DELETE_ATTACHMENT_SK) ? getValue(convertDeleteAttachment_sk(params.get(DELETE_ATTACHMENT_SK))) : null);
                        callableStatement.setString(23, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(24, params.containsKey(KB_TICKET_MAPPING) ? getValue(params.get(KB_TICKET_MAPPING)) : null);
                        callableStatement.setString(25, params.containsKey(KB_ARTICLE_LOG) ? getValue(params.get(KB_ARTICLE_LOG)) : null);
                        callableStatement.setString(26, params.containsKey(MASTER_TYPE) ? getValue(params.get(MASTER_TYPE)) : null);
                        callableStatement.setString(27, params.containsKey(ALT_CONTACT_SK) ? getValue(params.get(ALT_CONTACT_SK)) : null);
                        callableStatement.setString(28, params.containsKey(ROOT_CAUSE) ? getValue(params.get(ROOT_CAUSE)) : null);
                        callableStatement.setString(29, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static String convertDeleteAttachment_sk(Object deleteattachment_sk) {
        if (deleteattachment_sk instanceof ArrayList)
            return ((ArrayList<String>) deleteattachment_sk)
                    .stream().reduce(COMMA, String::concat);
        else if (deleteattachment_sk instanceof String)
            return deleteattachment_sk.toString();
        else
            return null;
    }

    public static Map<String, Object> updateSRTaskDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, getValue(params.get(TICKETSK)));
                        callableStatement.setString(2, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(SECURE_INFO_SK) ? getValue(params.get(SECURE_INFO_SK)) : null);
                        callableStatement.setString(4, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(5, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(6, params.containsKey(DELETE_ATTACHMENT_SK) ? getValue(convertDeleteAttachment_sk(params.get(DELETE_ATTACHMENT_SK))) : null);
                        callableStatement.setString(7, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(8, params.containsKey(KB_TICKET_MAPPING) ? getValue(params.get(KB_TICKET_MAPPING)) : null);
                        callableStatement.setString(9, params.containsKey(KB_ARTICLE_LOG) ? getValue(params.get(KB_ARTICLE_LOG)) : null);
                        callableStatement.setString(10, params.containsKey(MASTER_TYPE) ? getValue(params.get(MASTER_TYPE)) : null);
                        callableStatement.setString(11, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Object mandatoryFieldErrorMessage(List<String> fields, String endpointName) throws IOException {
        return SFInterfaceServices.getInfoMap("INFO.MESSAGE.MISSINGREQUIREDFIELDSFORCREATEORUPDATE", String.join(COMMA, fields), endpointName);
    }

    public static Map<String, Object> createVacationDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(LOGIN_USER_SK) ? getValue(params.get(LOGIN_USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(4, params.containsKey(START_DATE) ? getValue(params.get(START_DATE)) : null);
                        callableStatement.setString(5, params.containsKey(END_DATE) ? getValue(params.get(END_DATE)) : null);
                        callableStatement.setString(6, params.containsKey(REASON) ? getValue(params.get(REASON)) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateVacationDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(USER_VACATION_SK) ? getValue(params.get(USER_VACATION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(LOGIN_USER_SK) ? getValue(params.get(LOGIN_USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(START_DATE) ? getValue(params.get(START_DATE)) : null);
                        callableStatement.setString(4, params.containsKey(END_DATE) ? getValue(params.get(END_DATE)) : null);
                        callableStatement.setString(5, params.containsKey(REASON) ? getValue(params.get(REASON)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createDocumentDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(REPOSITORY_NAME) ? getValue(params.get(REPOSITORY_NAME)) : null);
                        callableStatement.setString(3, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(5, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDocumentDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(REPOSITORY_SK) ? getValue(params.get(REPOSITORY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(REPOSITORY_NAME) ? getValue(params.get(REPOSITORY_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(6, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(DELETE_ATTACHMENT_SK) ? getValue(convertDeleteAttachment_sk(params.get(DELETE_ATTACHMENT_SK))) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createSupportDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 28);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(3, params.containsKey(CATEGORY_SK) ? getValue(params.get(CATEGORY_SK)) : null);
                        callableStatement.setString(4, params.containsKey(TYPE_SK) ? getValue(params.get(TYPE_SK)) : null);
                        callableStatement.setString(5, params.containsKey(START_DATE) ? getValue(params.get(START_DATE)) : null);
                        callableStatement.setString(6, params.containsKey(END_DATE) ? getValue(params.get(END_DATE)) : null);
                        callableStatement.setString(7, params.containsKey(SUPPORT_TYPE) ? getValue(params.get(SUPPORT_TYPE)) : null);
                        callableStatement.setString(8, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(9, params.containsKey(NOTES) ? getValue(params.get(NOTES)) : null);
                        callableStatement.setString(10, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(11, params.containsKey(GLOBAL) ? getValue(params.get(GLOBAL)) : null);
                        callableStatement.setString(12, params.containsKey(PRIMARY_USER_SK) ? getValue(params.get(PRIMARY_USER_SK)) : null);
                        callableStatement.setString(13, params.containsKey(SECONDARY_USER_SK) ? getValue(params.get(SECONDARY_USER_SK)) : null);
                        callableStatement.setString(14, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(15, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_SUPPORT_DETAILS, queryObject.get(INDEXERNAME_FETCH_SUPPORT_INDEXER_SK).toString(), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSupportDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 32);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SUPPORT_SK) ? getValue(params.get(SUPPORT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(4, params.containsKey(CATEGORY_SK) ? getValue(params.get(CATEGORY_SK)) : null);
                        callableStatement.setString(5, params.containsKey(TYPE_SK) ? getValue(params.get(TYPE_SK)) : null);
                        callableStatement.setString(6, params.containsKey(START_DATE) ? getValue(params.get(START_DATE)) : null);
                        callableStatement.setString(7, params.containsKey(END_DATE) ? getValue(params.get(END_DATE)) : null);
                        callableStatement.setString(8, params.containsKey(SUPPORT_TYPE) ? getValue(params.get(SUPPORT_TYPE)) : null);
                        callableStatement.setString(9, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(10, params.containsKey(NOTES) ? getValue(params.get(NOTES)) : null);
                        callableStatement.setString(11, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(12, params.containsKey(GLOBAL) ? getValue(params.get(GLOBAL)) : null);
                        callableStatement.setString(13, params.containsKey(PRIMARY_USER_SK) ? getValue(params.get(PRIMARY_USER_SK)) : null);
                        callableStatement.setString(14, params.containsKey(SECONDARY_USER_SK) ? getValue(params.get(SECONDARY_USER_SK)) : null);
                        callableStatement.setString(15, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(16, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(17, params.containsKey(DELETE_ATTACHMENT_SK) ? getValue(convertDeleteAttachment_sk(params.get(DELETE_ATTACHMENT_SK))) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_SUPPORT_DETAILS, queryObject.get(INDEXERNAME_FETCH_SUPPORT_INDEXER_SK).toString(), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateProfileInfo(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 108);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(PEOPLE_INFO_SK) ? getDBValidatedValue(params.get(PEOPLE_INFO_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(2, params.containsKey(BUILDING) ? getDBValidatedValue(params.get(BUILDING), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(DEPARTMENT) ? getDBValidatedValue(params.get(DEPARTMENT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(FLOOR) ? getDBValidatedValue(params.get(FLOOR), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(SUITE) ? getDBValidatedValue(params.get(SUITE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(OFFICE) ? getDBValidatedValue(params.get(OFFICE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(EMAIL_ADDRESS) ? getDBValidatedValue(params.get(EMAIL_ADDRESS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(PHONE_WORK) ? getDBValidatedValue(params.get(PHONE_WORK), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(PHONE_EXTN) ? getDBValidatedValue(params.get(PHONE_EXTN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(FAX) ? getDBValidatedValue(params.get(FAX), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(11, params.containsKey(PAGER_NUMERIC) ? getDBValidatedValue(params.get(PAGER_NUMERIC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(PAGER_PIN) ? getDBValidatedValue(params.get(PAGER_PIN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(PAGER_ALPHA) ? getDBValidatedValue(params.get(PAGER_ALPHA), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(PHONE_CELL) ? getDBValidatedValue(params.get(PHONE_CELL), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(PHONE_HOME) ? getDBValidatedValue(params.get(PHONE_HOME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(CONTACT_TYPE_SK) ? getDBValidatedValue(params.get(CONTACT_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(CLIENT_NOTES) ? getDBValidatedValue(params.get(CLIENT_NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(NOTE_EXPIRES) ? getDBValidatedValue(params.get(NOTE_EXPIRES), DATATYPE_DATETIME) : null);
                        callableStatement.setString(19, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(20, params.containsKey(SSP_PREFERED_CONTACT_METHOD) ? getDBValidatedValue(params.get(SSP_PREFERED_CONTACT_METHOD), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(21, params.containsKey(AD_COMPANY) ? getDBValidatedValue(params.get(AD_COMPANY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(22, params.containsKey(AD_DEPARTMENT) ? getDBValidatedValue(params.get(AD_DEPARTMENT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(23, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(CST) ? getDBValidatedValue(params.get(CST), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(25, params.containsKey(DESIGNATION) ? getDBValidatedValue(params.get(DESIGNATION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(26, params.containsKey(EMPLOYEE_NUMBER) ? getDBValidatedValue(params.get(EMPLOYEE_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(27, params.containsKey(FIRSTNAME) ? getDBValidatedValue(params.get(FIRSTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(28, params.containsKey(LASTNAME) ? getDBValidatedValue(params.get(LASTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(29, params.containsKey(LOGIN_ID) ? getDBValidatedValue(params.get(LOGIN_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(30, params.containsKey(MANAGER_LOGIN) ? getDBValidatedValue(params.get(MANAGER_LOGIN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(31, params.containsKey(MANAGER_NAME) ? getDBValidatedValue(params.get(MANAGER_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(32, params.containsKey(MIDDLE_INIT) ? getDBValidatedValue(params.get(MIDDLE_INIT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(33, params.containsKey(FULL_NAME) ? getValue(params.get(FULL_NAME)) : null);
                        callableStatement.setString(34, params.containsKey(NETWORK_LOGIN) ? getDBValidatedValue(params.get(NETWORK_LOGIN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(35, params.containsKey(QUEUE_sk) ? getDBValidatedValue(params.get(QUEUE_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(36, params.containsKey(ROLE_PREFIX) ? getDBValidatedValue(params.get(ROLE_PREFIX), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(37, params.containsKey(ROLE) ? getDBValidatedValue(params.get(ROLE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(38, params.containsKey(PEOPLE_INFO_STATUS_SK) ? getDBValidatedValue(params.get(PEOPLE_INFO_STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(39, params.containsKey(IS_SUPPORT_PERSON) ? getDBValidatedValue(params.get(IS_SUPPORT_PERSON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(40, params.containsKey(TITLE_SK) ? getDBValidatedValue(params.get(TITLE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(41, params.containsKey(VIP) ? getDBValidatedValue(params.get(VIP), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(42, params.containsKey(USERTYPE_SK) ? getDBValidatedValue(params.get(USERTYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(43, params.containsKey(BUSINESS_ORGANIZATION) ? getDBValidatedValue(params.get(BUSINESS_ORGANIZATION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(44, params.containsKey(USER_POSITION_SK) ? getValue(params.get(USER_POSITION_SK)) : null);
                        callableStatement.setString(45, params.containsKey(BUILDING_SK) ? getDBValidatedValue(params.get(BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(46, params.containsKey(BUS_ORG_SK) ? getDBValidatedValue(params.get(BUS_ORG_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(47, params.containsKey(DEPARTMENT_SK) ? getDBValidatedValue(params.get(DEPARTMENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(48, params.containsKey(FLOOR_SK) ? getDBValidatedValue(params.get(FLOOR_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(49, params.containsKey(SUITE_SK) ? getDBValidatedValue(params.get(SUITE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(50, params.containsKey(USER_POSITION_STATUS_SK) ? getDBValidatedValue(params.get(USER_POSITION_STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(51, params.containsKey(IS_PRIMARY_LOCATION) ? getDBValidatedValue(params.get(IS_PRIMARY_LOCATION), DATATYPE_BIT) : null);
                        callableStatement.setString(52, params.containsKey(RETURN_ON) ? getDBValidatedValue(params.get(RETURN_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(53, params.containsKey(CLIENT_EXECUTIVE) ? getValue(params.get(CLIENT_EXECUTIVE)) : null);
                        callableStatement.setString(54, params.containsKey(COST_CODE) ? getDBValidatedValue(params.get(COST_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(55, params.containsKey(COMPANY_CODE) ? getDBValidatedValue(params.get(COMPANY_CODE), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_PROFILE, getValue(params.get(PEOPLE_INFO_SK)), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateWatchlist(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 6);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(4, params.containsKey(FUNCTION_TYPE) ? getValue(params.get(FUNCTION_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_WATCHLIST, queryObject.get(INDEXERNAME_FETCH_WATCHLIST_INDEXER_SK).toString(), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRUserFavorities(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USERFAVOURITE_SK) ? getValue(params.get(USERFAVOURITE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CreatedBy) ? getValue(params.get(CreatedBy)) : null);
                        callableStatement.setString(6, params.containsKey(ModifiedBy) ? getValue(params.get(ModifiedBy)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(INDEXERNAME_FETCH_CR_USER_FAVORITIES_INDEXER_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_USER_FAVORITIES, queryObject.get(INDEXERNAME_FETCH_CR_USER_FAVORITIES_INDEXER_SK).toString(), user.getClientInstance()));

                }
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateProfilePrefrence(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 6);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(4, params.containsKey(PREFRENCE) ? getValue(params.get(PREFRENCE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> createProblemManager(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(4, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(5, params.containsKey(START_DATE) ? getValue(params.get(START_DATE)) : null);
                        callableStatement.setString(6, params.containsKey(END_DATE) ? getValue(params.get(END_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                Set<String> updatedkey = result.parallelStream()
                        .filter(stringObjectMap -> stringObjectMap.get(PROBLEM_MANAGER_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(PROBLEM_MANAGER_SK).toString())
                        .collect(Collectors.toSet());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_PROBLEM_MANAGER, updatedkey.toArray(new String[0]), user.getClientInstance()));
                updatedkey = result.parallelStream()
                        .filter(stringObjectMap -> stringObjectMap.get(ACC_GROUP_USER_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(ACC_GROUP_USER_SK).toString())
                        .collect(Collectors.toSet());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_USERGROUPS, updatedkey.toArray(new String[0]), user.getClientInstance()));
                return result;
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return result;
    }

    public static List<Map<String, Object>> updateProblemManager(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(PROBLEM_MANAGER_SK) ? getValue(params.get(PROBLEM_MANAGER_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(5, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(START_DATE) ? getValue(params.get(START_DATE)) : null);
                        callableStatement.setString(7, params.containsKey(END_DATE) ? getValue(params.get(END_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                Set<String> updatedkey = result.parallelStream()
                        .filter(stringObjectMap -> stringObjectMap.get(PROBLEM_MANAGER_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(PROBLEM_MANAGER_SK).toString())
                        .collect(Collectors.toSet());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_PROBLEM_MANAGER, updatedkey.toArray(new String[0]), user.getClientInstance()));
                updatedkey = result.parallelStream()
                        .filter(stringObjectMap -> stringObjectMap.get(ACC_GROUP_USER_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(ACC_GROUP_USER_SK).toString())
                        .collect(Collectors.toSet());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_USERGROUPS, updatedkey.toArray(new String[0]), user.getClientInstance()));
                return result;

            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return result;
    }

    public static List<Map<String, Object>> updateUserPrefrence(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> resul = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(USER_PREFERENCES) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                resul = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey = resul.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(INDEXERNAME_FETCH_USERPREFERENCE_INDEXER_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(INDEXERNAME_FETCH_USERPREFERENCE_INDEXER_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_USERPREFERENCE, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
                return resul;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            resul.add(queryObject);
        }

        return resul;
    }

    public static List<Map<String, Object>> updateAccountGroupUser(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> resul = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACC_GROUP_USER) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                resul = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey = resul.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(ACC_GROUP_USER_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(ACC_GROUP_USER_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_USERGROUPS, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
                return resul;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            resul.add(queryObject);
        }

        return resul;
    }

    public static Map<String, Object> updateUserNotes(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(USERNOTE_SK) ? getValue(params.get(USERNOTE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(4, params.containsKey(IS_PUBLIC) ? getValue(params.get(IS_PUBLIC)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List indexer_sk = new ArrayList();
                List<Map<String, Object>> queryList = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                queryList.stream().forEach(object -> {
                    indexer_sk.add(object.get(INDEXERNAME_FETCH_USERNOTES_INDEXER_SK).toString());
                });
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_USERNOTES, SFInterfaceServices.GetStringArray(indexer_sk), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSecureInfoHistory(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BUSINESS_FUNCTION_CODE) ? getValue(params.get(BUSINESS_FUNCTION_CODE)) : null);
                        callableStatement.setString(2, params.containsKey(SECURE_INFORMATION_SK) ? getValue(params.get(SECURE_INFORMATION_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ACTION) ? getValue(params.get(ACTION)) : null);
                        callableStatement.setString(4, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(5, params.containsKey(SECURE_INFORMATION) ? getValue(params.get(SECURE_INFORMATION)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDownloadedAttachmentsHistory(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BUSINESS_FUNCTION_CODE) ? getValue(params.get(BUSINESS_FUNCTION_CODE)) : null);
                        callableStatement.setString(2, params.containsKey(ATTACHMENTS_SK) ? getValue(params.get(ATTACHMENTS_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ACTION) ? getValue(params.get(ACTION)) : null);
                        callableStatement.setString(4, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(5, params.containsKey(SECURE_INFORMATION_SK) ? getValue(params.get(SECURE_INFORMATION_SK)) : null);
                        callableStatement.setString(6, params.containsKey(FILE_NAME) ? getValue(params.get(FILE_NAME)) : null);
                        callableStatement.setString(7, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(8, params.containsKey(FILE_TYPE) ? getValue(params.get(FILE_TYPE)) : null);
                        callableStatement.setString(9, params.containsKey(FILE_PATH) ? getValue(params.get(FILE_PATH)) : null);
                        callableStatement.setString(10, params.containsKey(FILE_SIZE) ? getValue(params.get(FILE_SIZE)) : null);
                        callableStatement.setString(11, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(12, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateINCEmailDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 32);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(INC_SK) ? getDBValidatedValue(params.get(INC_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(2, params.containsKey(MAIL_TEMPLATE_SK) ? getDBValidatedValue(params.get(MAIL_TEMPLATE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(4, params.containsKey(FROM) ? getValue(params.get(FROM)) : null);
                        callableStatement.setString(5, params.containsKey(TO) ? getValue(params.get(TO)) : null);
                        callableStatement.setString(6, params.containsKey(CC) ? getDBValidatedValue(params.get(CC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(SUBJECT) ? getValue(params.get(SUBJECT)) : null);
                        callableStatement.setString(8, params.containsKey(MAIL_BODY) ? getDBValidatedValue(params.get(MAIL_BODY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(10, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(11, params.containsKey(INC_NUMBER) ? getDBValidatedValue(params.get(INC_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(EMAIL_SK) ? getValue(params.get(EMAIL_SK)) : null);
                        callableStatement.setString(13, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(SREMAIL_SK) ? getDBValidatedValue(params.get(SREMAIL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(MAILID) ? getDBValidatedValue(params.get(MAILID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(OFFLINE_UNIQUE_ID) ? getDBValidatedValue(params.get(OFFLINE_UNIQUE_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSREmailDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 32);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SR_SK) ? getDBValidatedValue(params.get(SR_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(2, params.containsKey(MAIL_TEMPLATE_SK) ? getDBValidatedValue(params.get(MAIL_TEMPLATE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(4, params.containsKey(FROM) ? getValue(params.get(FROM)) : null);
                        callableStatement.setString(5, params.containsKey(TO) ? getValue(params.get(TO)) : null);
                        callableStatement.setString(6, params.containsKey(CC) ? getDBValidatedValue(params.get(CC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(SUBJECT) ? getValue(params.get(SUBJECT)) : null);
                        callableStatement.setString(8, params.containsKey(MAIL_BODY) ? getDBValidatedValue(params.get(MAIL_BODY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(10, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(11, params.containsKey(SR_NUMBER) ? getDBValidatedValue(params.get(SR_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(EMAIL_SK) ? getValue(params.get(EMAIL_SK)) : null);
                        callableStatement.setString(13, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(INCEMAIL_SK) ? getDBValidatedValue(params.get(INCEMAIL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(MAILID) ? getDBValidatedValue(params.get(MAILID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(OFFLINE_UNIQUE_ID) ? getDBValidatedValue(params.get(OFFLINE_UNIQUE_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSRTEmailDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 30);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SRT_SK) ? getDBValidatedValue(params.get(SRT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(2, params.containsKey(MAIL_TEMPLATE_SK) ? getDBValidatedValue(params.get(MAIL_TEMPLATE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(4, params.containsKey(FROM) ? getValue(params.get(FROM)) : null);
                        callableStatement.setString(5, params.containsKey(TO) ? getValue(params.get(TO)) : null);
                        callableStatement.setString(6, params.containsKey(CC) ? getDBValidatedValue(params.get(CC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(SUBJECT) ? getValue(params.get(SUBJECT)) : null);
                        callableStatement.setString(8, params.containsKey(MAIL_BODY) ? getDBValidatedValue(params.get(MAIL_BODY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(10, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(11, params.containsKey(SRT_NUMBER) ? getDBValidatedValue(params.get(SRT_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(EMAIL_SK) ? getValue(params.get(EMAIL_SK)) : null);
                        callableStatement.setString(13, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(ENTITYNAME) ? getDBValidatedValue(params.get(ENTITYNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(ENTITY_sk) ? getDBValidatedValue(params.get(ENTITY_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(MAILID) ? getDBValidatedValue(params.get(MAILID), DATATYPE_VARCHAR) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createINCReport(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 162);  // 81 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varFloat = new SqlParameter(Types.FLOAT);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varDateTime); // 15
            paramList.add(varDateTime); // 16
            paramList.add(varDateTime); // 17
            paramList.add(varDateTime); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varString); // 35
            paramList.add(varString); // 36
            paramList.add(varDateTime); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39
            paramList.add(varString); // 40
            paramList.add(varString); // 41
            paramList.add(varString); // 42
            paramList.add(varString); // 43
            paramList.add(varString); // 44
            paramList.add(varString); // 45
            paramList.add(varString); // 46
            paramList.add(varDateTime); // 47
            paramList.add(varDateTime); // 48
            paramList.add(varString); // 49
            paramList.add(varString); // 50
            paramList.add(varString); // 52
            paramList.add(varString); // 52
            paramList.add(varFloat); // 53
            paramList.add(varString); // 54
            paramList.add(varString); //55
            paramList.add(varString); //56
            paramList.add(varString); // 57
            paramList.add(varString); // 58
            paramList.add(varString); // 59
            paramList.add(varString); // 60
            paramList.add(varString); // 61
            paramList.add(varString); // 62
            paramList.add(varString); //63
            paramList.add(varString); //64
            paramList.add(varString); // 65
            paramList.add(varString); // 66
            paramList.add(varString); // 67
            paramList.add(varString); // 68
            paramList.add(varString); // 69
            paramList.add(varString); // 70
            paramList.add(varString); //71
            paramList.add(varString); //72
            paramList.add(varString); //73
            paramList.add(varString); //74
            paramList.add(varString); //75
            paramList.add(varString); //76
            paramList.add(varString); //77
            paramList.add(varString); //78
            paramList.add(varString); //79
            paramList.add(varString); //80
            paramList.add(varString); //81
            paramList.add(varString); //82

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, params.containsKey(PARENT) ? getValue(params.get(PARENT)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(FIRSTNAME) ? getValue(params.get(FIRSTNAME)) : null);
                        callableStatement.setString(6, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);
                        callableStatement.setString(7, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(8, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(9, params.containsKey(NETWORK_LOGIN) ? getValue(params.get(NETWORK_LOGIN)) : null);
                        callableStatement.setString(10, params.containsKey(LOGIN_ID) ? getValue(params.get(LOGIN_ID)) : null);
                        callableStatement.setString(11, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(12, params.containsKey(SUBMITTED_BY) ? getValue(params.get(SUBMITTED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(SUBMITTER_NAME) ? getValue(params.get(SUBMITTER_NAME)) : null);
                        callableStatement.setString(14, params.containsKey(EMAIL_ADDRESS) ? getValue(params.get(EMAIL_ADDRESS)) : null);
                        callableStatement.setString(15, params.containsKey(DATE_TIME_CREATED) ? getValue(params.get(DATE_TIME_CREATED)) : null);
                        callableStatement.setString(16, params.containsKey(DATE_TIME_ASSIGNED) ? getValue(params.get(DATE_TIME_ASSIGNED)) : null);
                        callableStatement.setString(17, params.containsKey(DATE_TIME_WORK_IN_PROGRESS) ? getValue(params.get(DATE_TIME_WORK_IN_PROGRESS)) : null);
                        callableStatement.setString(18, params.containsKey(FIRST_ACKNOWLEDGE) ? getValue(params.get(FIRST_ACKNOWLEDGE)) : null);
                        callableStatement.setString(19, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(20, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(21, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(22, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(23, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(24, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(25, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(26, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(27, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(28, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(29, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(30, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(31, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(32, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(33, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(34, params.containsKey(Z_SUBMITTER_GROUP) ? getValue(params.get(Z_SUBMITTER_GROUP)) : null);
                        callableStatement.setString(35, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(36, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(37, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(38, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(39, params.containsKey(FLR_POSSIBLE) ? getValue(params.get(FLR_POSSIBLE)) : null);
                        callableStatement.setString(40, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(41, params.containsKey(CASE_TYPE) ? getValue(params.get(CASE_TYPE)) : null);
                        callableStatement.setString(42, params.containsKey(ADEQUATE_DETAILS_NO) ? getValue(params.get(ADEQUATE_DETAILS_NO)) : null);
                        callableStatement.setString(43, params.containsKey(ADEQUATE_DETAILS) ? getValue(params.get(ADEQUATE_DETAILS)) : null);
                        callableStatement.setString(44, params.containsKey(VERIFIED_INFORMATION) ? getValue(params.get(VERIFIED_INFORMATION)) : null);
                        callableStatement.setString(45, params.containsKey(NO_VERIFY_REASON) ? getValue(params.get(NO_VERIFY_REASON)) : null);
                        callableStatement.setString(46, params.containsKey(COST_CENTER) ? getValue(params.get(COST_CENTER)) : null);
                        callableStatement.setString(47, params.containsKey(DATE_TIME_PENDING_ON) ? getValue(params.get(DATE_TIME_PENDING_ON)) : null);
                        callableStatement.setString(48, params.containsKey(DATE_TIME_PENDING_OFF) ? getValue(params.get(DATE_TIME_PENDING_OFF)) : null);
                        callableStatement.setString(49, params.containsKey(ASSET_TAG) ? getValue(params.get(ASSET_TAG)) : null);
                        callableStatement.setString(50, params.containsKey(COMPUTER_NAME) ? getValue(params.get(COMPUTER_NAME)) : null);
                        callableStatement.setString(51, params.containsKey(SOLUTION_DOCUMENT_ID) ? getValue(params.get(SOLUTION_DOCUMENT_ID)) : null);
                        callableStatement.setString(52, params.containsKey(VENDOR_REF) ? getValue(params.get(VENDOR_REF)) : null);
                        callableStatement.setString(53, params.containsKey(TOTAL_COST) ? getValue(params.get(TOTAL_COST)) : null);
                        callableStatement.setString(54, params.containsKey(EVENT_SCHEDULE) ? getValue(params.get(EVENT_SCHEDULE)) : null);
                        callableStatement.setString(55, params.containsKey(FLR_ACHIEVED) ? getValue(params.get(FLR_ACHIEVED)) : null);
                        callableStatement.setString(56, params.containsKey(DATE_TIME_CLOSED) ? getValue(params.get(DATE_TIME_CLOSED)) : null);
                        callableStatement.setString(57, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(58, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(59, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(60, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(61, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(62, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(63, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(64, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(65, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(66, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(67, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(68, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(69, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(70, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(71, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(72, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(73, params.containsKey(ALERTSTATUS_SK) ? getValue(params.get(ALERTSTATUS_SK)) : null);
                        callableStatement.setString(74, params.containsKey(RKM_REASON) ? getValue(params.get(RKM_REASON)) : null);
                        callableStatement.setString(75, params.containsKey(PARENT_TICKET) ? getValue(params.get(PARENT_TICKET)) : null);
                        callableStatement.setString(76, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);
                        callableStatement.setString(77, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(78, params.containsKey(ZASSIGNED_GROUP) ? getValue(params.get(ZASSIGNED_GROUP)) : null);
                        callableStatement.setString(79, params.containsKey(ZASSIGN_LOGIN) ? getValue(params.get(ZASSIGN_LOGIN)) : null);
                        callableStatement.setString(80, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(81, params.containsKey(SUPPORT_PERSON) ? getValue(params.get(SUPPORT_PERSON)) : null);
                        callableStatement.setString(82, params.containsKey(ZASSIGN_GROUP_ID) ? getValue(params.get(ZASSIGN_GROUP_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createSRReport(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 160);  // 80 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varFloat = new SqlParameter(Types.FLOAT);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varDateTime); // 14
            paramList.add(varDateTime); // 15
            paramList.add(varDateTime); // 16
            paramList.add(varDateTime); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varDateTime); // 35
            paramList.add(varString); // 36
            paramList.add(varString); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39
            paramList.add(varString); // 40
            paramList.add(varString); // 41
            paramList.add(varString); // 42
            paramList.add(varString); // 43
            paramList.add(varDateTime); // 44
            paramList.add(varDateTime); // 45
            paramList.add(varString); // 46
            paramList.add(varString); // 47
            paramList.add(varString); // 48
            paramList.add(varString); // 49
            paramList.add(varFloat); // 50
            paramList.add(varString); // 52
            paramList.add(varString); // 52
            paramList.add(varString); // 53
            paramList.add(varString); // 54
            paramList.add(varString); // 55
            paramList.add(varString); // 56
            paramList.add(varString); // 57
            paramList.add(varString); // 58
            paramList.add(varString); // 59
            paramList.add(varString); // 60
            paramList.add(varString); // 61
            paramList.add(varString); // 62
            paramList.add(varString); //63
            paramList.add(varString); //64
            paramList.add(varString); // 65
            paramList.add(varString); // 66
            paramList.add(varString); // 67
            paramList.add(varString); // 68
            paramList.add(varString); // 69
            paramList.add(varString); // 70
            paramList.add(varString); //71
            paramList.add(varString); //72
            paramList.add(varString); //73
            paramList.add(varString); //74
            paramList.add(varString); //75
            paramList.add(varString); //76
            paramList.add(varString); //77
            paramList.add(varString); //78
            paramList.add(varString); //79
            paramList.add(varString); //80
            paramList.add(varString); //81
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, getValue(params.get(TICKET_NUMBER)));
                        callableStatement.setString(2, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(FIRSTNAME) ? getValue(params.get(FIRSTNAME)) : null);
                        callableStatement.setString(5, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);
                        callableStatement.setString(6, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(7, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(8, params.containsKey(NETWORK_LOGIN) ? getValue(params.get(NETWORK_LOGIN)) : null);
                        callableStatement.setString(9, params.containsKey(LOGIN_ID) ? getValue(params.get(LOGIN_ID)) : null);
                        callableStatement.setString(10, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(11, params.containsKey(SUBMITTED_BY) ? getValue(params.get(SUBMITTED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(SUBMITTER_NAME) ? getValue(params.get(SUBMITTER_NAME)) : null);
                        callableStatement.setString(13, params.containsKey(EMAIL_ADDRESS) ? getValue(params.get(EMAIL_ADDRESS)) : null);
                        callableStatement.setString(14, params.containsKey(DATE_TIME_CREATED) ? getValue(params.get(DATE_TIME_CREATED)) : null);
                        callableStatement.setString(15, params.containsKey(DATE_TIME_ASSIGNED) ? getValue(params.get(DATE_TIME_ASSIGNED)) : null);
                        callableStatement.setString(16, params.containsKey(DATE_TIME_WORK_IN_PROGRESS) ? getValue(params.get(DATE_TIME_WORK_IN_PROGRESS)) : null);
                        callableStatement.setString(17, params.containsKey(FIRST_ACKNOWLEDGE) ? getValue(params.get(FIRST_ACKNOWLEDGE)) : null);
                        callableStatement.setString(18, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(19, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(20, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(21, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(22, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(23, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(24, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(25, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(26, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(27, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(28, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(29, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(30, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(31, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(32, params.containsKey(Z_SUBMITTER_GROUP) ? getValue(params.get(Z_SUBMITTER_GROUP)) : null);
                        callableStatement.setString(33, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(34, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(35, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(36, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(37, params.containsKey(FLR_POSSIBLE) ? getValue(params.get(FLR_POSSIBLE)) : null);
                        callableStatement.setString(38, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(39, params.containsKey(CASE_TYPE) ? getValue(params.get(CASE_TYPE)) : null);
                        callableStatement.setString(40, params.containsKey(ADEQUATE_DETAILS_NO) ? getValue(params.get(ADEQUATE_DETAILS_NO)) : null);
                        callableStatement.setString(41, params.containsKey(ADEQUATE_DETAILS) ? getValue(params.get(ADEQUATE_DETAILS)) : null);
                        callableStatement.setString(42, params.containsKey(NO_VERIFY_REASON) ? getValue(params.get(NO_VERIFY_REASON)) : null);
                        callableStatement.setString(43, params.containsKey(COST_CENTER) ? getValue(params.get(COST_CENTER)) : null);
                        callableStatement.setString(44, params.containsKey(DATE_TIME_PENDING_ON) ? getValue(params.get(DATE_TIME_PENDING_ON)) : null);
                        callableStatement.setString(45, params.containsKey(DATE_TIME_PENDING_OFF) ? getValue(params.get(DATE_TIME_PENDING_OFF)) : null);
                        callableStatement.setString(46, params.containsKey(ASSET_TAG) ? getValue(params.get(ASSET_TAG)) : null);
                        callableStatement.setString(47, params.containsKey(COMPUTER_NAME) ? getValue(params.get(COMPUTER_NAME)) : null);
                        callableStatement.setString(48, params.containsKey(SOLUTION_DOCUMENT_ID) ? getValue(params.get(SOLUTION_DOCUMENT_ID)) : null);
                        callableStatement.setString(49, params.containsKey(VENDOR_REF) ? getValue(params.get(VENDOR_REF)) : null);
                        callableStatement.setString(50, params.containsKey(TOTAL_COST) ? getValue(params.get(TOTAL_COST)) : null);
                        callableStatement.setString(51, params.containsKey(Z_APPROVAL_PERSON_GROUP) ? getValue(params.get(Z_APPROVAL_PERSON_GROUP)) : null);
                        callableStatement.setString(52, params.containsKey(Z_APPROVAL_STATUS) ? getValue(params.get(Z_APPROVAL_STATUS)) : null);
                        callableStatement.setString(53, params.containsKey(EVENT_SCHEDULE) ? getValue(params.get(EVENT_SCHEDULE)) : null);
                        callableStatement.setString(54, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(55, params.containsKey(FLR_ACHIEVED) ? getValue(params.get(FLR_ACHIEVED)) : null);
                        callableStatement.setString(56, params.containsKey(DATE_TIME_CLOSED) ? getValue(params.get(DATE_TIME_CLOSED)) : null);
                        callableStatement.setString(57, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(58, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(59, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(60, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(61, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(62, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(63, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(64, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(65, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(66, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(67, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(68, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(69, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(70, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(71, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(72, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(73, params.containsKey(ALERTSTATUS_SK) ? getValue(params.get(ALERTSTATUS_SK)) : null);
                        callableStatement.setString(74, params.containsKey(RKM_REASON) ? getValue(params.get(RKM_REASON)) : null);
                        callableStatement.setString(75, params.containsKey(VERIFIED_INFORMATION) ? getValue(params.get(VERIFIED_INFORMATION)) : null);
                        callableStatement.setString(76, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(77, params.containsKey(ZASSIGNED_GROUP) ? getValue(params.get(ZASSIGNED_GROUP)) : null);
                        callableStatement.setString(78, params.containsKey(ZASSIGN_LOGIN) ? getValue(params.get(ZASSIGN_LOGIN)) : null);
                        callableStatement.setString(79, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(80, params.containsKey(SUPPORT_PERSON) ? getValue(params.get(SUPPORT_PERSON)) : null);
                        callableStatement.setString(81, params.containsKey(ZASSIGN_GROUP_ID) ? getValue(params.get(ZASSIGN_GROUP_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateFrontEndMessages(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20);  // 11 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varFloat = new SqlParameter(Types.FLOAT);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varDateTime); // 5
            paramList.add(varDateTime); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(FrontEndMessage_sk) ? getValue(params.get(FrontEndMessage_sk)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(Object_sk) ? getValue(params.get(Object_sk)) : null);
                        callableStatement.setString(4, params.containsKey(Message) ? getValue(params.get(Message)) : null);
                        callableStatement.setString(5, params.containsKey(Start) ? getDBValidatedValue(params.get(Start), DATATYPE_DATETIME) : null);
                        callableStatement.setString(6, params.containsKey(End) ? getDBValidatedValue(params.get(End), DATATYPE_DATETIME) : null);
                        callableStatement.setString(7, params.containsKey(Approver_sk) ? getDBValidatedValue(params.get(Approver_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(ApproverComments) ? getDBValidatedValue(params.get(ApproverComments), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(Status_sk) ? getValue(params.get(Status_sk)) : null);
                        callableStatement.setString(10, params.containsKey(IsPublished) ? getValue(params.get(IsPublished)) : null);
                        callableStatement.setString(11, params.containsKey(ModifiedBy) ? getDBValidatedValue(params.get(ModifiedBy), DATATYPE_INTEGER) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createFrontEndMessages(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18);  // 10 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(Object_sk) ? getValue(params.get(Object_sk)) : null);
                        callableStatement.setString(3, params.containsKey(Message) ? getValue(params.get(Message)) : null);
                        callableStatement.setString(4, params.containsKey(Start) ? getValue(params.get(Start)) : null);
                        callableStatement.setString(5, params.containsKey(End) ? getValue(params.get(End)) : null);
                        callableStatement.setString(6, params.containsKey(Approver_sk) ? getValue(params.get(Approver_sk)) : null);
                        callableStatement.setString(7, params.containsKey(ApproverComments) ? getValue(params.get(ApproverComments)) : null);
                        callableStatement.setString(8, params.containsKey(Status_sk) ? getValue(params.get(Status_sk)) : null);
                        callableStatement.setString(9, params.containsKey(IsPublished) ? getValue(params.get(IsPublished)) : null);
                        callableStatement.setString(10, params.containsKey(CreatedBy) ? getValue(params.get(CreatedBy)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createSRTReport(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 60);  // 31 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varInt = new SqlParameter(INTEGER);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varDateTime); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varInt); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varDateTime); // 14
            paramList.add(varInt); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TASK_ID) ? getValue(params.get(TASK_ID)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT_REQUEST_ID) ? getValue(params.get(PARENT_REQUEST_ID)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(6, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(7, params.containsKey(TASK) ? getValue(params.get(TASK)) : null);
                        callableStatement.setString(8, params.containsKey(TASK_DETAILS) ? getValue(params.get(TASK_DETAILS)) : null);
                        callableStatement.setString(9, params.containsKey(TASK_SEQUENCE) ? getValue(params.get(TASK_SEQUENCE)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(12, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(13, params.containsKey(APPROVAL) ? getValue(params.get(APPROVAL)) : null);
                        callableStatement.setString(14, params.containsKey(ASSIGNED_ON) ? getValue(params.get(ASSIGNED_ON)) : null);
                        callableStatement.setString(15, params.containsKey(MINUTES) ? getValue(params.get(MINUTES)) : null);
                        callableStatement.setString(16, params.containsKey(zAssignLogin) ? getValue(params.get(zAssignLogin)) : null);
                        callableStatement.setString(17, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(18, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(19, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(20, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(21, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(22, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(23, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(24, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(25, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(26, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(27, params.containsKey(LAST_UPDATED_DATE) ? getValue(params.get(LAST_UPDATED_DATE)) : null);
                        callableStatement.setString(28, params.containsKey(LAST_UPDATE_USER) ? getValue(params.get(LAST_UPDATE_USER)) : null);
                        callableStatement.setString(29, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(30, params.containsKey(FIRSTNAME) ? getValue(params.get(FIRSTNAME)) : null);
                        callableStatement.setString(31, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createConsolidatedList(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 76);  // 39 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varDateTime); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varString); // 35
            paramList.add(varString); // 36
            paramList.add(varString); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RECORD_ENTRY_ID) ? getValue(params.get(RECORD_ENTRY_ID)) : null);
                        callableStatement.setString(2, params.containsKey(REQ_LOGIN_ID) ? getValue(params.get(REQ_LOGIN_ID)) : null);
                        callableStatement.setString(3, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(4, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(5, params.containsKey(CST) ? getValue(params.get(CST)) : null);
                        callableStatement.setString(6, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(7, params.containsKey(APPLICATION) ? getValue(params.get(APPLICATION)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_DATE) ? getValue(params.get(CREATED_DATE)) : null);
                        callableStatement.setString(9, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(10, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(11, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(12, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(13, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(14, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(15, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(16, params.containsKey(STATUS_DISPLAY) ? getValue(params.get(STATUS_DISPLAY)) : null);
                        callableStatement.setString(17, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(18, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(19, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(20, params.containsKey(PARENT_TICKET) ? getValue(params.get(PARENT_TICKET)) : null);
                        callableStatement.setString(21, params.containsKey(TRIAGE_GROUP) ? getValue(params.get(TRIAGE_GROUP)) : null);
                        callableStatement.setString(22, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(23, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(24, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(25, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(26, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(27, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(28, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(29, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(30, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(31, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(32, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(33, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(34, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(35, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(36, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(37, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(38, params.containsKey(ALERTSTATUS_SK) ? getValue(params.get(ALERTSTATUS_SK)) : null);
                        callableStatement.setString(39, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateINCREport(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 190); // 95 paramters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varInt = new SqlParameter(INTEGER);
            SqlParameter varFloat = new SqlParameter(Types.FLOAT);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varDateTime); // 12
            paramList.add(varDateTime); // 13
            paramList.add(varDateTime); // 14
            paramList.add(varDateTime); // 15
            paramList.add(varDateTime); // 16
            paramList.add(varDateTime); // 17
            paramList.add(varString); // 18
            paramList.add(varDateTime); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varInt); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varString); // 35
            paramList.add(varString); // 36
            paramList.add(varString); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39
            paramList.add(varString); // 40
            paramList.add(varString); // 41
            paramList.add(varString); // 42
            paramList.add(varDateTime); // 43
            paramList.add(varDateTime); // 44
            paramList.add(varDateTime); // 45
            paramList.add(varString); // 46
            paramList.add(varString); // 47
            paramList.add(varDateTime); // 48
            paramList.add(varString); // 49
            paramList.add(varString); // 50
            paramList.add(varFloat); // 51
            paramList.add(varDateTime); // 52
            paramList.add(varFloat); // 53
            paramList.add(varFloat); // 54
            paramList.add(varString); // 55
            paramList.add(varString); // 56
            paramList.add(varString); // 57
            paramList.add(varString); // 58
            paramList.add(varString); // 59
            paramList.add(varString); // 60
            paramList.add(varString); // 61
            paramList.add(varString); // 62
            paramList.add(varString); // 63
            paramList.add(varString); // 64
            paramList.add(varString); // 65
            paramList.add(varFloat); // 66
            paramList.add(varString); // 67
            paramList.add(varString); // 68
            paramList.add(varString); // 69
            paramList.add(varString); // 70
            paramList.add(varString); // 71
            paramList.add(varString); // 72
            paramList.add(varString); // 73
            paramList.add(varString); // 74
            paramList.add(varString); // 75
            paramList.add(varString); // 76
            paramList.add(varString); // 77
            paramList.add(varString); // 78
            paramList.add(varString); //79
            paramList.add(varString); //80
            paramList.add(varString); // 81
            paramList.add(varString); // 82
            paramList.add(varString); // 83
            paramList.add(varString); // 84
            paramList.add(varString); // 85
            paramList.add(varString); // 86
            paramList.add(varString); //87
            paramList.add(varString); //88
            paramList.add(varString); //89
            paramList.add(varString); //90
            paramList.add(varString); //91
            paramList.add(varString); //92
            paramList.add(varString); //93
            paramList.add(varString); //94
            paramList.add(varString); //95
            paramList.add(varString); //96

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT) ? getValue(params.get(PARENT)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(NETWORK_LOGIN) ? getValue(params.get(NETWORK_LOGIN)) : null);
                        callableStatement.setString(6, params.containsKey(EMAIL_ADDRESS) ? getValue(params.get(EMAIL_ADDRESS)) : null);
                        callableStatement.setString(7, params.containsKey(LOGIN_ID) ? getValue(params.get(LOGIN_ID)) : null);
                        callableStatement.setString(8, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(9, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(10, params.containsKey(ASSET_TAG) ? getValue(params.get(ASSET_TAG)) : null);
                        callableStatement.setString(11, params.containsKey(COMPUTER_NAME) ? getValue(params.get(COMPUTER_NAME)) : null);
                        callableStatement.setString(12, params.containsKey(FIRST_ASSIGNED_ON) ? getValue(params.get(FIRST_ASSIGNED_ON)) : null);
                        callableStatement.setString(13, params.containsKey(DATE_TIME_ASSIGNED) ? getValue(params.get(DATE_TIME_ASSIGNED)) : null);
                        callableStatement.setString(14, params.containsKey(DATE_TIME_WORK_IN_PROGRESS) ? getValue(params.get(DATE_TIME_WORK_IN_PROGRESS)) : null);
                        callableStatement.setString(15, params.containsKey(FIRST_ACKNOWLEDGE) ? getValue(params.get(FIRST_ACKNOWLEDGE)) : null);
                        callableStatement.setString(16, params.containsKey(DATE_TIME_RESOLVED) ? getValue(params.get(DATE_TIME_RESOLVED)) : null);
                        callableStatement.setString(17, params.containsKey(DATE_TIME_CLOSED) ? getValue(params.get(DATE_TIME_CLOSED)) : null);
                        callableStatement.setString(18, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(19, params.containsKey(LAST_MODIFIED_DATE) ? getValue(params.get(LAST_MODIFIED_DATE)) : null);
                        callableStatement.setString(20, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(21, params.containsKey(ZSUBMITTER_GROUP) ? getValue(params.get(ZSUBMITTER_GROUP)) : null);
                        callableStatement.setString(22, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(23, params.containsKey(ZASSIGNED_GROUP) ? getValue(params.get(ZASSIGNED_GROUP)) : null);
                        callableStatement.setString(24, params.containsKey(ZASSIGN_LOGIN) ? getValue(params.get(ZASSIGN_LOGIN)) : null);
                        callableStatement.setString(25, params.containsKey(ASSIGN_GRP_CHG) ? getValue(params.get(ASSIGN_GRP_CHG)) : null);
                        callableStatement.setString(26, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(27, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(28, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(29, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(30, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(31, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(32, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(33, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(34, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(35, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(36, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(37, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(38, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(39, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(40, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(41, params.containsKey(CASE_TYPE) ? getValue(params.get(CASE_TYPE)) : null);
                        callableStatement.setString(42, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(43, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(44, params.containsKey(DATE_TIME_PENDING_ON) ? getValue(params.get(DATE_TIME_PENDING_ON)) : null);
                        callableStatement.setString(45, params.containsKey(DATE_TIME_PENDING_OFF) ? getValue(params.get(DATE_TIME_PENDING_OFF)) : null);
                        callableStatement.setString(46, params.containsKey(RESOLUTION) ? getValue(params.get(RESOLUTION)) : null);
                        callableStatement.setString(47, params.containsKey(RE_OPENED) ? getValue(params.get(RE_OPENED)) : null);
                        callableStatement.setString(48, params.containsKey(DATE_TIME_REOPENED) ? getValue(params.get(DATE_TIME_REOPENED)) : null);
                        callableStatement.setString(49, params.containsKey(FLR_ACHIEVED) ? getValue(params.get(FLR_ACHIEVED)) : null);
                        callableStatement.setString(50, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(51, params.containsKey(TOTAL_TIME_MIN) ? getValue(params.get(TOTAL_TIME_MIN)) : null);
                        callableStatement.setString(52, params.containsKey(TIME_SPENT_DATE_TIME) ? getValue(params.get(TIME_SPENT_DATE_TIME)) : null);
                        callableStatement.setString(53, params.containsKey(BUS_HOURS_TO_RESOLVE) ? getValue(params.get(BUS_HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(54, params.containsKey(HOURS_TO_RESOLVE) ? getValue(params.get(HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(55, params.containsKey(VERIFIED_INFORMATION) ? getValue(params.get(VERIFIED_INFORMATION)) : null);
                        callableStatement.setString(56, params.containsKey(NO_VERIFY_REASON) ? getValue(params.get(NO_VERIFY_REASON)) : null);
                        callableStatement.setString(57, params.containsKey(ADEQUATE_DETAILS_NO) ? getValue(params.get(ADEQUATE_DETAILS_NO)) : null);
                        callableStatement.setString(58, params.containsKey(ADEQUATE_DETAILS) ? getValue(params.get(ADEQUATE_DETAILS)) : null);
                        callableStatement.setString(59, params.containsKey(ZASSIGNED_TO_WRONG_GROUP) ? getValue(params.get(ZASSIGNED_TO_WRONG_GROUP)) : null);
                        callableStatement.setString(60, params.containsKey(ZASSIGNED_TO_WRONG_GROUP_LOG) ? getValue(params.get(ZASSIGNED_TO_WRONG_GROUP_LOG)) : null);
                        callableStatement.setString(61, params.containsKey(BUT_COULD_HAVE_BEEN_RESOLVED_YES) ? getValue(params.get(BUT_COULD_HAVE_BEEN_RESOLVED_YES)) : null);
                        callableStatement.setString(62, params.containsKey(ZCOULD_RESOLVED_BY_HELPDESK) ? getValue(params.get(ZCOULD_RESOLVED_BY_HELPDESK)) : null);
                        callableStatement.setString(63, params.containsKey(VENDOR_REF) ? getValue(params.get(VENDOR_REF)) : null);
                        callableStatement.setString(64, params.containsKey(SOLUTION_DOCUMENT_ID) ? getValue(params.get(SOLUTION_DOCUMENT_ID)) : null);
                        callableStatement.setString(65, params.containsKey(COST_CENTER) ? getValue(params.get(COST_CENTER)) : null);
                        callableStatement.setString(66, params.containsKey(TOTAL_COST) ? getValue(params.get(TOTAL_COST)) : null);
                        callableStatement.setString(67, params.containsKey(TICKET_UPDATE_TYPE) ? getValue(params.get(TICKET_UPDATE_TYPE)) : null);
                        callableStatement.setString(68, params.containsKey(ACD_CALL) ? getValue(params.get(ACD_CALL)) : null);
                        callableStatement.setString(69, params.containsKey(EVENT_SCHEDULE) ? getValue(params.get(EVENT_SCHEDULE)) : null);
                        callableStatement.setString(70, params.containsKey(ROOT_CAUSE_CATEGORY) ? getValue(params.get(ROOT_CAUSE_CATEGORY)) : null);
                        callableStatement.setString(71, params.containsKey(VOID_USER) ? getValue(params.get(VOID_USER)) : null);
                        callableStatement.setString(72, params.containsKey(VOID_TIME) ? getValue(params.get(VOID_TIME)) : null);
                        callableStatement.setString(73, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(74, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(75, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(76, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(77, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(78, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(79, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(80, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(81, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(82, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(83, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(84, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(85, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(86, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(87, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(88, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(89, params.containsKey(ALERTSTATUS_SK) ? getValue(params.get(ALERTSTATUS_SK)) : null);
                        callableStatement.setString(90, params.containsKey(RKM_REASON) ? getValue(params.get(RKM_REASON)) : null);
                        callableStatement.setString(91, params.containsKey(WORKLOG_UPDATE) ? getValue(params.get(WORKLOG_UPDATE)) : null);
                        callableStatement.setString(92, params.containsKey(PARENT_TICKET) ? getValue(params.get(PARENT_TICKET)) : null);
                        callableStatement.setString(93, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);
                        callableStatement.setString(94, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(95, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(96, params.containsKey(ZASSIGN_GROUP_ID) ? getValue(params.get(ZASSIGN_GROUP_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSRReport(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 188); // 95 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varInt = new SqlParameter(INTEGER);
            SqlParameter varFloat = new SqlParameter(Types.FLOAT);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varDateTime); // 11
            paramList.add(varDateTime); // 12
            paramList.add(varDateTime); // 13
            paramList.add(varDateTime); // 14
            paramList.add(varDateTime); // 15
            paramList.add(varDateTime); // 16
            paramList.add(varString); // 17
            paramList.add(varDateTime); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varInt); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varString); // 35
            paramList.add(varString); // 36
            paramList.add(varString); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39
            paramList.add(varString); // 40
            paramList.add(varDateTime); // 41
            paramList.add(varDateTime); // 42
            paramList.add(varDateTime); // 43
            paramList.add(varString); // 44
            paramList.add(varString); // 45
            paramList.add(varDateTime); // 46
            paramList.add(varString); // 47
            paramList.add(varString); // 48
            paramList.add(varFloat); // 49
            paramList.add(varDateTime); // 50
            paramList.add(varFloat); // 52
            paramList.add(varFloat); // 52
            paramList.add(varString); // 53
            paramList.add(varString); // 54
            paramList.add(varString); // 55
            paramList.add(varString); // 56
            paramList.add(varString); // 57
            paramList.add(varString); // 58
            paramList.add(varString); // 59
            paramList.add(varString); // 60
            paramList.add(varString); // 61
            paramList.add(varString); // 62
            paramList.add(varFloat); // 63
            paramList.add(varString); // 64
            paramList.add(varString); // 65
            paramList.add(varString); // 66
            paramList.add(varString); // 67
            paramList.add(varString); // 68
            paramList.add(varString); // 69
            paramList.add(varInt); // 70
            paramList.add(varString); // 71
            paramList.add(varString); //72
            paramList.add(varString); // 73
            paramList.add(varString); // 74
            paramList.add(varString); // 75
            paramList.add(varString); // 76
            paramList.add(varString); // 77
            paramList.add(varString); // 78
            paramList.add(varString); //79
            paramList.add(varString); //80
            paramList.add(varString); // 81
            paramList.add(varString); // 82
            paramList.add(varString); // 83
            paramList.add(varString); // 84
            paramList.add(varString); // 85
            paramList.add(varString); // 86
            paramList.add(varString); //87
            paramList.add(varString); //88
            paramList.add(varString); //89
            paramList.add(varString); //90
            paramList.add(varString); //91
            paramList.add(varString); //92
            paramList.add(varString); //93
            paramList.add(varString); //94
            paramList.add(varString); //94


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(NETWORK_LOGIN) ? getValue(params.get(NETWORK_LOGIN)) : null);
                        callableStatement.setString(5, params.containsKey(EMAIL_ADDRESS) ? getValue(params.get(EMAIL_ADDRESS)) : null);
                        callableStatement.setString(6, params.containsKey(LOGIN_ID) ? getValue(params.get(LOGIN_ID)) : null);
                        callableStatement.setString(7, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(8, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(9, params.containsKey(ASSET_TAG) ? getValue(params.get(ASSET_TAG)) : null);
                        callableStatement.setString(10, params.containsKey(COMPUTER_NAME) ? getValue(params.get(COMPUTER_NAME)) : null);
                        callableStatement.setString(11, params.containsKey(FIRST_ASSIGNED_ON) ? getValue(params.get(FIRST_ASSIGNED_ON)) : null);
                        callableStatement.setString(12, params.containsKey(DATE_TIME_ASSIGNED) ? getValue(params.get(DATE_TIME_ASSIGNED)) : null);
                        callableStatement.setString(13, params.containsKey(DATE_TIME_WORK_IN_PROGRESS) ? getValue(params.get(DATE_TIME_WORK_IN_PROGRESS)) : null);
                        callableStatement.setString(14, params.containsKey(FIRST_ACKNOWLEDGE) ? getValue(params.get(FIRST_ACKNOWLEDGE)) : null);
                        callableStatement.setString(15, params.containsKey(DATE_TIME_RESOLVED) ? getValue(params.get(DATE_TIME_RESOLVED)) : null);
                        callableStatement.setString(16, params.containsKey(DATE_TIME_CLOSED) ? getValue(params.get(DATE_TIME_CLOSED)) : null);
                        callableStatement.setString(17, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(18, params.containsKey(LAST_MODIFIED_DATE) ? getValue(params.get(LAST_MODIFIED_DATE)) : null);
                        callableStatement.setString(19, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(20, params.containsKey(ZSUBMITTER_GROUP) ? getValue(params.get(ZSUBMITTER_GROUP)) : null);
                        callableStatement.setString(21, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(22, params.containsKey(ZASSIGNED_GROUP) ? getValue(params.get(ZASSIGNED_GROUP)) : null);
                        callableStatement.setString(23, params.containsKey(ZASSIGN_LOGIN) ? getValue(params.get(ZASSIGN_LOGIN)) : null);
                        callableStatement.setString(24, params.containsKey(ASSIGN_GRP_CHG) ? getValue(params.get(ASSIGN_GRP_CHG)) : null);
                        callableStatement.setString(25, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(26, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(27, params.containsKey(SOURCE) ? getValue(params.get(SOURCE)) : null);
                        callableStatement.setString(28, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(29, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(30, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(31, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(32, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(33, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(34, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(35, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(36, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(37, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(38, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(39, params.containsKey(CASE_TYPE) ? getValue(params.get(CASE_TYPE)) : null);
                        callableStatement.setString(40, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(41, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(42, params.containsKey(DATE_TIME_PENDING_ON) ? getValue(params.get(DATE_TIME_PENDING_ON)) : null);
                        callableStatement.setString(43, params.containsKey(DATE_TIME_PENDING_OFF) ? getValue(params.get(DATE_TIME_PENDING_OFF)) : null);
                        callableStatement.setString(44, params.containsKey(RESOLUTION) ? getValue(params.get(RESOLUTION)) : null);
                        callableStatement.setString(45, params.containsKey(RE_OPENED) ? getValue(params.get(RE_OPENED)) : null);
                        callableStatement.setString(46, params.containsKey(DATE_TIME_REOPENED) ? getValue(params.get(DATE_TIME_REOPENED)) : null);
                        callableStatement.setString(47, params.containsKey(FLR_ACHIEVED) ? getValue(params.get(FLR_ACHIEVED)) : null);
                        callableStatement.setString(48, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(49, params.containsKey(TOTAL_TIME_MIN) ? getValue(params.get(TOTAL_TIME_MIN)) : null);
                        callableStatement.setString(50, params.containsKey(TIME_SPENT_DATE_TIME) ? getValue(params.get(TIME_SPENT_DATE_TIME)) : null);
                        callableStatement.setString(51, params.containsKey(BUS_HOURS_TO_RESOLVE) ? getValue(params.get(BUS_HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(52, params.containsKey(HOURS_TO_RESOLVE) ? getValue(params.get(HOURS_TO_RESOLVE)) : null);
                        callableStatement.setString(53, params.containsKey(NO_VERIFY_REASON) ? getValue(params.get(NO_VERIFY_REASON)) : null);
                        callableStatement.setString(54, params.containsKey(ADEQUATE_DETAILS_NO) ? getValue(params.get(ADEQUATE_DETAILS_NO)) : null);
                        callableStatement.setString(55, params.containsKey(ADEQUATE_DETAILS) ? getValue(params.get(ADEQUATE_DETAILS)) : null);
                        callableStatement.setString(56, params.containsKey(ZASSIGNED_TO_WRONG_GROUP) ? getValue(params.get(ZASSIGNED_TO_WRONG_GROUP)) : null);
                        callableStatement.setString(57, params.containsKey(ZASSIGNED_TO_WRONG_GROUP_LOG) ? getValue(params.get(ZASSIGNED_TO_WRONG_GROUP_LOG)) : null);
                        callableStatement.setString(58, params.containsKey(BUT_COULD_HAVE_BEEN_RESOLVED_YES) ? getValue(params.get(BUT_COULD_HAVE_BEEN_RESOLVED_YES)) : null);
                        callableStatement.setString(59, params.containsKey(ZCOULD_RESOLVED_BY_HELPDESK) ? getValue(params.get(ZCOULD_RESOLVED_BY_HELPDESK)) : null);
                        callableStatement.setString(60, params.containsKey(VENDOR_REF) ? getValue(params.get(VENDOR_REF)) : null);
                        callableStatement.setString(61, params.containsKey(SOLUTION_DOCUMENT_ID) ? getValue(params.get(SOLUTION_DOCUMENT_ID)) : null);
                        callableStatement.setString(62, params.containsKey(COST_CENTER) ? getValue(params.get(COST_CENTER)) : null);
                        callableStatement.setString(63, params.containsKey(TOTAL_COST) ? getValue(params.get(TOTAL_COST)) : null);
                        callableStatement.setString(64, params.containsKey(TICKET_UPDATE_TYPE) ? getValue(params.get(TICKET_UPDATE_TYPE)) : null);
                        callableStatement.setString(65, params.containsKey(ACD_CALL) ? getValue(params.get(ACD_CALL)) : null);
                        callableStatement.setString(66, params.containsKey(ZAPPROVAL_PERSON_GROUP) ? getValue(params.get(ZAPPROVAL_PERSON_GROUP)) : null);
                        callableStatement.setString(67, params.containsKey(ZAPPROVAL_STATUS) ? getValue(params.get(ZAPPROVAL_STATUS)) : null);
                        callableStatement.setString(68, params.containsKey(EVENT_SCHEDULE) ? getValue(params.get(EVENT_SCHEDULE)) : null);
                        callableStatement.setString(69, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(70, params.containsKey(USERS) ? getValue(params.get(USERS)) : null);
                        callableStatement.setString(71, params.containsKey(VOID_USER) ? getValue(params.get(VOID_USER)) : null);
                        callableStatement.setString(72, params.containsKey(VOID_TIME) ? getValue(params.get(VOID_TIME)) : null);
                        callableStatement.setString(73, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(74, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(75, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(76, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(77, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(78, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(79, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(80, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(81, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(82, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(83, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(84, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(85, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(86, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(87, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(88, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(89, params.containsKey(ALERTSTATUS_SK) ? getValue(params.get(ALERTSTATUS_SK)) : null);
                        callableStatement.setString(90, params.containsKey(VERIFIED_INFORMATION) ? getValue(params.get(VERIFIED_INFORMATION)) : null);
                        callableStatement.setString(91, params.containsKey(RKM_REASON) ? getValue(params.get(RKM_REASON)) : null);
                        callableStatement.setString(92, params.containsKey(WORKLOG_UPDATE) ? getValue(params.get(WORKLOG_UPDATE)) : null);
                        callableStatement.setString(93, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(94, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(95, params.containsKey(ZASSIGN_GROUP_ID) ? getValue(params.get(ZASSIGN_GROUP_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSRTaskReport(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 62); // 32 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varInt = new SqlParameter(INTEGER);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varDateTime); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varInt); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varDateTime); // 14
            paramList.add(varDateTime); // 15
            paramList.add(varInt); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT_REQUEST_ID) ? getValue(params.get(PARENT_REQUEST_ID)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(4, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(7, params.containsKey(TASK) ? getValue(params.get(TASK)) : null);
                        callableStatement.setString(8, params.containsKey(TASK_DETAILS) ? getValue(params.get(TASK_DETAILS)) : null);
                        callableStatement.setString(9, params.containsKey(TASK_SEQUENCE) ? getValue(params.get(TASK_SEQUENCE)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(12, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(13, params.containsKey(APPROVAL) ? getValue(params.get(APPROVAL)) : null);
                        callableStatement.setString(14, params.containsKey(COMPLETE_DATE_TIME) ? getValue(params.get(COMPLETE_DATE_TIME)) : null);
                        callableStatement.setString(15, params.containsKey(ASSIGNED_ON) ? getValue(params.get(ASSIGNED_ON)) : null);
                        callableStatement.setString(16, params.containsKey(MINUTES) ? getValue(params.get(MINUTES)) : null);
                        callableStatement.setString(17, params.containsKey(zAssignLogin) ? getValue(params.get(zAssignLogin)) : null);
                        callableStatement.setString(18, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(19, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(20, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(21, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(22, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(23, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(24, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(25, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(26, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(27, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(28, params.containsKey(LAST_UPDATED_DATE) ? getValue(params.get(LAST_UPDATED_DATE)) : null);
                        callableStatement.setString(29, params.containsKey(LAST_UPDATE_USER) ? getValue(params.get(LAST_UPDATE_USER)) : null);
                        callableStatement.setString(30, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(31, params.containsKey(FIRSTNAME) ? getValue(params.get(FIRSTNAME)) : null);
                        callableStatement.setString(32, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateConsolidatedList(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 82); // 42 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(RECORD_ENTRY_ID) ? getValue(params.get(RECORD_ENTRY_ID)) : null);
                        callableStatement.setString(2, params.containsKey(REQ_LOGIN_ID) ? getValue(params.get(REQ_LOGIN_ID)) : null);
                        callableStatement.setString(3, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(4, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(5, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(6, params.containsKey(CST) ? getValue(params.get(CST)) : null);
                        callableStatement.setString(7, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(8, params.containsKey(APPLICATION) ? getValue(params.get(APPLICATION)) : null);
                        callableStatement.setString(9, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(10, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(11, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(12, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(13, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(14, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(15, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(16, params.containsKey(STATUS_DISPLAY) ? getValue(params.get(STATUS_DISPLAY)) : null);
                        callableStatement.setString(17, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(18, params.containsKey(SUMMARY) ? getValue(params.get(SUMMARY)) : null);
                        callableStatement.setString(19, params.containsKey(ALERT_STATUS) ? getValue(params.get(ALERT_STATUS)) : null);
                        callableStatement.setString(20, params.containsKey(PENDING_REASON) ? getValue(params.get(PENDING_REASON)) : null);
                        callableStatement.setString(21, params.containsKey(PENDING_TIME) ? getValue(params.get(PENDING_TIME)) : null);
                        callableStatement.setString(22, params.containsKey(PARENT_TICKET) ? getValue(params.get(PARENT_TICKET)) : null);
                        callableStatement.setString(23, params.containsKey(TRIAGE_GROUP) ? getValue(params.get(TRIAGE_GROUP)) : null);
                        callableStatement.setString(24, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(25, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(26, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getValue(params.get(ASSIGNED_INDIVIDUALSK)) : null);
                        callableStatement.setString(27, params.containsKey(RAISED_BY_SK) ? getValue(params.get(RAISED_BY_SK)) : null);
                        callableStatement.setString(28, params.containsKey(RAISED_BY_USERNAME) ? getValue(params.get(RAISED_BY_USERNAME)) : null);
                        callableStatement.setString(29, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(30, params.containsKey(SUBMITTER_SK) ? getValue(params.get(SUBMITTER_SK)) : null);
                        callableStatement.setString(31, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(32, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(33, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(34, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(35, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(36, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(37, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(38, params.containsKey(LAST_UPDATED_USER_NAME) ? getValue(params.get(LAST_UPDATED_USER_NAME)) : null);
                        callableStatement.setString(39, params.containsKey(ASSIGNED_GROUP_SK) ? getValue(params.get(ASSIGNED_GROUP_SK)) : null);
                        callableStatement.setString(40, params.containsKey(ALERTSTATUS_SK) ? getValue(params.get(ALERTSTATUS_SK)) : null);
                        callableStatement.setString(41, params.containsKey(TICKET_TYPE) ? getValue(params.get(TICKET_TYPE)) : null);
                        callableStatement.setString(42, params.containsKey(LAST_UPDATED_DATE) ? getValue(params.get(LAST_UPDATED_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

 /*   public static Comparator<? super Map<String, Object>> returncomparator(String sortfield) {
        return (Comparator<? super Map<String, Object>>) Comparator.comparing((Map<String, String> m) -> m.get(sortfield))
                .thenComparing(m -> m.get(sortfield))
                .thenComparing(m -> m.get(sortfield))
                .thenComparing(m -> m.get(sortfield));

    }

    public static List<Map<String, Object>> sortNDistinct(List<Map<String, Object>> result, String sortfield, String sortorder, String distinct
            , String distinctfield) {
        if (sortfield != NULL && !sortfield.isEmpty()) {
            result = result.stream().sorted(returncomparator(sortfield)).collect(Collectors.toList());

            if (sortorder != NULL && sortorder.equalsIgnoreCase(DESC)) {
                Collections.reverse(result);
            }
            if (distinct != NULL && distinct.equalsIgnoreCase(TRUE)) {
                return distinct(result, distinctfield, distinct);
            }
        }
        return result;
    }*/

    public static List<Map<String, Object>> sortNDistinct(List<Map<String, Object>> result, String sortfield, String sortorder, String distinct
            , String distinctfield) {
        if (sortfield != NULL && !sortfield.isEmpty()) {
            result = result.stream().sorted((o1, o2) -> {
                return Comparator.nullsFirst(String::compareTo).compare((String) o1.get(sortfield), (String) o2.get(sortfield));
            }).collect(Collectors.toList());

            if (sortorder != NULL && sortorder.equalsIgnoreCase(DESC)) {
                Collections.reverse(result);
            }
            if (distinct != NULL && distinct.equalsIgnoreCase(TRUE)) {
                return distinct(result, distinctfield, distinct);
            }
        }
        return result;
    }


   /* public static int comparefields(Map<String, Object> o1, Map<String, Object> o2, String sortfield) {
        if (o1.get(sortfield) == null || o2.get(sortfield) == null) {
            if (o1.get(sortfield) == null && o2.get(sortfield) == null) {
                return o1.get(sortfield).(o2.get(sortfield));
            } else if (o1.get(sortfield) == null) {
                return -1;
            } else if (o2.get(sortfield) == null) {
                return 1;
            }
        } else {
            if (o1.get(sortfield).equals(o2.get(sortfield))) {
                return o1.get(sortfield).compareTo(o1.get(sortfield));
            } else
                return o1.get(sortfield).compareTo(o1.get(sortfield));
        }
        return 0;
    }*/

    public static Map<String, Object> updateSecureAnswers(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(QUESTION_SK) ? getValue(params.get(QUESTION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(PIN) ? getValue(params.get(PIN)) : null);
                        callableStatement.setString(4, params.containsKey(DATE_OF_BIRTH) ? getValue(params.get(DATE_OF_BIRTH)) : null);
                        callableStatement.setString(5, params.containsKey(ANSWER) ? getValue(params.get(ANSWER)) : null);
                        callableStatement.setString(6, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(7, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(8, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(9, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }
            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_SECURE_ANSWERS);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_SECURE_ANSWERS, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateApplication(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(APPLICATION_sk) ? getValue(params.get(APPLICATION_sk)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT_APPLICATION_sk) ? getValue(params.get(PARENT_APPLICATION_sk)) : null);
                        callableStatement.setString(3, params.containsKey(APPLICATION_CODE) ? getValue(params.get(APPLICATION_CODE)) : null);
                        callableStatement.setString(4, params.containsKey(APPLICATION_NAME) ? getValue(params.get(APPLICATION_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(APPLICATION_URL) ? getValue(params.get(APPLICATION_URL)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CSS_CLASS) ? getValue(params.get(CSS_CLASS)) : null);
                        callableStatement.setString(8, params.containsKey(TARGET) ? getValue(params.get(TARGET)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }
            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
               /* String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_SECURE_ANSWERS);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_SECURE_ANSWERS, queryObject.get(updatedKey).toString(),user.getClientInstance()));

                }*/
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccGroupApp(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 9 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT_GROUP_APP_SK) ? getDBValidatedValue(params.get(ACCOUNT_GROUP_APP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getDBValidatedValue(params.get(USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ACC_APPLICATION_sk) ? getDBValidatedValue(params.get(ACC_APPLICATION_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }
            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccApplication(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 26); // 9 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACC_APPLICATION_sk) ? getValue(params.get(ACC_APPLICATION_sk)) : null);
                        callableStatement.setString(2, params.containsKey(APPLICATION_sk) ? getValue(params.get(APPLICATION_sk)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(AUTHTYPE_SK) ? getValue(params.get(AUTHTYPE_SK)) : null);
                        callableStatement.setString(5, params.containsKey(APPLICATION_NAME) ? getValue(params.get(APPLICATION_NAME)) : null);
                        callableStatement.setString(6, params.containsKey(APPLICATION_SUB_URL) ? getValue(params.get(APPLICATION_SUB_URL)) : null);
                        callableStatement.setString(7, params.containsKey(APPLICATION_URL) ? getValue(params.get(APPLICATION_URL)) : null);
                        callableStatement.setString(8, params.containsKey(THUMBNAIL_URL) ? getValue(params.get(THUMBNAIL_URL)) : null);
                        callableStatement.setString(9, params.containsKey(ISSSO) ? getValue(params.get(ISSSO)) : null);
                        callableStatement.setString(10, params.containsKey(CSS_CLASS) ? getValue(params.get(CSS_CLASS)) : null);
                        callableStatement.setString(11, params.containsKey(TARGET) ? getValue(params.get(TARGET)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(SORTORDER) ? getValue(params.get(SORTORDER)) : null);
                        callableStatement.setString(14, params.containsKey(NAVICON) ? getValue(params.get(NAVICON)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }
            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
               /* String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_SECURE_ANSWERS);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_SECURE_ANSWERS, queryObject.get(updatedKey).toString(),user.getClientInstance()));

                }*/
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createResponses(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(RDY_QUERIES_SK) ? getValue(params.get(RDY_QUERIES_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(3, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(4, params.containsKey(RESPONSE) ? getValue(params.get(RESPONSE)) : null);
                        callableStatement.setString(5, params.containsKey(JSON_RESPONSE) ? getValue(params.get(JSON_RESPONSE)) : null);
                        callableStatement.setString(6, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(7, params.containsKey(COMMENTS) ? getValue(params.get(COMMENTS)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateResponses(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(RESPONSE_SK) ? getValue(params.get(RESPONSE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(3, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(4, params.containsKey(RDY_QUERIES_SK) ? getValue(params.get(RDY_QUERIES_SK)) : null);
                        callableStatement.setString(5, params.containsKey(RESPONSE) ? getValue(params.get(RESPONSE)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(JSON_RESPONSE) ? getDBValidatedValue(params.get(JSON_RESPONSE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(COMMENTS) ? getDBValidatedValue(params.get(COMMENTS), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
        Map<Object, Boolean> seen = new ConcurrentHashMap<>();
        return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }

    public static Map<String, Object> createKBArticleLogDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ARTICLE_LOG_TYPE) ? getValue(params.get(ARTICLE_LOG_TYPE)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ARTICLE_METADATA_SK) ? getValue(params.get(ARTICLE_METADATA_SK)) : null);
                        callableStatement.setString(4, params.containsKey(SEARCH_QUERY) ? getValue(params.get(SEARCH_QUERY)) : null);
                        callableStatement.setString(5, params.containsKey(SEARCH_TIME) ? getValue(params.get(SEARCH_TIME)) : null);
                        callableStatement.setString(6, params.containsKey(RESULTS_RETURNED) ? getValue(params.get(RESULTS_RETURNED)) : null);
                        callableStatement.setString(7, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createKBArticleLogDetailsARSystem(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); // 7 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            //SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(LOG_TYPE) ? getValue(params.get(LOG_TYPE)) : null);
                        callableStatement.setString(2, params.containsKey(LOGIN_ID) ? getValue(params.get(LOGIN_ID)) : null);
                        callableStatement.setString(3, params.containsKey(KB_ARTICLE_ID) ? getValue(params.get(KB_ARTICLE_ID)) : null);
                        callableStatement.setString(4, params.containsKey(SEARCH_QUERY) ? getValue(params.get(SEARCH_QUERY)) : null);
                        callableStatement.setString(5, params.containsKey(SEARCH_TIME) ? getValue(params.get(SEARCH_TIME)) : null);
                        callableStatement.setString(6, params.containsKey(RESULTS_RETURNED) ? getValue(params.get(RESULTS_RETURNED)) : null);
                        callableStatement.setString(7, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(8, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(9, params.containsKey(KB_ARTICLE) ? getValue(params.get(KB_ARTICLE)) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_ON) ? getValue(params.get(CREATED_ON)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBArticleLogDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 2); // 2 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ARTICLE_LOG_SK) ? getValue(params.get(ARTICLE_LOG_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBTicketMapping(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(TICKET_MAPPING_SK) ? getValue(params.get(TICKET_MAPPING_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ARTICLE_METADATA_SK) ? getValue(params.get(ARTICLE_METADATA_SK)) : null);
                        callableStatement.setString(3, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(4, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(5, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateHangupsDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 8); // 5 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(HANGUP_SK) ? getValue(params.get(HANGUP_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(4, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }
            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static void syncIndexer(String action, String[] indexername, String[] ticketID, IndexerDomain indexerDomain) {
        RestTemplate restTemplate = new RestTemplate();
        Gson g = gson;
        HttpHeaders headers = new HttpHeaders();
        MultiValueMap body = new LinkedMultiValueMap<String, Object>();
        HttpEntity<MultiValueMap<String, String>> httpEntity;
        String constructurl = "";
        headers.add("atoken", SFInterfaceConstants.getaTokenValue());
        headers.add(CLIENT_INSTANCE, indexerDomain.getClientInstance());
        switch (action) {
            case INDEXER_CREATE_ALL: {
                constructurl += SFInterfaceConstants.getIndexerCreateallUrl();
            }
            break;
            case INDEXER_CREATE: {
                for (String s : Arrays.asList(indexername)) {
                    body.add("indexerName", s);
                }
                constructurl += SFInterfaceConstants.getIndexerCreateUrl();
            }
            break;
            case INDEXER_UPDATE: {
                for (String s : Arrays.asList(indexername)) {
                    body.add("indexerName", s);
                }
                for (String s : Arrays.asList(ticketID)) {
                    body.add("ticketID", s);
                }
                constructurl += SFInterfaceConstants.getIndexerUpdateUrl();
            }
            break;
        }
        SFInterfaceLoggerBase.log(LOGGER, "Indexer Sync Starts:" + action
                + " IndexerName: " + (indexername != null ? String.join(",", indexername) : NA) + " Ticket:" + (ticketID != null ? String.join(",", ticketID) : NA));
        httpEntity = new HttpEntity(body, headers);
        HttpEntity<MultiValueMap<String, String>> finalHttpEntity = httpEntity;
        String finalConstructurl = constructurl;
        if (StringUtils.isNotBlank(SFInterfaceConstants.getIndexerSyncUrl()))
            Arrays.asList(SFInterfaceConstants.getIndexerSyncUrl().split(SEMI_COLON)).parallelStream().forEach(url -> {
                ResponseEntity<String> response = restTemplate.exchange("http://" + url + finalConstructurl, HttpMethod.POST, finalHttpEntity, String.class);
                SFInterfaceLoggerBase.log(LOGGER, "Indexer Sync Response:" + response.getBody().toString());
            });
        SFInterfaceLoggerBase.log(LOGGER, "Indexer Sync Ends:" + action
                + " IndexerName: " + (indexername != null ? String.join(",", indexername) : NA) + " Ticket:" + (ticketID != null ? String.join(",", ticketID) : NA));
    }

    public static Map<String, Object> createHangUpsReporting(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(2, params.containsKey(SUBMITTER_ID) ? getValue(params.get(SUBMITTER_ID)) : null);
                        callableStatement.setString(3, params.containsKey(SUBMITTER_NAME) ? getValue(params.get(SUBMITTER_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(TRIAGE_GROUP) ? getValue(params.get(TRIAGE_GROUP)) : null);
                        callableStatement.setString(6, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createWatchList(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 8); // 5 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_CODE) ? getValue(params.get(BUSINESS_FUNCTION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(WATCHLIST_SK) ? getValue(params.get(WATCHLIST_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(LOGIN_ID) ? getValue(params.get(LOGIN_ID)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> updateSecureAnswers1(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(SECURE_ANSWERS) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(SECURE_ANSWERS_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(SECURE_ANSWERS_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_SECURE_ANSWERS, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static Map<String, Object> createTicketFromRflow(Map<String, Object> ticketFields, String busFunctionCode, String accessToken
            , String refreshToken, String aToken, String user_sk, String endpointName, User user) throws Exception {

        String workflowresturl = SFInterfaceServices.generateWorkflowAPIURL(busFunctionCode) + WF_SUBMIT;

        Map<String, Object> resultMap = new LinkedHashMap<>();

        String resultString = "";

        try {
            Map<String, Object> inputMapToValidateAPI = new LinkedHashMap<>();
            inputMapToValidateAPI.put(REFERENCE_NUMBER, StringUtils.isNotBlank((String) ticketFields.get(TICKET_NUMBER)) ? ticketFields.get(TICKET_NUMBER) : "");
            inputMapToValidateAPI.put(MASTER_ACCOUNT_CODE, ticketFields.get(MASTER_ACCOUNT_CODE));
            inputMapToValidateAPI.put(APPLICATION_CODE, SFInterfaceConstants.getEmail_ticket_applicationcode());

            ticketFields = mapUserDetailstoTicket(ticketFields, user_sk, busFunctionCode, user);
            ticketFields = mapDefaultTicketValue(ticketFields, busFunctionCode, user);

            inputMapToValidateAPI.put(DATA, ticketFields);

            ObjectMapper mapper = new ObjectMapper();
            mapper.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);
            mapper.enable(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS);

            String jsonString = mapper.writeValueAsString(inputMapToValidateAPI);
            RestTemplate restTemplate = new RestTemplate();
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            if (StringUtils.isNotBlank(accessToken) && StringUtils.isNotBlank(refreshToken)) {
                headers.set(ACCESS_TOKEN, accessToken);
                headers.set(REFRESH_TOKEN, refreshToken);
                headers.set(CLIENT_INSTANCE, user.getClientInstance());
            } else {
                headers.set(A_TOKEN, aToken);
                headers.set(CLIENT_INSTANCE, user.getClientInstance());
            }
            SFInterfaceLoggerBase.log(LOGGER, TICKET, endpointName, NA, NA, NA, NA, NA, jsonString);
            HttpEntity<Object> entity = new HttpEntity<Object>(new ObjectMapper().readValue(jsonString, Object.class), headers);
            resultMap = restTemplate.postForObject(workflowresturl, entity, HashMap.class);
        } catch (Exception e) {
            SFInterfaceLoggerBase.log(LOGGER, WF_TICKETINFO_API_ERROR, endpointName, NA, NA, NA, NA, NA, ERROR + COLON + e.getMessage());
            resultMap.put(WF_TICKETINFO_API_ERROR, SFInterfaceServices.ISPExceptionHandler(e, null, endpointName).get(ERROR));
        }
        return resultMap;
    }

    public static Map<String, Object> createTicketFromRflowOfflineTickets(Map<String, Object> ticketFields, String busFunctionCode, String accessToken
            , String refreshToken, String aToken, String user_sk, String endpointName, TicketModel ticketmodel, User user) throws Exception {

        String workflowresturl = SFInterfaceServices.generateWorkflowAPIURL(busFunctionCode) + WF_SUBMIT;

        Map<String, Object> resultMap = new LinkedHashMap<>();

        String resultString = "";

        Map<String, Object> inputMapToValidateAPI = new LinkedHashMap<>();
        inputMapToValidateAPI.put(REFERENCE_NUMBER, StringUtils.isNotBlank((String) ticketFields.get(TICKET_NUMBER)) ? ticketFields.get(TICKET_NUMBER) : "");
        inputMapToValidateAPI.put(MASTER_ACCOUNT_CODE, ticketFields.get(MASTER_ACCOUNT_CODE));
        inputMapToValidateAPI.put(APPLICATION_CODE, SFInterfaceConstants.getOffline_ticket_applicationcode());

        ticketFields = mapUserDetailstoTicketOffline(ticketFields, user_sk, busFunctionCode, ticketmodel, user);
        ticketFields = mapDefaultTicketValueOfflineTicket(ticketFields, busFunctionCode, ticketmodel, user);

        inputMapToValidateAPI.put(DATA, ticketFields);

        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);
        mapper.enable(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS);

        String jsonString = mapper.writeValueAsString(inputMapToValidateAPI);
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        if (StringUtils.isNotBlank(accessToken) && StringUtils.isNotBlank(refreshToken)) {
            headers.set(ACCESS_TOKEN, accessToken);
            headers.set(REFRESH_TOKEN, refreshToken);
            headers.set(CLIENT_INSTANCE, user.getClientInstance());
        } else {
            headers.set(A_TOKEN, aToken);
            headers.set(CLIENT_INSTANCE, user.getClientInstance());
        }
        SFInterfaceLoggerBase.log(LOGGER, TICKET, endpointName, NA, NA, NA, NA, NA, jsonString);
        HttpEntity<Object> entity = new HttpEntity<Object>(new ObjectMapper().readValue(jsonString, Object.class), headers);
        SFInterfaceLoggerBase.log(LOGGER, endpointName, jsonString);
        resultMap = restTemplate.postForObject(workflowresturl, entity, HashMap.class);
        return resultMap;
    }

    public static Map<String, Object> mapUserDetailstoTicket(Map<String, Object> ticketdetails, String user_sk, String businessFunctionCode, User user) throws IOException {
        List<Map<String, Object>> profilerecords = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, "User_sk:" + user_sk, null, null, null, null, null, null, 1, user);
        String emailkey = "", emailvalue = "", summary = "", description = "";
        if (ticketdetails.containsKey("INC_Email_sk")) {
            emailkey = "INC_Email_sk";
            emailvalue = ticketdetails.get("INC_Email_sk").toString();
        } else if (ticketdetails.containsKey("SR_Email_sk")) {
            emailkey = "SR_Email_sk";
            emailvalue = ticketdetails.get("SR_Email_sk").toString();
        } else if (ticketdetails.containsKey("SRT_Email_sk")) {
            emailkey = "SRT_Email_sk";
            emailvalue = ticketdetails.get("SRT_Email_sk").toString();
        }

        summary = (String) ticketdetails.get(SUMMARY);
        description = (String) (((ticketdetails.get(DESCRIPTION) != null) && !ticketdetails.get(DESCRIPTION).toString().isEmpty())
                ? ticketdetails.get(DESCRIPTION) : ticketdetails.get(SUMMARY));

        ticketdetails = SFInterfaceBase.fetchTicketJson(businessFunctionCode);
        Map<String, Object> profile = profilerecords.get(0);
        if (summary != null && !summary.isEmpty())
            ticketdetails.put(SUMMARY, summary);
        if (description != null && !description.isEmpty())
            ticketdetails.put(DESCRIPTION, description);
        ticketdetails.put(ACCOUNT, profile.get(ACCOUNT_SK));
        ticketdetails.put(MASTER_ACCOUNT, profile.get(MASTER_ACCOUNT_SK));
        ticketdetails.put(MASTER_ACCOUNT_CODE, profile.get(MASTER_ACCOUNT));
        ticketdetails.put(SUBMITTER, profile.get(USER_SK));
        ticketdetails.put(RAISED_BY, profile.get(USER_SK));
        if (emailkey != null && !emailkey.isEmpty())
            ticketdetails.put(emailkey, emailvalue);
        //   ticketdetails.put(BUSINESS_PHONE, profile.get(BUSINESS_PHONE));
        ticketdetails.put(BUILDING, profile.get(BUILDING_SK));
        ticketdetails.put(DEPARTMENT, profile.get(DEPARTMENT_SK));
        ticketdetails.put(FLOOR, profile.get(FLOOR_SK));
        ticketdetails.put(BUSINESS_PHONE, profile.get(PHONE_WORK) != null ? profile.get(PHONE_WORK) : ticketdetails.get(BUSINESS_PHONE));
        //  ticketdetails.put(BUSINESS_PHONE, profile.get(PHONE_WORK) != null ? profile.get(PHONE_WORK) : ticketdetails.get(BUSINESS_PHONE));
        return ticketdetails;
    }

    public static Map<String, Object> mapUserDetailstoTicketOffline(Map<String, Object> ticketdetails,
                                                                    String user_sk,
                                                                    String businessFunctionCode,
                                                                    TicketModel ticketmodel
            , User user
    ) throws Exception {
        List<Map<String, Object>> profilerecords = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, "User_sk:" + user_sk, null, null, null, null, null, null, 1, user);
        String emailkey = "", emailvalue = "", summary = "", description = "";
        if (ticketdetails.containsKey("INC_Email_sk")) {
            emailkey = "INC_Email_sk";
            emailvalue = ticketdetails.get("INC_Email_sk").toString();
        } else if (ticketdetails.containsKey("SR_Email_sk")) {
            emailkey = "SR_Email_sk";
            emailvalue = ticketdetails.get("SR_Email_sk").toString();
        } else if (ticketdetails.containsKey("SRT_Email_sk")) {
            emailkey = "SRT_Email_sk";
            emailvalue = ticketdetails.get("SRT_Email_sk").toString();
        }

        summary = ticketmodel.getSummary();
        description = ticketmodel.getDescription();

        ticketdetails = SFInterfaceBase.fetchTicketJson(businessFunctionCode);
        Map<String, Object> profile = profilerecords.get(0);
        if (summary != null && !summary.isEmpty())
            ticketdetails.put(SUMMARY, summary);
        if (description != null && !description.isEmpty())
            ticketdetails.put(DESCRIPTION, description);
        ticketdetails.put(ACCOUNT, profile.get(ACCOUNT_SK));
        ticketdetails.put(MASTER_ACCOUNT, profile.get(MASTER_ACCOUNT_SK));
        ticketdetails.put(MASTER_ACCOUNT_CODE, profile.get(MASTER_ACCOUNT));
        ticketdetails.put(SUBMITTER, profile.get(USER_SK));
        ticketdetails.put(RAISED_BY, profile.get(USER_SK));
        ticketdetails.put(DESCRIPTION, ticketmodel.getDescription());

        //modified specified by user

        profilerecords = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE,
                NETWORK_LOGIN + COLON + ESCAPE_CHARACTER + ticketmodel.getUser().get("username") + ESCAPE_CHARACTER
                        + AND + ACCOUNT + COLON + ESCAPE_CHARACTER + (ticketmodel.getUser().get("account") != null ?
                        ticketmodel.getUser().get("account") : CTS) + ESCAPE_CHARACTER,
                null, new String[]{USER_SK}, null, null, null, null, 1, user);
        if (!profilerecords.isEmpty()) {
            ticketdetails.put(SUBMITTER, profilerecords.get(0).get(USER_SK));
        } else {
            throwException(SUBMITTER + " Not Found!");
        }

        //To get Building_sk,Department_sk,Floor_sk
        List<Map<String, Object>> locationList = new ArrayList<>();
        if (!ticketmodel.getUseDefault().equalsIgnoreCase(TRUE)
                && StringUtils.isNotBlank(ticketmodel.getBuilding())
                && StringUtils.isNotBlank(ticketmodel.getDepartment())) {
            locationList = (List<Map<String, Object>>) fetchWhooshRecords(INDEXERNAME_FETCH_LOCATION
                    , BUILDING + COLON + ESCAPE_CHARACTER + ticketmodel.getBuilding() + ESCAPE_CHARACTER + AND
                            + ACCOUNT + COLON + ESCAPE_CHARACTER + ticketmodel.getClient().getText() + ESCAPE_CHARACTER + AND
                            + DEPARTMENT + COLON + ESCAPE_CHARACTER + ticketmodel.getDepartment() + ESCAPE_CHARACTER + AND
                            + OPEN_BRACKET + FLOOR + COLON + ESCAPE_CHARACTER + ticketmodel.getFloor() + ESCAPE_CHARACTER
                            + OR + FLOOR + COLON + ESCAPE_CHARACTER + NULL_VALUE + ESCAPE_CHARACTER + CLOSE_BRACKET
                    , null
                    , new String[]{BUILDING_SK, DEPARTMENT_SK, FLOOR_SK}, BUILDING, null, TRUE, null, NUM_ONE
                    , Boolean.FALSE, null, NUM_ONE, null, user);
        }
        if (locationList.size() > NUM_ZERO) {//if user entered data is correct
        } else {
            locationList = (List<Map<String, Object>>) fetchWhooshRecords(INDEXERNAME_FETCH_LOCATION
                    , BUILDING_SK + COLON + ESCAPE_CHARACTER + profile.get(BUILDING_SK) + ESCAPE_CHARACTER + AND
                            + ACCOUNT + COLON + ESCAPE_CHARACTER + profile.get(ACCOUNT) + ESCAPE_CHARACTER + AND
                            + DEPARTMENT_SK + COLON + ESCAPE_CHARACTER + profile.get(DEPARTMENT_SK) + ESCAPE_CHARACTER + AND
                            + OPEN_BRACKET + FLOOR_SK + COLON + ESCAPE_CHARACTER + profile.get(FLOOR_SK) + ESCAPE_CHARACTER
                            + OR + FLOOR + COLON + ESCAPE_CHARACTER + NULL_VALUE + ESCAPE_CHARACTER + CLOSE_BRACKET
                    , null
                    , new String[]{BUILDING_SK, DEPARTMENT_SK, FLOOR_SK}, BUILDING, null, TRUE, null, NUM_ONE
                    , Boolean.FALSE, null, NUM_ONE, null, user);


            ticketdetails.put(DESCRIPTION, ticketmodel.getDescription() != null ?
                    (ticketmodel.getDescription() + (ticketmodel.getExtra_description() != null ? (ESCAPE_CHARACTER_NEWLINE + ticketmodel.getExtra_description()) : EMPTY))
                    :
                    (ticketmodel.getExtra_description() != null ? (ESCAPE_CHARACTER_NEWLINE + ticketmodel.getExtra_description()) : EMPTY)
            );

        }

        if (locationList.size() > NUM_ZERO) {
            ticketdetails.put(BUILDING, locationList.get(NUM_ZERO).get(BUILDING_SK));
            ticketdetails.put(DEPARTMENT, locationList.get(NUM_ZERO).get(DEPARTMENT_SK));
            ticketdetails.put(FLOOR, locationList.get(NUM_ZERO).get(FLOOR_SK) != null
                    ? locationList.get(NUM_ZERO).get(FLOOR_SK)
                    :
                    profile.get(FLOOR_SK));
        } else {
            throwException("Building-Department not valid!");
        }


        if (emailkey != null && !emailkey.isEmpty())
            ticketdetails.put(emailkey, emailvalue);

        ticketdetails.put(BUSINESS_PHONE,
                (StringUtils.isNotBlank(ticketmodel.getPhone()) ? ticketmodel.getPhone() : profile.get(PHONE_WORK)));
        ticketdetails.put(BUS_EMAILID,
                (StringUtils.isNotBlank(ticketmodel.getEmail()) ? ticketmodel.getEmail() : profile.get(EMAIL_ADDRESS)));

        return ticketdetails;
    }


    public static Map<String, Object> mapupdateTicketOffline(Map<String, Object> ticketdetails, String businessFunctionCode, TicketModel ticket, User user) throws Exception {

        Map<String, String> businessfuntion = new HashMap<>();
        businessfuntion.put("INCIDENTS", "INC");
        businessfuntion.put("SR", "SR");
        businessfuntion.put("SRT", "SRT");
        List<Map<String, Object>> grouprecords = new ArrayList<>();
        List<Map<String, Object>> assignedrecords = new ArrayList<>();
        List<Map<String, Object>> modifiedrecords = new ArrayList<>();

        //group specified by user
        if (ticket.getAssignedGroup() != null && !ticket.getAssignedGroup().isEmpty()) {
            grouprecords = fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS,
                    GROUP_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedGroup() + ESCAPE_CHARACTER,
                    null, new String[]{ACCOUNT_GROUP_SK, GROUP_CODE}, null, null, null, null, 1, user);
            if (!grouprecords.isEmpty()) {
                ticketdetails.put(ASSIGNED_GROUP, grouprecords.get(0).get(ACCOUNT_GROUP_SK));
                ticketdetails.put(ASSIGNED_GROUP_CODE, grouprecords.get(0).get(GROUP_CODE));
            } else {
                throwException(ASSIGNED_GROUP + " NOT VALID!");
            }
        }

        //assignedindividual specified by user
        if (ticket.getAssignedIndividual() != null && !ticket.getAssignedIndividual().isEmpty()) {
            if (ticket.getAssignedGroup() != null && !ticket.getAssignedGroup().isEmpty()) {
                assignedrecords = fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS,
                        GROUP_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedGroup() + ESCAPE_CHARACTER
                                + AND + FULL_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedIndividual() + ESCAPE_CHARACTER,
                        null, new String[]{USER_SK}, null, null, null, null, 1, user);
                if (!assignedrecords.isEmpty()) {
                    ticketdetails.put(ASSIGNED_INDIVIDUAL, assignedrecords.get(0).get(USER_SK));
                } else {
                    throwException(ASSIGNED_INDIVIDUAL + " Not Found under " + ticket.getAssignedGroup());
                }
            } else {
                throwException(ASSIGNED_GROUP + " IS MANDATORY WHEN UPDATING ASSIGNEDINDIVIDUAL!");
            }
        }

        //modified specified by user
        modifiedrecords = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE,
                NETWORK_LOGIN + COLON + ESCAPE_CHARACTER + ticket.getUser().get("username") + ESCAPE_CHARACTER
                        + AND + ACCOUNT + COLON + ESCAPE_CHARACTER + (ticket.getUser().get("account") != null ? ticket.getUser().get("account") : CTS) + ESCAPE_CHARACTER,
                null, new String[]{USER_SK}, null, null, null, null, 1, user);
        if (!modifiedrecords.isEmpty()) {
            ticketdetails.put(ModifiedBy, modifiedrecords.get(0).get(USER_SK));
        } else {
            throwException(MODIFIED_BY + " IS MANDATORY WHILE UDPATING!");
        }
        //status specified by user
        List<Map<String, Object>> statusrecords = new ArrayList<>();
        if (ticket.getStatus() != null && !ticket.getStatus().

                isEmpty()) {
            statusrecords = fetchWhooshRecords(INDEXERNAME_FETCH_STATUS,
                    ENTITYCODE + COLON + businessfuntion.get(businessFunctionCode) + AND + OPEN_BRACKET + STATUS_CODE + COLON + ticket.getStatus()
                            + OR + STATUS + COLON + ticket.getStatus() + CLOSE_BRACKET,
                    null, null, null, null, null, null, 1, user);
            if (!statusrecords.isEmpty()) {
                ticketdetails.put(STATUS, statusrecords.get(0).get(STATUS_SK));
                ticketdetails.put(STATUS_CODE, statusrecords.get(0).get(STATUS_CODE));
            }
        }

        //priority specified by user
        List<Map<String, Object>> priorityrecords = new ArrayList<>();
        if (ticket.getPriority() != null && !ticket.getPriority().isEmpty()) {
            priorityrecords = fetchWhooshRecords(INDEXERNAME_FETCH_PRIORITY,
                    PRIORITY + COLON + ticket.getPriority() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
            if (!priorityrecords.isEmpty()) {
                ticketdetails.put(PRIORITY, priorityrecords.get(0).get(PRIORITY_SK));
            } else {
                throwException(PRIORITY + " Not Valid!");
            }
        }

        //source specified by user
        List<Map<String, Object>> sourcerecords = new ArrayList<>();
        if (ticket.getSource() != null && !ticket.getSource().

                isEmpty()) {
            sourcerecords = fetchWhooshRecords(INDEXERNAME_FETCH_SOURCE,
                    SOURCE + COLON + ticket.getSource() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }

        //casetype specified by user
        List<Map<String, Object>> casetyperecords = new ArrayList<>();
        if (ticket.getCasetype() != null && !ticket.getCasetype().

                isEmpty()) {
            casetyperecords = fetchWhooshRecords(INDEXERNAME_FETCH_CASETYPE,
                    CASE_TYPE + COLON + ticket.getCasetype() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }
        if (!sourcerecords.isEmpty()) {
            ticketdetails.put(SOURCE, sourcerecords.get(0).get(SOURCE_SK));
        }
        if (!casetyperecords.isEmpty()) {
            ticketdetails.put(CASE_TYPE, casetyperecords.get(0).get(CASE_TYPE_sk));
        }

        if (ticket.getSummary() != null && !ticket.getSummary().isEmpty())
            ticketdetails.put(SUMMARY, ticket.getSummary());

        if (ticket.getAux_contact() != null && !ticket.getAux_contact().isEmpty())
            ticketdetails.put(AUXCONTACT, ticket.getAux_contact());

        if (ticket.getDescription() != null && !ticket.getDescription().isEmpty())
            ticketdetails.put(DESCRIPTION, ticket.getDescription());

        if (ticket.getResolution() != null && !ticket.getResolution().isEmpty())
            ticketdetails.put(RESOLUTION, ticket.getResolution());

        if (ticket.getOffice() != null && !ticket.getOffice().isEmpty())
            ticketdetails.put(OFFICE, ticket.getOffice());

      /*  if (ticket.getEmail() != null && !ticket.getEmail().isEmpty())
            ticketdetails.put(BUS_EMAILID, ticket.getEmail());
*/
        if (ticket.getAssetTag() != null && !ticket.getAssetTag().isEmpty())
            ticketdetails.put(ASSET_TAG, ticket.getAssetTag());

        if (ticket.getComputerName() != null && !ticket.getComputerName().isEmpty())
            ticketdetails.put(COMPUTER_NAME, ticket.getComputerName());

        if (StringUtils.isNotBlank(ticket.getFname())
                || StringUtils.isNotBlank(ticket.getLname())
                || StringUtils.isNotBlank(ticket.getLoginName())
                || StringUtils.isNotBlank(ticket.getBuilding())
                || StringUtils.isNotBlank(ticket.getDepartment())
                || StringUtils.isNotBlank(ticket.getFloor())
                || StringUtils.isNotBlank(ticket.getCategory())
                || StringUtils.isNotBlank(ticket.getType())
                || StringUtils.isNotBlank(ticket.getItem())
                || StringUtils.isNotBlank(ticket.getEmail())
        ) {
            if (StringUtils.isNotBlank(ticket.getWorklog())) {
                ticketdetails.put(WRK_DESCRIPTION, (ticket.getWorklog() + "\n"
                        + (StringUtils.isNotBlank(ticket.getMailbody()) ? ticket.getMailbody() : EMPTY)));
                ticketdetails.put(WORKNOTE_TYPE, "W");
            } else {
                ticketdetails.put(WRK_DESCRIPTION, ticket.getMailbody());
                ticketdetails.put(WORKNOTE_TYPE, "W");
            }
        } else if (StringUtils.isNotBlank(ticket.getWorklog())) {
            ticketdetails.put(WRK_DESCRIPTION, ticket.getWorklog());
            ticketdetails.put(WORKNOTE_TYPE, "W");
        }

      /*  if (ticket.getPhone() != null && !ticket.getPhone().

                isEmpty())
            ticketdetails.put(BUSINESS_PHONE, ticket.getPhone());

        if (ticket.getPager() != null && !ticket.getPager().

                isEmpty())
            ticketdetails.put(PAGER, ticket.getPager());*/

        if (ticket.getCreated() != null && !ticket.getCreated().
                isEmpty())
            ticketdetails.put(ATTRIBUTE_2, ticket.getCreated());

        ticketdetails.put(OFFLINE_UNIQUE_ID, ticket.getGuid());

        return ticketdetails;
    }


    public static Map<String, Object> mapDefaultTicketValue(Map<String, Object> ticketdetails, String businessFunctionCode, User user) throws IOException {

        Map<String, String> businessfuntion = new HashMap<>();
        businessfuntion.put("INCIDENTS", "INC");
        businessfuntion.put("SR", "SR");
        businessfuntion.put("SRT", "SRT");

        Map<String, Object> queuerecords = fetchWhooshRecords(INDEXERNAME_FETCH_QUEUE,
                QUEUE + COLON + ticketdetails.get(QUEUE) + AND + ACCOUNT_SK + COLON + ticketdetails.get(ACCOUNT),
                null, null, null, null, null, null, 1, user).get(0);

        Map<String, Object> priorityrecords = fetchWhooshRecords(INDEXERNAME_FETCH_PRIORITY,
                PRIORITY + COLON + ticketdetails.get(PRIORITY) + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                null, null, null, null, null, null, 1, user).get(0);

        Map<String, Object> sourcerecords = fetchWhooshRecords(INDEXERNAME_FETCH_SOURCE,
                SOURCE + COLON + ticketdetails.get(SOURCE) + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                null, null, null, null, null, null, 1, user).get(0);

        Map<String, Object> casetyperecords = fetchWhooshRecords(INDEXERNAME_FETCH_CASETYPE,
                CASE_TYPE + COLON + ticketdetails.get(CASE_TYPE) + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                null, null, null, null, null, null, 1, user).get(0);

        String[] cti = ticketdetails.get(CTI).toString().split("/");
        Map<String, Object> businessfn = runjdbcQuery(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), "SELECT BusinessFunction_sk,BusinessFunctionCode FROM FDN_BUSINESSFUNCTION WHERE BusinessFunctionCode='" + ticketdetails.get(BUSINESS_FUNCTION) + "'").get(0);
        Map<String, Object> ctirecords = fetchWhooshRecords(INDEXERNAME_FETCH_CTI,
                CATEGORY + COLON + ESCAPE_CHARACTER + cti[0] + ESCAPE_CHARACTER + AND + TYPE + COLON + ESCAPE_CHARACTER + cti[1] + ESCAPE_CHARACTER
                        + AND + ITEM + COLON + ESCAPE_CHARACTER + cti[2] + ESCAPE_CHARACTER + AND + CTI_STATUS + COLON + "\"Active\"" + AND + BUSINESS_FUNCTION_SK + COLON + businessfn.get(BUSINESS_FUNCTION_SK),
                null, null, null, null, null, null, 1, user).get(0);

        Map<String, Object> statusrecords = fetchWhooshRecords(INDEXERNAME_FETCH_STATUS,
                ENTITYCODE + COLON + businessfuntion.get(businessFunctionCode) + AND + STATUS_CODE + COLON + ticketdetails.get(STATUS_CODE),
                null, null, null, null, null, null, 1, user).get(0);

        Map<String, Object> grouprecords = fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS,
                GROUP_NAME + COLON + ESCAPE_CHARACTER + ticketdetails.get(ASSIGNED_GROUP) + ESCAPE_CHARACTER,
                null, null, null, null, null, null, 1, user).get(0);


        Map<String, Object> profile = new HashMap<>();
        ticketdetails.put(QUEUE, queuerecords.get(QUEUE_sk));
        ticketdetails.put(PRIORITY, priorityrecords.get(PRIORITY_SK));
        ticketdetails.put(SOURCE, sourcerecords.get(SOURCE_SK));
        ticketdetails.put(CASE_TYPE, casetyperecords.get(CASE_TYPE_sk));
        ticketdetails.put(CTI, ctirecords.get(CTI_SK));
        ticketdetails.put(ASSIGNED_GROUP, grouprecords.get(ACCOUNT_GROUP_SK));
        ticketdetails.put(TRIAGE_GROUP, grouprecords.get(ACCOUNT_GROUP_SK));
        ticketdetails.put(ASSIGNED_GROUP_CODE, grouprecords.get(GROUP_CODE));
        ticketdetails.put(STATUS, statusrecords.get(STATUS_SK));
        ticketdetails.put(STATUS_CODE, statusrecords.get(STATUS_CODE));
        ticketdetails.put(BUSINESS_FUNCTION, businessfn.get(BUSINESS_FUNCTION_SK));
        return ticketdetails;
    }

    public static Map<String, Object> mapDefaultTicketValueOfflineTicket(Map<String, Object> ticketdetails,
                                                                         String businessFunctionCode,
                                                                         TicketModel ticket,
                                                                         User user) throws Exception {

        Map<String, String> businessfuntion = new HashMap<>();
        businessfuntion.put("INCIDENTS", "INC");
        businessfuntion.put("SR", "SR");
        businessfuntion.put("SRT", "SRT");
        //priority specified by user
        String ticketqueue = (ticket.getQueue() != null && !ticket.getQueue().isEmpty()) ? ticket.getQueue() : ticketdetails.get(QUEUE).toString();
        Map<String, Object> queuerecords = fetchWhooshRecords(INDEXERNAME_FETCH_QUEUE,
                QUEUE + COLON + ticketqueue + AND + ACCOUNT_SK + COLON + ticketdetails.get(ACCOUNT),
                null, null, null, null, null, null, 1, user).get(0);

        //priority specified by user
        List<Map<String, Object>> priorityrecords = new ArrayList<>();
        String priority = (ticket.getPriority() != null && !ticket.getPriority().isEmpty()) ? ticket.getPriority() : ticketdetails.get(PRIORITY).toString();
        if (ticket.getPriority() != null && !ticket.getPriority().isEmpty()) {
            priorityrecords = fetchWhooshRecords(INDEXERNAME_FETCH_PRIORITY,
                    PRIORITY + COLON + ticket.getPriority() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }
        if (priorityrecords.isEmpty()) {
            priorityrecords = fetchWhooshRecords(INDEXERNAME_FETCH_PRIORITY,
                    PRIORITY + COLON + ticketdetails.get(PRIORITY) + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }

        //source specified by user
        List<Map<String, Object>> sourcerecords = new ArrayList<>();
        if (ticket.getSource() != null && !ticket.getSource().isEmpty()) {
            sourcerecords = fetchWhooshRecords(INDEXERNAME_FETCH_SOURCE,
                    SOURCE + COLON + ticket.getSource() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }
        if (sourcerecords.isEmpty()) {
            sourcerecords = fetchWhooshRecords(INDEXERNAME_FETCH_SOURCE,
                    SOURCE + COLON + ticketdetails.get(SOURCE).toString() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }

        //casetype specified by user
        List<Map<String, Object>> casetyperecords = new ArrayList<>();
        if (ticket.getCasetype() != null && !ticket.getCasetype().isEmpty()) {
            casetyperecords = fetchWhooshRecords(INDEXERNAME_FETCH_CASETYPE,
                    CASE_TYPE + COLON + ticket.getCasetype() + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }
        if (casetyperecords.isEmpty()) {
            casetyperecords = fetchWhooshRecords(INDEXERNAME_FETCH_CASETYPE,
                    CASE_TYPE + COLON + ticketdetails.get(CASE_TYPE) + AND + BUSINESS_FUNCTION_CODE + COLON + businessFunctionCode,
                    null, null, null, null, null, null, 1, user);
        }
        Map<String, Object> businessfn = runjdbcQuery(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), "SELECT BusinessFunction_sk,BusinessFunctionCode FROM FDN_BUSINESSFUNCTION WHERE BusinessFunctionCode='" + ticketdetails.get(BUSINESS_FUNCTION) + "'").get(0);

        List<Map<String, Object>> ctiList = new ArrayList<>();
        if (StringUtils.isNotBlank(ticket.getCategory()) || StringUtils.isNotBlank(ticket.getType()) || StringUtils.isNotBlank(ticket.getItem())) {
            ctiList = fetchWhooshRecords(INDEXERNAME_FETCH_CTI,
                    OPEN_BRACKET
                            + ACCOUNT_SK + COLON + ESCAPE_CHARACTER + ticketdetails.get(ACCOUNT) + ESCAPE_CHARACTER
                            + MASTER_ACCOUNT_SK + COLON + ESCAPE_CHARACTER + ticketdetails.get(MASTER_ACCOUNT) + ESCAPE_CHARACTER
                            + CLOSE_BRACKET
                            + CATEGORY + COLON + ESCAPE_CHARACTER + ticket.getCategory() + ESCAPE_CHARACTER
                            + AND + TYPE + COLON + ESCAPE_CHARACTER + ticket.getType() + ESCAPE_CHARACTER
                            + AND + ITEM + COLON + ESCAPE_CHARACTER + ticket.getItem() + ESCAPE_CHARACTER
                            + AND + CTI_STATUS + COLON + "\"Active\""
                            + AND + BUSINESS_FUNCTION_SK + COLON + businessfn.get(BUSINESS_FUNCTION_SK),
                    null, new String[]{CTI_SK, CATEGORY_SK, TYPE_SK, ITEM_SK}, null, null, TRUE, null, 0, false,
                    null, 1, null, user);
            //cti specified by user
        } else {
            String[] cti = ticketdetails.get(CTI).toString().split("/");
            ctiList = fetchWhooshRecords(INDEXERNAME_FETCH_CTI,
                    OPEN_BRACKET
                            + ACCOUNT_SK + COLON + ESCAPE_CHARACTER + ticketdetails.get(ACCOUNT) + ESCAPE_CHARACTER
                            + MASTER_ACCOUNT_SK + COLON + ESCAPE_CHARACTER + ticketdetails.get(MASTER_ACCOUNT) + ESCAPE_CHARACTER
                            + CLOSE_BRACKET + CATEGORY + COLON + ESCAPE_CHARACTER + cti[0] + ESCAPE_CHARACTER + AND + TYPE + COLON + ESCAPE_CHARACTER + cti[1] + ESCAPE_CHARACTER
                            + AND + ITEM + COLON + ESCAPE_CHARACTER + cti[2] + ESCAPE_CHARACTER + AND + CTI_STATUS + COLON + "\"Active\"" + AND + BUSINESS_FUNCTION_SK + COLON + businessfn.get(BUSINESS_FUNCTION_SK),
                    null, new String[]{CTI_SK, CATEGORY_SK, TYPE_SK, ITEM_SK}, null, null, null, null, 1, user);
        }
        if (ctiList.size() > NUM_ZERO) {
            ticketdetails.put(CTI, ctiList.get(0).get(CTI_SK));
            ticketdetails.put(CATEGORY_SK, ctiList.get(0).get(CATEGORY_SK));
            ticketdetails.put(TYPE_SK, ctiList.get(0).get(TYPE_SK));
            ticketdetails.put(ITEM_SK, ctiList.get(0).get(ITEM_SK));
        } else {
            throwException("Exception occured CTI not Valid!");
        }
        //status specified by user
        String status = (ticket.getStatus() != null && !ticket.getStatus().isEmpty()) ? ticket.getStatus() : ticketdetails.get(STATUS_CODE).toString();
        Map<String, Object> statusrecords = fetchWhooshRecords(INDEXERNAME_FETCH_STATUS,
                ENTITYCODE + COLON + businessfuntion.get(businessFunctionCode) + AND + OPEN_BRACKET + STATUS_CODE + COLON + status
                        + OR + STATUS + COLON + status + CLOSE_BRACKET,
                null, null, null, null, null, null, 1, user).get(0);
        List<String> statuscode = new ArrayList<>();
        statuscode.add("R");
        statuscode.add("C");
        statuscode.add("V");
        statuscode.add("ACK");

        List<Map<String, Object>> grouprecords = new ArrayList<>();
        //group specified by user
        if (StringUtils.isBlank(ticket.getAssignedGroup()) || ticket.getAssignedGroup().equalsIgnoreCase(CTS_1ST_LEVEL)) {
            ticket.setAssignedGroup(CTS_1ST_LEVEL);
            String groupname = ticket.getAssignedGroup();
            grouprecords = fetchWhooshRecords(INDEXERNAME_FETCH_MANAGE_ACCOUNT_GROUP,
                    GROUP_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedGroup() + ESCAPE_CHARACTER,
                    null, null, null, null, null, null, 1, user);
        } else {
            throwException("Assigned Group specified cannot be other than 1'st LEVEL");
        }
        //assignedindividual
        if (statuscode.contains(statusrecords.get(STATUS_CODE).toString())) {//assignedindividual is mandatory if status is in above list
            List<Map<String, Object>> assignedindividual = new ArrayList<>();


            if (StringUtils.isNotBlank(ticket.getAssignedIndividual())) {//assignedindividual specified by user
                assignedindividual = fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS,
                        GROUP_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedGroup() + ESCAPE_CHARACTER
                                + AND + FULL_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedIndividual() + ESCAPE_CHARACTER,
                        null, new String[]{USER_SK}, null, null, null, null, 1, user);
                if (assignedindividual.isEmpty()) {
                    throwException(ASSIGNED_INDIVIDUAL + "Not Valid!");
                } else {
                    ticketdetails.put(ASSIGNED_INDIVIDUAL, assignedindividual.get(0).get(USER_SK));
                }
            } else {//else check for submitter in group
                assignedindividual = fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS,
                        GROUP_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedGroup() + ESCAPE_CHARACTER
                                + AND + USER_SK + COLON + ESCAPE_CHARACTER + ticketdetails.get(SUBMITTER) + ESCAPE_CHARACTER,
                        null, new String[]{USER_SK}, null, null, null, null, 1, user);

                if (!assignedindividual.isEmpty()) {
                    ticketdetails.put(ASSIGNED_INDIVIDUAL, ticketdetails.get(SUBMITTER));
                } else {//check for TRIAGE USER PROFILE EXIST
                    assignedindividual = fetchWhooshRecords(
                            INDEXERNAME_FETCH_PROFILE,
                            FULL_NAME + COLON + ESCAPE_CHARACTER + TRIAGE_FULL_NAME + ESCAPE_CHARACTER +
                                    AND + ACCOUNT + COLON + CTS,
                            null, new String[]{USER_SK}, null, null, null, null, 1, user);
                    if (!assignedindividual.isEmpty()) {
                        ticketdetails.put(ASSIGNED_INDIVIDUAL, assignedindividual.get(0).get(USER_SK));
                    } else {
                        throwException(ASSIGNED_INDIVIDUAL + "Not Found!");
                    }
                }
            }
        } else {
            List<Map<String, Object>> assignedrecords = new ArrayList<>();
            if (StringUtils.isNotBlank(ticket.getAssignedIndividual())) {
                assignedrecords = fetchWhooshRecords(INDEXERNAME_FETCH_USERGROUPS,
                        GROUP_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedGroup() + ESCAPE_CHARACTER
                                + AND + FULL_NAME + COLON + ESCAPE_CHARACTER + ticket.getAssignedIndividual() + ESCAPE_CHARACTER,
                        null, new String[]{USER_SK}, null, null, null, null, 1, user);
                if (!assignedrecords.isEmpty()) {
                    ticketdetails.put(ASSIGNED_INDIVIDUAL, assignedrecords.get(0).get(USER_SK));
                } else {
                    throwException(ASSIGNED_INDIVIDUAL + "Not Found!");
                }
            }
        }

        if (ticket.getOffice() != null && !ticket.getOffice().isEmpty())
            ticketdetails.put(OFFICE, ticket.getOffice());

        if (ticket.getAssetTag() != null && !ticket.getAssetTag().isEmpty())
            ticketdetails.put(ASSET_TAG, ticket.getAssetTag());

        if (ticket.getComputerName() != null && !ticket.getComputerName().isEmpty())
            ticketdetails.put(COMPUTER_NAME, ticket.getComputerName());

        Map<String, Object> profile = new HashMap<>();
        ticketdetails.put(QUEUE, queuerecords.get(QUEUE_sk));
        ticketdetails.put(PRIORITY, priorityrecords.get(0).get(PRIORITY_SK));
        ticketdetails.put(SOURCE, sourcerecords.get(0).get(SOURCE_SK));
        ticketdetails.put(CASE_TYPE, casetyperecords.get(0).get(CASE_TYPE_sk));
        ticketdetails.put(AUXCONTACT, ticket.getAux_contact());
        ticketdetails.remove(TRIAGE_GROUP);
        // ticketdetails.put(TRIAGE_GROUP, grouprecords.get(ACCOUNT_GROUP_SK));
        ticketdetails.put(ASSIGNED_GROUP, grouprecords.get(0).get(ACCOUNT_GROUP_SK));
        ticketdetails.put(ASSIGNED_GROUP_CODE, grouprecords.get(0).get(GROUP_CODE));
        ticketdetails.put(STATUS, statusrecords.get(STATUS_SK));
        ticketdetails.put(STATUS_CODE, statusrecords.get(STATUS_CODE));
        ticketdetails.put(BUSINESS_FUNCTION, businessfn.get(BUSINESS_FUNCTION_SK));
        ticketdetails.put(OFFLINE_UNIQUE_ID, ticket.getGuid());

        if (ticket.getPager() != null && !ticket.getPager().isEmpty())
            ticketdetails.put(PAGER, ticket.getPager());
        if (ticket.getCreated() != null && !ticket.getCreated().isEmpty())
            ticketdetails.put(ATTRIBUTE_2, ticket.getCreated());
        if (ticket.getResolution() != null && !ticket.getResolution().isEmpty())
            ticketdetails.put(RESOLUTION, ticket.getResolution());
        return ticketdetails;
    }

    public static <T> Set<T> convertArrayToSet(T array[]) {
        // Create the Set by passing the Array
        // as parameter in the constructor
        Set<T> set = new HashSet<>(Arrays.asList(array));

        // Return the converted Set
        return set;
    }

    public static Map<String, Object> updateBuilding(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 28); //15 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUILDING_CODE) ? getDBValidatedValue(params.get(BUILDING_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(BUILDING) ? getDBValidatedValue(params.get(BUILDING), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(ADDRESS_LINE_1) ? getDBValidatedValue(params.get(ADDRESS_LINE_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(ADDRESS_LINE_2) ? getDBValidatedValue(params.get(ADDRESS_LINE_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(COUNTRY_SK) ? getDBValidatedValue(params.get(COUNTRY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(STATE_SK) ? getDBValidatedValue(params.get(STATE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(CITY_SK) ? getDBValidatedValue(params.get(CITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(ZIP_CODE) ? getDBValidatedValue(params.get(ZIP_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(PHONE) ? getDBValidatedValue(params.get(PHONE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(NOTES) ? getDBValidatedValue(params.get(NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(15, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_BUILDING);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_BUILDING, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createProfile(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 146); //74 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30
            paramList.add(varString); //31
            paramList.add(varString); //32
            paramList.add(varString); //33
            paramList.add(varString); //34
            paramList.add(varString); //35
            paramList.add(varString); //36
            paramList.add(varString); //37
            paramList.add(varString); //38
            paramList.add(varString); //39
            paramList.add(varString); //40
            paramList.add(varString); //41
            paramList.add(varString); //42
            paramList.add(varString); //43
            paramList.add(varString); //44
            paramList.add(varString); //45
            paramList.add(varString); //46
            paramList.add(varString); //47
            paramList.add(varString); //48
            paramList.add(varString); //49
            paramList.add(varString); //50
            paramList.add(varString); //51
            paramList.add(varString); //52
            paramList.add(varString); //53
            paramList.add(varString); //54
            paramList.add(varString); //55
            paramList.add(varString); //56
            paramList.add(varString); //57
            paramList.add(varString); //58
            paramList.add(varString); //59
            paramList.add(varString); //60
            paramList.add(varString); //61
            paramList.add(varString); //62
            paramList.add(varString); //63
            paramList.add(varString); //64
            paramList.add(varString); //65
            paramList.add(varString); //66
            paramList.add(varString); //67
            paramList.add(varString); //68
            paramList.add(varString); //69
            paramList.add(varString); //70
            paramList.add(varString); //71
            paramList.add(varString); //72
            paramList.add(varString); //73
            paramList.add(varString); //74

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FIRSTNAME) ? getValue(params.get(FIRSTNAME)) : null);
                        callableStatement.setString(2, params.containsKey(MIDDLE_INIT) ? getValue(params.get(MIDDLE_INIT)) : null);
                        callableStatement.setString(3, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);
                        callableStatement.setString(4, params.containsKey(FULL_NAME) ? getValue(params.get(FULL_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(EMPLOYEE_NUMBER) ? getValue(params.get(EMPLOYEE_NUMBER)) : null);
                        callableStatement.setString(6, params.containsKey(BUS_EMAILID) ? getValue(params.get(BUS_EMAILID)) : null);
                        callableStatement.setString(7, params.containsKey(REFID_3) ? getValue(params.get(REFID_3)) : null);
                        callableStatement.setString(8, params.containsKey(REFID_4) ? getValue(params.get(REFID_4)) : null);
                        callableStatement.setString(9, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(10, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(11, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(12, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(13, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(14, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(15, params.containsKey(PAGER_ALPHA) ? getValue(params.get(PAGER_ALPHA)) : null);
                        callableStatement.setString(16, params.containsKey(PAGER_NUMERIC) ? getValue(params.get(PAGER_NUMERIC)) : null);
                        callableStatement.setString(17, params.containsKey(PHONE_CELL) ? getValue(params.get(PHONE_CELL)) : null);
                        callableStatement.setString(18, params.containsKey(PHONE_HOME) ? getValue(params.get(PHONE_HOME)) : null);
                        callableStatement.setString(19, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(20, params.containsKey(PHONE_EXTN) ? getValue(params.get(PHONE_EXTN)) : null);
                        callableStatement.setString(21, params.containsKey(FAX) ? getValue(params.get(FAX)) : null);
                        callableStatement.setString(22, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(23, params.containsKey(SUPERVISOR_LOGIN) ? getValue(params.get(SUPERVISOR_LOGIN)) : null);
                        callableStatement.setString(24, params.containsKey(SUPERVISOR_NAME) ? getValue(params.get(SUPERVISOR_NAME)) : null);
                        callableStatement.setString(25, params.containsKey(IS_SUPPORT_PERSON) ? getValue(params.get(IS_SUPPORT_PERSON)) : null);
                        callableStatement.setString(26, params.containsKey(COST_CODE) ? getValue(params.get(COST_CODE)) : null);
                        callableStatement.setString(27, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(28, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(29, params.containsKey(NOTIFY_METHOD) ? getValue(params.get(NOTIFY_METHOD)) : null);
                        callableStatement.setString(30, params.containsKey(CST) ? getValue(params.get(CST)) : null);
                        callableStatement.setString(31, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(32, params.containsKey(ROLE) ? getValue(params.get(ROLE)) : null);
                        callableStatement.setString(33, params.containsKey(ROLE_DESC) ? getValue(params.get(ROLE_DESC)) : null);
                        callableStatement.setString(34, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(35, params.containsKey(CLIENT_NOTES) ? getValue(params.get(CLIENT_NOTES)) : null);
                        callableStatement.setString(36, params.containsKey(AD_COMPANY) ? getValue(params.get(AD_COMPANY)) : null);
                        callableStatement.setString(37, params.containsKey(AD_DEPARTMENT) ? getValue(params.get(AD_DEPARTMENT)) : null);
                        callableStatement.setString(38, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(39, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(40, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(41, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(42, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(43, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(44, params.containsKey(PER_EMAIL_ID) ? getValue(params.get(PER_EMAIL_ID)) : null);
                        callableStatement.setString(45, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(46, params.containsKey(GUID) ? getValue(params.get(GUID)) : null);
                        callableStatement.setString(47, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(48, params.containsKey(PAGER_PIN) ? getValue(params.get(PAGER_PIN)) : null);
                        callableStatement.setString(49, params.containsKey(CLIENT_NOTE_EXPIRATION_DATE) ? getValue(params.get(CLIENT_NOTE_EXPIRATION_DATE)) : null);
                        callableStatement.setString(50, params.containsKey(PEOPLE_SOFT_EMP_ID) ? getValue(params.get(PEOPLE_SOFT_EMP_ID)) : null);
                        callableStatement.setString(51, params.containsKey(COMPANY_CODE) ? getValue(params.get(COMPANY_CODE)) : null);
                        callableStatement.setString(52, params.containsKey(SSP_PREFERED_CONTACT_METHOD) ? getValue(params.get(SSP_PREFERED_CONTACT_METHOD)) : null);
                        callableStatement.setString(53, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(54, params.containsKey(QUEUE_sk) ? getValue(params.get(QUEUE_sk)) : null);
                        callableStatement.setString(55, params.containsKey(DESIGNATION_SK) ? getValue(params.get(DESIGNATION_SK)) : null);
                        callableStatement.setString(56, params.containsKey(TITLE_SK) ? getValue(params.get(TITLE_SK)) : null);
                        callableStatement.setString(57, params.containsKey(IS_SPECIAL_NOTIFICATION) ? getValue(params.get(IS_SPECIAL_NOTIFICATION)) : null);
                        callableStatement.setString(58, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(59, params.containsKey(CONTACT_TYPE_SK) ? getValue(params.get(CONTACT_TYPE_SK)) : null);
                        callableStatement.setString(60, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(61, params.containsKey(IS_AUTOMATED_USER) ? getValue(params.get(IS_AUTOMATED_USER)) : null);
                        callableStatement.setString(62, params.containsKey(RETURN_ON) ? getValue(params.get(RETURN_ON)) : null);
                        callableStatement.setString(63, params.containsKey(USERTYPE_SK) ? getValue(params.get(USERTYPE_SK)) : null);
                        callableStatement.setString(64, params.containsKey(PASSWORD) ? getValue(params.get(PASSWORD)) : null);
                        callableStatement.setString(65, params.containsKey(AD_PASSWORD) ? getValue(params.get(AD_PASSWORD)) : null);
                        callableStatement.setString(66, params.containsKey(NETWORK_LOGIN) ? getValue(params.get(NETWORK_LOGIN)) : null);
                        callableStatement.setString(67, params.containsKey(BUILDING_SK) ? getValue(params.get(BUILDING_SK)) : null);
                        callableStatement.setString(68, params.containsKey(BUS_ORG_SK) ? getValue(params.get(BUS_ORG_SK)) : null);
                        callableStatement.setString(69, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(70, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(71, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(72, params.containsKey(USER_POSITION_STATUS_SK) ? getValue(params.get(USER_POSITION_STATUS_SK)) : null);
                        callableStatement.setString(73, params.containsKey(IS_PRIMARY_LOCATION) ? getValue(params.get(IS_PRIMARY_LOCATION)) : null);
                        callableStatement.setString(74, params.containsKey(CLIENT_EXECUTIVE) ? getValue(params.get(CLIENT_EXECUTIVE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(PEOPLE_INFO_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_PROFILE, queryObject.get(PEOPLE_INFO_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDepartment(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 28); //12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(DEPARTMENT_SK) ? getValue(params.get(DEPARTMENT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(DEPARTMENT_CODE) ? getDBValidatedValue(params.get(DEPARTMENT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(DEPARTMENT) ? getDBValidatedValue(params.get(DEPARTMENT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(BUILDING_SK) ? getDBValidatedValue(params.get(BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(BUS_ORG_SK) ? getDBValidatedValue(params.get(BUS_ORG_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(Approver_sk) ? getDBValidatedValue(params.get(Approver_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(REQUESTED_BY) ? getDBValidatedValue(params.get(REQUESTED_BY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(LOCATION_NOTE) ? getDBValidatedValue(params.get(LOCATION_NOTE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(INVALID_DEPT_FLAG) ? getDBValidatedValue(params.get(INVALID_DEPT_FLAG), DATATYPE_BIT) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(IS_DEFAULT) ? getDBValidatedValue(params.get(IS_DEFAULT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_DEPARTMENT);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_DEPARTMENT, queryObject.get(updatedKey).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateFloor(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); //7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FLOOR_SK) ? getValue(params.get(FLOOR_SK)) : null);
                        callableStatement.setString(2, params.containsKey(FLOOR_CODE) ? getDBValidatedValue(params.get(FLOOR_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(FLOOR) ? getDBValidatedValue(params.get(FLOOR), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(BUILDING_SK) ? getDBValidatedValue(params.get(BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);

                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_FLOOR);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_FLOOR, queryObject.get(updatedKey).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSuite(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); //8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SUITE_SK) ? getValue(params.get(SUITE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SUITE_CODE) ? getDBValidatedValue(params.get(SUITE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(SUITE) ? getDBValidatedValue(params.get(SUITE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(BUILDING_SK) ? getDBValidatedValue(params.get(BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(FLOOR_SK) ? getDBValidatedValue(params.get(FLOOR_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);

                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_SUITE);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_SUITE, queryObject.get(updatedKey).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccount(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); //10 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT_ACCOUNT_SK) ? getDBValidatedValue(params.get(PARENT_ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_CODE) ? getValue(params.get(ACCOUNT_CODE)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_NAME) ? getValue(params.get(ACCOUNT_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(SESSION_EXPIRY) ? getDBValidatedValue(params.get(SESSION_EXPIRY), DATATYPE_BIGINT) : null);
                        callableStatement.setString(6, params.containsKey(URL_CODE) ? getDBValidatedValue(params.get(URL_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(ACCOUNT_TYPE_SK) ? getDBValidatedValue(params.get(ACCOUNT_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(10, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_ACCOUNT);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_ACCOUNT, queryObject.get(updatedKey).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateGroup(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); //6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(GROUP_SK) ? getValue(params.get(GROUP_SK)) : null);
                        callableStatement.setString(2, params.containsKey(GROUP_CODE) ? getDBValidatedValue(params.get(GROUP_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(GROUP_NAME) ? getDBValidatedValue(params.get(GROUP_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(LONG_GROUP_NAME) ? getDBValidatedValue(params.get(LONG_GROUP_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getDBValidatedValue(params.get(STATUS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccountGroup(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20); //11 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(GROUP_SK) ? getDBValidatedValue(params.get(GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getDBValidatedValue(params.get(STATUS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(IS_NOTIFICATION_NEEDED) ? getDBValidatedValue(params.get(IS_NOTIFICATION_NEEDED), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(NOTIFY_ADDRESS) ? getDBValidatedValue(params.get(NOTIFY_ADDRESS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(GROUP_TYPE_SK) ? getDBValidatedValue(params.get(GROUP_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(IS_TIME_SPENT_REQUIRED) ? getDBValidatedValue(params.get(IS_TIME_SPENT_REQUIRED), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(NOTIFY_REASSIGN) ? getDBValidatedValue(params.get(NOTIFY_REASSIGN), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(SIZE) ? getDBValidatedValue(params.get(SIZE), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_MANAGE_ACCOUNT_GROUP);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_MANAGE_ACCOUNT_GROUP, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCategory(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); //8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CATEGORY_SK) ? getValue(params.get(CATEGORY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CATEGORY_CODE) ? getDBValidatedValue(params.get(CATEGORY_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(PARENT_CATEGORY_SK) ? getDBValidatedValue(params.get(PARENT_CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CATEGORY) ? getDBValidatedValue(params.get(CATEGORY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateType(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); //7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TYPE_SK) ? getValue(params.get(TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TYPE_CODE) ? getDBValidatedValue(params.get(TYPE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(TYPE) ? getDBValidatedValue(params.get(TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateItem(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); //7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ITEM_SK) ? getValue(params.get(ITEM_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ITEM_CODE) ? getDBValidatedValue(params.get(ITEM_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ITEM) ? getDBValidatedValue(params.get(ITEM), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCTI(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); //12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CTI_CODE) ? getDBValidatedValue(params.get(CTI_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(CATEGORY_SK) ? getDBValidatedValue(params.get(CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(TYPE_SK) ? getDBValidatedValue(params.get(TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ITEM_SK) ? getDBValidatedValue(params.get(ITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(COMMENTS) ? getDBValidatedValue(params.get(COMMENTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(PRIORITY_SK) ? getDBValidatedValue(params.get(PRIORITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(FLR_POSSIBLE) ? getDBValidatedValue(params.get(FLR_POSSIBLE), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_CTI);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CTI, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> UpdatePendingReasons(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); //10 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(PENDING_REASON_SK) ? getValue(params.get(PENDING_REASON_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PENDING_REASON_CODE) ? getDBValidatedValue(params.get(PENDING_REASON_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(PENDING_REASON) ? getDBValidatedValue(params.get(PENDING_REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(PAUSE_SLA) ? getDBValidatedValue(params.get(PAUSE_SLA), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(MAIL_TEMPLATE_SK) ? getDBValidatedValue(params.get(MAIL_TEMPLATE_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_PENDING_REASON);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_PENDING_REASON, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> UpdateDesignation(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); //6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(DESIGNATION_SK) ? getValue(params.get(DESIGNATION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(DESIGNATION_CODE) ? getDBValidatedValue(params.get(DESIGNATION_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(DESIGNATION) ? getDBValidatedValue(params.get(DESIGNATION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_DESIGNATION);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_DESIGNATION, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createChangeRequest(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 124); //63 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30
            paramList.add(varString); //31
            paramList.add(varString); //32
            paramList.add(varString); //33
            paramList.add(varString); //34
            paramList.add(varString); //35
            paramList.add(varString); //36
            paramList.add(varString); //37
            paramList.add(varString); //38
            paramList.add(varString); //39
            paramList.add(varString); //40
            paramList.add(varString); //41
            paramList.add(varString); //42
            paramList.add(varString); //43
            paramList.add(varString); //44
            paramList.add(varString); //45
            paramList.add(varString); //46
            paramList.add(varString); //47
            paramList.add(varString); //48
            paramList.add(varString); //49
            paramList.add(varString); //50
            paramList.add(varString); //51
            paramList.add(varString); //52
            paramList.add(varString); //53
            paramList.add(varString); //54
            paramList.add(varString); //55
            paramList.add(varString); //56
            paramList.add(varString); //57
            paramList.add(varString); //58
            paramList.add(varString); //59
            paramList.add(varString); //60
            paramList.add(varString); //61
            paramList.add(varString); //62
            paramList.add(varString); //62

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(PARENT_SK) ? getValue(params.get(PARENT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(REQUESTER_SK) ? getValue(params.get(REQUESTER_SK)) : null);
                        callableStatement.setString(5, params.containsKey(REQUESTERGROUP_SK) ? getValue(params.get(REQUESTERGROUP_SK)) : null);
                        callableStatement.setString(6, params.containsKey(RISK_LEVEL_SK) ? getValue(params.get(RISK_LEVEL_SK)) : null);
                        callableStatement.setString(7, params.containsKey(REQUESTED_ON) ? getValue(params.get(REQUESTED_ON)) : null);
                        callableStatement.setString(8, params.containsKey(CHANGE_REASON_SK) ? getValue(params.get(CHANGE_REASON_SK)) : null);
                        callableStatement.setString(9, params.containsKey(PLATFORM_SK) ? getValue(params.get(PLATFORM_SK)) : null);
                        callableStatement.setString(10, params.containsKey(CR_CATEGORY_SK) ? getValue(params.get(CR_CATEGORY_SK)) : null);
                        callableStatement.setString(11, params.containsKey(CR_SYSTEM_SK) ? getValue(params.get(CR_SYSTEM_SK)) : null);
                        callableStatement.setString(12, params.containsKey(CHANGE_TYPE_SK) ? getValue(params.get(CHANGE_TYPE_SK)) : null);
                        callableStatement.setString(13, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(14, params.containsKey(CAB_MEMEBER_SK) ? getValue(params.get(CAB_MEMEBER_SK)) : null);
                        callableStatement.setString(15, params.containsKey(SCHEDULED_ON) ? getValue(params.get(SCHEDULED_ON)) : null);
                        callableStatement.setString(16, params.containsKey(ESTIMATED_DOWN_TIME) ? getValue(params.get(ESTIMATED_DOWN_TIME)) : null);
                        callableStatement.setString(17, params.containsKey(ACTUAL_DOWNTIME) ? getValue(params.get(ACTUAL_DOWNTIME)) : null);
                        callableStatement.setString(18, params.containsKey(IMPLEMENTATION_STATUS_SK) ? getValue(params.get(IMPLEMENTATION_STATUS_SK)) : null);
                        callableStatement.setString(19, params.containsKey(RESULTS) ? getValue(params.get(RESULTS)) : null);
                        callableStatement.setString(20, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(21, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(22, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(23, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(24, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(25, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(26, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(27, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(28, params.containsKey(ATTRIBUTE_8) ? getValue(params.get(ATTRIBUTE_8)) : null);
                        callableStatement.setString(29, params.containsKey(ATTRIBUTE_9) ? getValue(params.get(ATTRIBUTE_9)) : null);
                        callableStatement.setString(30, params.containsKey(ATTRIBUTE_10) ? getValue(params.get(ATTRIBUTE_10)) : null);
                        callableStatement.setString(31, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(32, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(33, params.containsKey(CANCELLED_ON) ? getValue(params.get(CANCELLED_ON)) : null);
                        callableStatement.setString(34, params.containsKey(REQUEST_TYPE_SK) ? getValue(params.get(REQUEST_TYPE_SK)) : null);
                        callableStatement.setString(35, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(36, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(37, params.containsKey(IS_TEMPLATE) ? getValue(params.get(IS_TEMPLATE)) : null);
                        callableStatement.setString(38, params.containsKey(CHANGE_NAME) ? getValue(params.get(CHANGE_NAME)) : null);
                        callableStatement.setString(39, params.containsKey(PROJECT_SK) ? getValue(params.get(PROJECT_SK)) : null);
                        callableStatement.setString(40, params.containsKey(PERIODIC) ? getValue(params.get(PERIODIC)) : null);
                        callableStatement.setString(41, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(42, params.containsKey(MAP_JSON) ? getValue(params.get(MAP_JSON)) : null);
                        callableStatement.setString(43, params.containsKey(DISCUSSION_BOARD_JSON) ? getValue(params.get(DISCUSSION_BOARD_JSON)) : null);
                        callableStatement.setString(44, params.containsKey(EST_CRITICAL_USER_DOWN_TIME) ? getValue(params.get(EST_CRITICAL_USER_DOWN_TIME)) : null);
                        callableStatement.setString(45, params.containsKey(EST_IMPACTED_USERS) ? getValue(params.get(EST_IMPACTED_USERS)) : null);
                        callableStatement.setString(46, params.containsKey(CALCULATED_RISK_LEVE_SK) ? getValue(params.get(CALCULATED_RISK_LEVE_SK)) : null);
                        callableStatement.setString(47, params.containsKey(OVERRIDE) ? getValue(params.get(OVERRIDE)) : null);
                        callableStatement.setString(48, params.containsKey(OVERRIDE_REASON) ? getValue(params.get(OVERRIDE_REASON)) : null);
                        callableStatement.setString(49, params.containsKey(CHANGE_OWNER_SK) ? getValue(params.get(CHANGE_OWNER_SK)) : null);
                        callableStatement.setString(50, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(51, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(52, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(53, params.containsKey(COM_REFRENCES) ? getValue(params.get(COM_REFRENCES)) : null);
                        callableStatement.setString(54, params.containsKey(CR_ASSESTS) ? getValue(params.get(CR_ASSESTS)) : null);
                        callableStatement.setString(55, params.containsKey(CR_GROUPS) ? getValue(params.get(CR_GROUPS)) : null);
                        callableStatement.setString(56, params.containsKey(CR_BUILDINGS) ? getValue(params.get(CR_BUILDINGS)) : null);
                        callableStatement.setString(57, params.containsKey(CR_LOCATIONS) ? getValue(params.get(CR_LOCATIONS)) : null);
                        callableStatement.setString(58, params.containsKey(CR_RISKS) ? gson.toJson(params.get(CR_RISKS)) : null);
                        callableStatement.setString(59, params.containsKey(CR_IMPACTED) ? gson.toJson(params.get(CR_IMPACTED)) : null);
                        callableStatement.setString(60, params.containsKey(CR_WORKNOTES) ? gson.toJson(params.get(CR_WORKNOTES)) : null);
                        callableStatement.setString(61, params.containsKey(COM_PERMISSIONS) ? gson.toJson(params.get(COM_PERMISSIONS)) : null);
                        callableStatement.setString(62, params.containsKey(ESTIMATED_TIME) ? getValue(params.get(ESTIMATED_TIME)) : null);
                        callableStatement.setString(63, params.containsKey(ReadinessRemarks) ? getValue(params.get(ReadinessRemarks)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(CR_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CHANGE_REQUEST, queryObject.get(CR_SK).toString(), user.getClientInstance()));


                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_COM_PERMISSIONS, queryObject.get(CR_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateChangeRequest(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 130); //66 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30
            paramList.add(varString); //31
            paramList.add(varString); //32
            paramList.add(varString); //33
            paramList.add(varString); //34
            paramList.add(varString); //35
            paramList.add(varString); //36
            paramList.add(varString); //37
            paramList.add(varString); //38
            paramList.add(varString); //39
            paramList.add(varString); //40
            paramList.add(varString); //41
            paramList.add(varString); //42
            paramList.add(varString); //43
            paramList.add(varString); //44
            paramList.add(varString); //45
            paramList.add(varString); //46
            paramList.add(varString); //47
            paramList.add(varString); //48
            paramList.add(varString); //49
            paramList.add(varString); //50
            paramList.add(varString); //51
            paramList.add(varString); //52
            paramList.add(varString); //53
            paramList.add(varString); //54
            paramList.add(varString); //54
            paramList.add(varString); //55
            paramList.add(varString); //56
            paramList.add(varString); //57
            paramList.add(varString); //58
            paramList.add(varString); //59
            paramList.add(varString); //60
            paramList.add(varString); //61
            paramList.add(varString); //62
            paramList.add(varString); //63
            paramList.add(varString); //64
            paramList.add(varString); //65
            paramList.add(varString); //66

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(PARENT_SK) ? getDBValidatedValue(params.get(PARENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(REQUESTER_SK) ? getDBValidatedValue(params.get(REQUESTER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(REQUESTERGROUP_SK) ? getDBValidatedValue(params.get(REQUESTERGROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(RISK_LEVEL_SK) ? getDBValidatedValue(params.get(RISK_LEVEL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(REQUESTED_ON) ? getDBValidatedValue(params.get(REQUESTED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(9, params.containsKey(CHANGE_REASON_SK) ? getDBValidatedValue(params.get(CHANGE_REASON_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(PLATFORM_SK) ? getDBValidatedValue(params.get(PLATFORM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(CR_CATEGORY_SK) ? getDBValidatedValue(params.get(CR_CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(CR_SYSTEM_SK) ? getDBValidatedValue(params.get(CR_SYSTEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(CHANGE_TYPE_SK) ? getDBValidatedValue(params.get(CHANGE_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(15, params.containsKey(CAB_MEMEBER_SK) ? getDBValidatedValue(params.get(CAB_MEMEBER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(SCHEDULED_ON) ? getDBValidatedValue(params.get(SCHEDULED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(17, params.containsKey(ESTIMATED_DOWN_TIME) ? getValue(params.get(ESTIMATED_DOWN_TIME)) : null);
                        callableStatement.setString(18, params.containsKey(ACTUAL_DOWNTIME) ? getDBValidatedValue(params.get(ACTUAL_DOWNTIME), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(IMPLEMENTATION_STATUS_SK) ? getDBValidatedValue(params.get(IMPLEMENTATION_STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(RESULTS) ? getDBValidatedValue(params.get(RESULTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(21, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(22, params.containsKey(ATTRIBUTE_1) ? getDBValidatedValue(params.get(ATTRIBUTE_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(23, params.containsKey(ATTRIBUTE_2) ? getDBValidatedValue(params.get(ATTRIBUTE_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(24, params.containsKey(ATTRIBUTE_3) ? getDBValidatedValue(params.get(ATTRIBUTE_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(25, params.containsKey(ATTRIBUTE_4) ? getDBValidatedValue(params.get(ATTRIBUTE_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(26, params.containsKey(ATTRIBUTE_5) ? getDBValidatedValue(params.get(ATTRIBUTE_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(27, params.containsKey(ATTRIBUTE_6) ? getDBValidatedValue(params.get(ATTRIBUTE_6), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(28, params.containsKey(ATTRIBUTE_7) ? getDBValidatedValue(params.get(ATTRIBUTE_7), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(29, params.containsKey(ATTRIBUTE_8) ? getDBValidatedValue(params.get(ATTRIBUTE_8), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(30, params.containsKey(ATTRIBUTE_9) ? getDBValidatedValue(params.get(ATTRIBUTE_9), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(31, params.containsKey(ATTRIBUTE_10) ? getDBValidatedValue(params.get(ATTRIBUTE_10), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(32, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(33, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(34, params.containsKey(CANCELLED_ON) ? getDBValidatedValue(params.get(CANCELLED_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(35, params.containsKey(REQUEST_TYPE_SK) ? getDBValidatedValue(params.get(REQUEST_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(36, params.containsKey(ACTUAL_START_TIME) ? getDBValidatedValue(params.get(ACTUAL_START_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(37, params.containsKey(ACTUAL_END_TIME) ? getDBValidatedValue(params.get(ACTUAL_END_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(38, params.containsKey(IS_TEMPLATE) ? getDBValidatedValue(params.get(IS_TEMPLATE), DATATYPE_BIT) : null);
                        callableStatement.setString(39, params.containsKey(CHANGE_NAME) ? getDBValidatedValue(params.get(CHANGE_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(40, params.containsKey(PROJECT_SK) ? getDBValidatedValue(params.get(PROJECT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(41, params.containsKey(PERIODIC) ? getValue(params.get(PERIODIC)) : null);
                        callableStatement.setString(42, params.containsKey(TYPE) ? getDBValidatedValue(params.get(TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(43, params.containsKey(MAP_JSON) ? getDBValidatedValue(params.get(MAP_JSON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(44, params.containsKey(DISCUSSION_BOARD_JSON) ? getDBValidatedValue(params.get(DISCUSSION_BOARD_JSON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(45, params.containsKey(EST_CRITICAL_USER_DOWN_TIME) ? getDBValidatedValue(params.get(EST_CRITICAL_USER_DOWN_TIME), DATATYPE_TIME) : null);
                        callableStatement.setString(46, params.containsKey(EST_IMPACTED_USERS) ? getDBValidatedValue(params.get(EST_IMPACTED_USERS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(47, params.containsKey(CALCULATED_RISK_LEVE_SK) ? getDBValidatedValue(params.get(CALCULATED_RISK_LEVE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(48, params.containsKey(OVERRIDE) ? getValue(params.get(OVERRIDE)) : null);
                        callableStatement.setString(49, params.containsKey(OVERRIDE_REASON) ? getDBValidatedValue(params.get(OVERRIDE_REASON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(50, params.containsKey(CHANGE_OWNER_SK) ? getDBValidatedValue(params.get(CHANGE_OWNER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(51, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(52, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(53, params.containsKey(DELETE_CR_ATTACHMENT_SK) ? getValue(params.get(DELETE_CR_ATTACHMENT_SK)) : null);
                        callableStatement.setString(54, params.containsKey(COM_REFRENCES) ? getValue(params.get(COM_REFRENCES)) : null);
                        callableStatement.setString(55, params.containsKey(DELETE_CR_COMREFRENCES_SK) ? getValue(params.get(DELETE_CR_COMREFRENCES_SK)) : null);
                        callableStatement.setString(56, params.containsKey(CR_ASSESTS) ? getValue(params.get(CR_ASSESTS)) : null);
                        callableStatement.setString(57, params.containsKey(CR_GROUPS) ? getValue(params.get(CR_GROUPS)) : null);
                        callableStatement.setString(58, params.containsKey(CR_BUILDINGS) ? getValue(params.get(CR_BUILDINGS)) : null);
                        callableStatement.setString(59, params.containsKey(CR_LOCATIONS) ? getValue(params.get(CR_LOCATIONS)) : null);
                        callableStatement.setString(60, params.containsKey(CR_RISKS) ? gson.toJson(params.get(CR_RISKS)) : null);
                        callableStatement.setString(61, params.containsKey(CR_IMPACTED) ? gson.toJson(params.get(CR_IMPACTED)) : null);
                        callableStatement.setString(62, params.containsKey(CR_WORKNOTES) ? gson.toJson(params.get(CR_WORKNOTES)) : null);
                        callableStatement.setString(63, params.containsKey(COM_PERMISSIONS) ? gson.toJson(params.get(COM_PERMISSIONS)) : null);
                        callableStatement.setString(64, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(65, params.containsKey(ESTIMATED_TIME) ? getValue(params.get(ESTIMATED_TIME)) : null);
                        callableStatement.setString(66, params.containsKey(ReadinessRemarks) ? getValue(params.get(ReadinessRemarks)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(CR_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CHANGE_REQUEST, queryObject.get(CR_SK).toString(), user.getClientInstance()));

                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_COM_PERMISSIONS, queryObject.get(CR_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createChangeRequestTask(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 58); //30 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(3, params.containsKey(PARENT_CRT_SK) ? getValue(params.get(PARENT_CRT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(TASK_DETAILS_SK) ? getValue(params.get(TASK_DETAILS_SK)) : null);
                        callableStatement.setString(5, params.containsKey(TASK_NAME) ? getValue(params.get(TASK_NAME)) : null);
                        callableStatement.setString(6, params.containsKey(INSTALL_ON) ? getValue(params.get(INSTALL_ON)) : null);
                        callableStatement.setString(7, params.containsKey(TASK_TYPE_SK) ? getValue(params.get(TASK_TYPE_SK)) : null);
                        callableStatement.setString(8, params.containsKey(CLIENT_VENDOR_SK) ? getValue(params.get(CLIENT_VENDOR_SK)) : null);
                        callableStatement.setString(9, params.containsKey(VENDOR_TICKET_NUMBER) ? getValue(params.get(VENDOR_TICKET_NUMBER)) : null);
                        callableStatement.setString(10, params.containsKey(IMPLEMENTATION_STATUS) ? getValue(params.get(IMPLEMENTATION_STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(RESULTS) ? getValue(params.get(RESULTS)) : null);
                        callableStatement.setString(12, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(13, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(14, params.containsKey(DOWN_TIME) ? getValue(params.get(DOWN_TIME)) : null);
                        callableStatement.setString(15, params.containsKey(EST_START_TIME) ? getValue(params.get(EST_START_TIME)) : null);
                        callableStatement.setString(16, params.containsKey(EST_END_TIME) ? getValue(params.get(EST_END_TIME)) : null);
                        callableStatement.setString(17, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(18, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(19, params.containsKey(ESTIMATED_EFFORT) ? getValue(params.get(ESTIMATED_EFFORT)) : null);
                        callableStatement.setString(20, params.containsKey(APPROVAL_CRITERIA_SK) ? getValue(params.get(APPROVAL_CRITERIA_SK)) : null);
                        callableStatement.setString(21, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(22, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(23, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(24, params.containsKey(ACTUAL_EFFORT) ? getValue(params.get(ACTUAL_EFFORT)) : null);
                        callableStatement.setString(25, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(26, params.containsKey(CRT_STAKE_HOLDERS) ? gson.toJson(params.get(CRT_STAKE_HOLDERS)) : null);
                        callableStatement.setString(27, params.containsKey(CRT_ASSIGNMENTS) ? gson.toJson(params.get(CRT_ASSIGNMENTS)) : null);
                        callableStatement.setString(28, params.containsKey(DESIGN_BOARD) ? gson.toJson(params.get(DESIGN_BOARD)) : null);
                        callableStatement.setString(29, params.containsKey(WORKNOTES) ? gson.toJson(params.get(WORKNOTES)) : null);
                        callableStatement.setString(30, params.containsKey(ACTION_ITEMS) ? gson.toJson(params.get(ACTION_ITEMS)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(CRT_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_TASKS, queryObject.get(CRT_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateChangeRequestTask(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 62); //32 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30
            paramList.add(varString); //31
            paramList.add(varString); //32


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(3, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(4, params.containsKey(PARENT_CRT_SK) ? getDBValidatedValue(params.get(PARENT_CRT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(TASK_DETAILS_SK) ? getDBValidatedValue(params.get(TASK_DETAILS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(TASK_NAME) ? getValue(params.get(TASK_NAME)) : null);
                        callableStatement.setString(7, params.containsKey(INSTALL_ON) ? getValue(params.get(INSTALL_ON)) : null);
                        callableStatement.setString(8, params.containsKey(TASK_TYPE_SK) ? getValue(params.get(TASK_TYPE_SK)) : null);
                        callableStatement.setString(9, params.containsKey(CLIENT_VENDOR_SK) ? getDBValidatedValue(params.get(CLIENT_VENDOR_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(VENDOR_TICKET_NUMBER) ? getDBValidatedValue(params.get(VENDOR_TICKET_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(11, params.containsKey(IMPLEMENTATION_STATUS) ? getDBValidatedValue(params.get(IMPLEMENTATION_STATUS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(RESULTS) ? getDBValidatedValue(params.get(RESULTS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(14, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(15, params.containsKey(DOWN_TIME) ? getDBValidatedValue(params.get(DOWN_TIME), DATATYPE_TIME) : null);
                        callableStatement.setString(16, params.containsKey(EST_START_TIME) ? getDBValidatedValue(params.get(EST_START_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(17, params.containsKey(EST_END_TIME) ? getDBValidatedValue(params.get(EST_END_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(18, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(IS_MANDATORY) ? getDBValidatedValue(params.get(IS_MANDATORY), DATATYPE_BIT) : null);
                        callableStatement.setString(20, params.containsKey(ESTIMATED_EFFORT) ? getDBValidatedValue(params.get(ESTIMATED_EFFORT), DATATYPE_TIME) : null);
                        callableStatement.setString(21, params.containsKey(APPROVAL_CRITERIA_SK) ? getDBValidatedValue(params.get(APPROVAL_CRITERIA_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(22, params.containsKey(ACTUAL_START_TIME) ? getDBValidatedValue(params.get(ACTUAL_START_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(23, params.containsKey(ACTUAL_END_TIME) ? getDBValidatedValue(params.get(ACTUAL_END_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(24, params.containsKey(IS_DELETED) ? getDBValidatedValue(params.get(IS_DELETED), DATATYPE_BIT) : null);
                        callableStatement.setString(25, params.containsKey(ACTUAL_EFFORT) ? getDBValidatedValue(params.get(ACTUAL_EFFORT), DATATYPE_TIME) : null);
                        callableStatement.setString(26, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(27, params.containsKey(DELETE_ATTACHMENT_SK) ? getValue(convertDeleteAttachment_sk(params.get(DELETE_ATTACHMENT_SK))) : null);
                        callableStatement.setString(28, params.containsKey(CRT_STAKE_HOLDERS) ? gson.toJson(params.get(CRT_STAKE_HOLDERS)) : null);
                        callableStatement.setString(29, params.containsKey(CRT_ASSIGNMENTS) ? gson.toJson(params.get(CRT_ASSIGNMENTS)) : null);
                        callableStatement.setString(30, params.containsKey(WORKNOTES) ? gson.toJson(params.get(WORKNOTES)) : null);
                        callableStatement.setString(31, params.containsKey(ACTION_ITEMS) ? gson.toJson(params.get(ACTION_ITEMS)) : null);
                        callableStatement.setString(32, params.containsKey(DESIGN_BOARD) ? gson.toJson(params.get(DESIGN_BOARD)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(CRT_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_TASKS, queryObject.get(CRT_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createChangeRequestDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20); //11 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(3, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(4, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(5, params.containsKey(COM_REFRENCES) ? getValue(params.get(COM_REFRENCES)) : null);
                        callableStatement.setString(6, params.containsKey(CR_ASSESTS) ? getValue(params.get(CR_ASSESTS)) : null);
                        callableStatement.setString(7, params.containsKey(CR_GROUPS) ? getValue(params.get(CR_GROUPS)) : null);
                        callableStatement.setString(8, params.containsKey(CR_BUILDINGS) ? getValue(params.get(CR_BUILDINGS)) : null);
                        callableStatement.setString(9, params.containsKey(CR_LOCATIONS) ? getValue(params.get(CR_LOCATIONS)) : null);
                        callableStatement.setString(10, params.containsKey(CR_RISKS) ? gson.toJson(params) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateChangeRequestDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); //12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(3, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(4, params.containsKey(ATTACHMENTS) ? getValue(params.get(ATTACHMENTS)) : null);
                        callableStatement.setString(5, params.containsKey(DELETE_CR_ATTACHMENT_SK) ? getValue(params.get(DELETE_CR_ATTACHMENT_SK)) : null);
                        callableStatement.setString(6, params.containsKey(COM_REFRENCES) ? getValue(params.get(COM_REFRENCES)) : null);
                        callableStatement.setString(7, params.containsKey(DELETE_CR_COMREFRENCES_SK) ? getValue(params.get(DELETE_CR_COMREFRENCES_SK)) : null);
                        callableStatement.setString(8, params.containsKey(CR_ASSESTS) ? getValue(params.get(CR_ASSESTS)) : null);
                        callableStatement.setString(9, params.containsKey(CR_GROUPS) ? getValue(params.get(CR_GROUPS)) : null);
                        callableStatement.setString(10, params.containsKey(CR_BUILDINGS) ? getValue(params.get(CR_BUILDINGS)) : null);
                        callableStatement.setString(11, params.containsKey(CR_LOCATIONS) ? getValue(params.get(CR_LOCATIONS)) : null);
                        callableStatement.setString(12, params.containsKey(CR_RISKS) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> updateActionItemDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACTION_ITEMS) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(ACTIONITEM_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(ACTIONITEM_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_ACTIONITEMS, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> createCRApprovalsDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 32); //17 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(2, params.containsKey(APPROVAL_CRITERIA_SK) ? getValue(params.get(APPROVAL_CRITERIA_SK)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(4, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(5, params.containsKey(APPROVAL_NUMBER) ? getValue(params.get(APPROVAL_NUMBER)) : null);
                        callableStatement.setString(6, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(7, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(8, params.containsKey(TASKTYPE_SK) ? getValue(params.get(TASKTYPE_SK)) : null);
                        //  callableStatement.setString(9, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(9, params.containsKey(EST_START_TIME) ? getValue(params.get(EST_START_TIME)) : null);
                        callableStatement.setString(10, params.containsKey(EST_END_TIME) ? getValue(params.get(EST_END_TIME)) : null);
                        callableStatement.setString(11, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(12, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(13, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(14, params.containsKey(CR_APPROVAL_STATUS) ? gson.toJson(params.get(CR_APPROVAL_STATUS)) : null);
                        callableStatement.setString(15, params.containsKey(DESIGN_BOARD) ? gson.toJson(params.get(DESIGN_BOARD)) : null);
                        callableStatement.setString(16, params.containsKey(REMARKS) ? getValue(params.get(REMARKS)) : null);
                        callableStatement.setString(17, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey1 = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(APPROVAL_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(APPROVAL_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CR_APPROVALS, SFInterfaceServices.GetStringArray(updatedkey1), user.getClientInstance()));

                /*List<String> updatedkey2 = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(APPROVALSTATUS_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(APPROVALSTATUS_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CR_APPROVALSTATUS, SFInterfaceServices.GetStringArray(updatedkey2)));*/
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateCRApprovalsDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 32); //17 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(APPROVAL_SK) ? getValue(params.get(APPROVAL_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(3, params.containsKey(APPROVAL_CRITERIA_SK) ? getDBValidatedValue(params.get(APPROVAL_CRITERIA_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(7, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(TASKTYPE_SK) ? getDBValidatedValue(params.get(TASKTYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(EST_START_TIME) ? getDBValidatedValue(params.get(EST_START_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(10, params.containsKey(EST_END_TIME) ? getDBValidatedValue(params.get(EST_END_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(11, params.containsKey(ACTUAL_START_TIME) ? getDBValidatedValue(params.get(ACTUAL_START_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(12, params.containsKey(ACTUAL_END_TIME) ? getDBValidatedValue(params.get(ACTUAL_END_TIME), DATATYPE_DATETIME) : null);
                        callableStatement.setString(13, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(14, params.containsKey(CR_APPROVAL_STATUS) ? gson.toJson(params.get(CR_APPROVAL_STATUS)) : null);
                        callableStatement.setString(15, params.containsKey(DESIGN_BOARD) ? gson.toJson(params.get(DESIGN_BOARD)) : null);
                        callableStatement.setString(16, params.containsKey(REMARKS) ? getValue(params.get(REMARKS)) : null);
                        callableStatement.setString(17, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey1 = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(APPROVAL_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(APPROVAL_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CR_APPROVALS, SFInterfaceServices.GetStringArray(updatedkey1), user.getClientInstance()));

                /*List<String> updatedkey2 = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(APPROVALSTATUS_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(APPROVALSTATUS_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CR_APPROVALSTATUS, SFInterfaceServices.GetStringArray(updatedkey2)));*/
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateImpactDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(IMPACTED) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(IMPACTED_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(IMPACTED_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CR_IMPACTED, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateRisksDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(RISKS) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                List<String> updatedkey = result.stream()
                        .filter(stringObjectMap -> stringObjectMap.get(RISK_SK) != null)
                        .map(
                                stringObjectMap -> stringObjectMap.get(RISK_SK).toString())
                        .collect(Collectors.toList());
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CRRISKS, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static Map<String, Object> createKBArticle(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 34); //18 Parameters
            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {

                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(2, params.containsKey(ARTICLE_TITLE) ? getValue(params.get(ARTICLE_TITLE)) : null);
                        callableStatement.setString(3, params.containsKey(ARTILCE_KEYWORDS) ? getValue(params.get(ARTILCE_KEYWORDS)) : null);
                        callableStatement.setString(4, params.containsKey(PHRASE_HISTORY) ? getValue(params.get(PHRASE_HISTORY)) : null);
                        callableStatement.setString(5, params.containsKey(TYPE_AHEAD_CATEGORY) ? getValue(params.get(TYPE_AHEAD_CATEGORY)) : null);
                        callableStatement.setString(6, params.containsKey(ARTICLE_OWNER_SK) ? getValue(params.get(ARTICLE_OWNER_SK)) : null);
                        callableStatement.setString(7, params.containsKey(EXPIRY_DATE) ? getValue(params.get(EXPIRY_DATE)) : null);
                        callableStatement.setString(8, params.containsKey(LOCK_STATUS) ? getValue(params.get(LOCK_STATUS)) : null);
                        callableStatement.setString(9, params.containsKey(FLR) ? getValue(params.get(FLR)) : null);
                        callableStatement.setString(10, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(11, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(12, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(ARTICLE_TYPE_SK) ? getValue(params.get(ARTICLE_TYPE_SK)) : null);
                        callableStatement.setString(14, params.containsKey(CONTENT_OWNER) ? getValue(params.get(CONTENT_OWNER)) : null);
                        callableStatement.setString(15, params.containsKey(AUTHOR) ? getValue(params.get(AUTHOR)) : null);
                        callableStatement.setString(16, params.containsKey(DOC_CONTENT_TYPE_SK) ? getValue(params.get(DOC_CONTENT_TYPE_SK)) : null);
                        callableStatement.setString(17, params.containsKey(TYPE_AHEAD_PHRASE) ? getValue(params.get(TYPE_AHEAD_PHRASE)) : null);
                        callableStatement.setString(18, params.containsKey(RDY_MAP) ? gson.toJson(params.get(RDY_MAP)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBArticle(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 36); //18 Parameters
            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {

                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ARTICLE_METADATA_SK) ? getValue(params.get(ARTICLE_METADATA_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(ARTICLE_TITLE) ? getValue(params.get(ARTICLE_TITLE)) : null);
                        callableStatement.setString(4, params.containsKey(ARTILCE_KEYWORDS) ? getValue(params.get(ARTILCE_KEYWORDS)) : null);
                        callableStatement.setString(5, params.containsKey(PHRASE_HISTORY) ? getValue(params.get(PHRASE_HISTORY)) : null);
                        callableStatement.setString(6, params.containsKey(LOCK_STATUS) ? getValue(params.get(LOCK_STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(TYPE_AHEAD_CATEGORY) ? getValue(params.get(TYPE_AHEAD_CATEGORY)) : null);
                        callableStatement.setString(8, params.containsKey(FLR) ? getValue(params.get(FLR)) : null);
                        callableStatement.setString(9, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(ARTICLE_TYPE_SK) ? getValue(params.get(ARTICLE_TYPE_SK)) : null);
                        callableStatement.setString(13, params.containsKey(CONTENT_OWNER) ? getValue(params.get(CONTENT_OWNER)) : null);
                        callableStatement.setString(14, params.containsKey(AUTHOR) ? getValue(params.get(AUTHOR)) : null);
                        callableStatement.setString(15, params.containsKey(DOC_CONTENT_TYPE_SK) ? getValue(params.get(DOC_CONTENT_TYPE_SK)) : null);
                        callableStatement.setString(16, params.containsKey(COMMENT) ? getValue(params.get(COMMENT)) : null);
                        callableStatement.setString(17, params.containsKey(TYPE_AHEAD_PHRASE) ? gson.toJson(params.get(TYPE_AHEAD_PHRASE)) : null);
                        callableStatement.setString(18, params.containsKey(RDY_MAP) ? gson.toJson(params.get(RDY_MAP)) : null);
                        callableStatement.setString(19, params.containsKey(ArchivedPath) ? getValue(params.get(ArchivedPath)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateChangeType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CHANGE_TYPE_SK) ? getValue(params.get(CHANGE_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CHANGE_TYPE_CODE) ? getValue(params.get(CHANGE_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CHANGE_TYPE_NAME) ? getValue(params.get(CHANGE_TYPE_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(CHANGE_TYPE_DESC) ? getDBValidatedValue(params.get(CHANGE_TYPE_DESC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updatePlatforms(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(PLATFORM_SK) ? getValue(params.get(PLATFORM_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PLATFORM_CODE) ? getValue(params.get(PLATFORM_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(PLATFORM_NAME) ? getValue(params.get(PLATFORM_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(PLATFORM_DESC) ? getDBValidatedValue(params.get(PLATFORM_DESC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(QUESTIONS) ? gson.toJson(params.get(QUESTIONS)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRCategory(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CR_CATEGORY_SK) ? getValue(params.get(CR_CATEGORY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_CATEGORY_CODE) ? getValue(params.get(CR_CATEGORY_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CR_CATEGORY_NAME) ? getValue(params.get(CR_CATEGORY_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(CR_CATEGORY_DESC) ? getDBValidatedValue(params.get(CR_CATEGORY_DESC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(QUESTIONS) ? gson.toJson(params.get(QUESTIONS)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRSystems(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CR_SYSTEM_SK) ? getValue(params.get(CR_SYSTEM_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SYSTEM_CODE) ? getValue(params.get(CR_SYSTEM_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CR_CATEGORY_SK) ? getValue(params.get(CR_CATEGORY_SK)) : null);
                        callableStatement.setString(5, params.containsKey(SYSTEM) ? getDBValidatedValue(params.get(SYSTEM), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(QUESTIONS) ? gson.toJson(params.get(QUESTIONS)) : null);
                        callableStatement.setString(10, params.containsKey(SYSTEM_DESC) ? getDBValidatedValue(params.get(SYSTEM_DESC), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateLOV(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 26); // 14 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(LOVVALUES_SK) ? getValue(params.get(LOVVALUES_SK)) : null);
                        callableStatement.setString(2, params.containsKey(LOVNAME_SK) ? getDBValidatedValue(params.get(LOVNAME_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(LABEL) ? getDBValidatedValue(params.get(LABEL), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(REFERENCE_GROUP) ? getDBValidatedValue(params.get(REFERENCE_GROUP), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(LOVFUNCTION) ? getDBValidatedValue(params.get(LOVFUNCTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(SORTORDER) ? getDBValidatedValue(params.get(SORTORDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(TYPE) ? getDBValidatedValue(params.get(TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(14, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRiskLevel(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RISK_LEVEL_SK) ? getValue(params.get(RISK_LEVEL_SK)) : null);
                        callableStatement.setString(2, params.containsKey(RISK_LEVEL_CODE) ? getValue(params.get(RISK_LEVEL_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(RISK_LEVEL_NAME) ? getDBValidatedValue(params.get(RISK_LEVEL_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(RISK_LEVEL_DESC) ? getDBValidatedValue(params.get(RISK_LEVEL_DESC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(ORDER) ? getDBValidatedValue(params.get(ORDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(RANGE_START) ? getDBValidatedValue(params.get(RANGE_START), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(RANGE_END) ? getDBValidatedValue(params.get(RANGE_END), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(COLOR) ? getDBValidatedValue(params.get(COLOR), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateQuestions(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); // 10 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(QUESTION_SK) ? getValue(params.get(QUESTION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(QUESTION_CODE) ? getValue(params.get(QUESTION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(QUESTION) ? getValue(params.get(QUESTION)) : null);
                        callableStatement.setString(5, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(TYPE) ? getDBValidatedValue(params.get(TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(10, params.containsKey(ORDER) ? getDBValidatedValue(params.get(ORDER), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateTaskType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TASKTYPE_SK) ? getValue(params.get(TASKTYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TASKTYPE_CODE) ? getValue(params.get(TASKTYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(TASKTYPE_NAME) ? getDBValidatedValue(params.get(TASKTYPE_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(TASKTYPE_DESC) ? getDBValidatedValue(params.get(TASKTYPE_DESC), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(ORDER) ? getDBValidatedValue(params.get(ORDER), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateBusinessOrganization(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BUS_ORG_SK) ? getValue(params.get(BUS_ORG_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSORG_CODE) ? getDBValidatedValue(params.get(BUSORG_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(BUSINESS_ORGANIZATION) ? getDBValidatedValue(params.get(BUSINESS_ORGANIZATION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updatePriority(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PRIORITY_CODE) ? getDBValidatedValue(params.get(PRIORITY_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(PRIORITY) ? getDBValidatedValue(params.get(PRIORITY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_PRIORITY);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_PRIORITY, queryObject.get(updatedKey).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccountRole(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT_ROLE_SK) ? getValue(params.get(ACCOUNT_ROLE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_ROLE_CODE) ? getDBValidatedValue(params.get(ACCOUNT_ROLE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ROLE) ? getDBValidatedValue(params.get(ROLE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static Map<String, Object> updateApprovalType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(APPROVAL_TYPE_SK) ? getValue(params.get(APPROVAL_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(APPROVAL_TYPE_CODE) ? getDBValidatedValue(params.get(APPROVAL_TYPE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(APPROVAL_TYPE) ? getDBValidatedValue(params.get(APPROVAL_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ENTITYCODE) ? getDBValidatedValue(params.get(ENTITYCODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateVendor(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(VENDOR_SK) ? getValue(params.get(VENDOR_SK)) : null);
                        callableStatement.setString(2, params.containsKey(VENDOR_CODE) ? getDBValidatedValue(params.get(VENDOR_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(VENDOR) ? getDBValidatedValue(params.get(VENDOR), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                String updatedKey = fetchIndexerJsonfromPath(INDEXERNAME_FETCH_VENDOR);
                if (queryObject.containsKey(updatedKey)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_VENDOR, queryObject.get(updatedKey).toString(), user.getClientInstance()));

                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateLOVName(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(LOVNAME_SK) ? getValue(params.get(LOVNAME_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static String convertStringToTimestamp(String strDate) {
        try {

            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH mm");
            // you can change format of date
            strDate += " 00 00";
            Date date = formatter.parse(strDate);
            Timestamp timeStampDate = new Timestamp(date.getTime());
            return String.valueOf(timeStampDate.getTime() / 1000);
        } catch (ParseException e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            return null;
        }
    }

    public static String convertToTimestamp(String strDate) {
        try {

            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            // you can change format of date
            Date date = formatter.parse(strDate);
            Timestamp timeStampDate = new Timestamp(date.getTime());
            return String.valueOf(timeStampDate.getTime());
        } catch (ParseException e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            return null;
        }
    }

    public static String convertTimestampTODatetime(String strDate) {
        try {
            if (strDate == null) {
                return null;
            }
            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            // you can change format of date
            Date date = new Date(Long.parseLong(strDate));
            return formatter.format(date);
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            return null;
        }
    }

    public static String convertStringToTimestampendDate(String strDate) {
        try {
            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH mm");
            // you can change format of date
            strDate += " 23 59";
            Date date = formatter.parse(strDate);
            Timestamp timeStampDate = new Timestamp(date.getTime());
            return String.valueOf((timeStampDate.getTime() + (24 * 60 * 60)) / 1000);
        } catch (ParseException e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            return null;
        }
    }

    public static String consolidatedTicketsFullTextQuery(String query) {
        try {
            return SFInterfaceBase.fetchRequiredFieldsForBusinessFunction("CONSOLIDATED_TICKET_FULLTEXT_SEARCH_FIELDS").parallelStream()
                    .map(fieldname ->
                            (fieldname.equalsIgnoreCase("ticket")
                                    && query.length() >= 4
                                    && StringUtils.isNumeric(query)
                            ) ?
                                    fieldname + COLON + ESCAPE_CHARACTER + query + ESCAPE_CHARACTER
                                            + OR + fieldname + COLON + ASTERISK + query
                                    :
                                    fieldname + COLON + ESCAPE_CHARACTER + query + ESCAPE_CHARACTER
                                            + OR + fieldname + COLON + query + ASTERISK
                    )
                    .collect(Collectors.joining(OR));
        } catch (IOException e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
            return null;
        }
    }

    public static Map<String, Object> fetchSNOWTicket(String businessFunctionCode, String ticket) throws Exception {
        Map<String, Object> response = new HashMap<>();
        final Map<String, List<Map<String, String>>>[] tempresponse = new Map[]{new HashMap<>()};
        String snow_URL_FETCH_SYSID = SFInterfaceConstants.getServicenowFetchSystemId();
        String snow_URL_FETCH_TICKET = SFInterfaceConstants.getServicenowFetchIncident();
        String snow_URL_FETCH_TICKET_DESCRIPTION = SFInterfaceConstants.getServicenowFetchIncidentDescription();
        String snow_URL_FETCH_AUTHORIZATION_VALUE = SFInterfaceConstants.getServicenowAuthHeaderValue();
        snow_URL_FETCH_SYSID = snow_URL_FETCH_SYSID.replace(DOUBLE_OPEN_BRACE + BUSINESS_FUNCTION_CODE + DOUBLE_CLOSE_BRACE, businessFunctionCode);
        snow_URL_FETCH_TICKET = snow_URL_FETCH_TICKET.replace(DOUBLE_OPEN_BRACE + BUSINESS_FUNCTION_CODE + DOUBLE_CLOSE_BRACE, businessFunctionCode);
        snow_URL_FETCH_SYSID = snow_URL_FETCH_SYSID.replace(DOUBLE_OPEN_BRACE + TICKET + DOUBLE_CLOSE_BRACE, ticket);
        snow_URL_FETCH_TICKET_DESCRIPTION = snow_URL_FETCH_TICKET_DESCRIPTION.replace(DOUBLE_OPEN_BRACE + TICKET + DOUBLE_CLOSE_BRACE, ticket);

        RestTemplate restTemplate = new RestTemplate();

        //   configureproxy();

        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.AUTHORIZATION, snow_URL_FETCH_AUTHORIZATION_VALUE);
        HttpEntity entity = new HttpEntity<>(headers);

        tempresponse[0] = (Map<String, List<Map<String, String>>>) restTemplate.exchange(snow_URL_FETCH_SYSID, HttpMethod.GET, entity, HashMap.class).getBody();

        if (tempresponse[0].containsKey(SFInterfaceConstants.result)) {
            if (tempresponse[0].get(SFInterfaceConstants.result).size() == 1) {
                String sys_id = tempresponse[0].get(SFInterfaceConstants.result).get(0)
                        .get(SFInterfaceConstants.sys_id)
                        .toString();

                snow_URL_FETCH_TICKET = snow_URL_FETCH_TICKET.replace(DOUBLE_OPEN_BRACE + SFInterfaceConstants.sys_id + DOUBLE_CLOSE_BRACE, sys_id);
                response = (Map<String, Object>) restTemplate.exchange(snow_URL_FETCH_TICKET, HttpMethod.GET, entity, HashMap.class).getBody();
                Map<String, Object> finalResponse = response;
                Map<String, Object> resultResponse = new HashMap<>();
                RestTemplate finalRestTemplate = restTemplate;
                resultResponse = (Map<String, Object>) response.get(result);
                Map<String, Object> finalResultResponse = resultResponse;
                resultResponse.keySet().forEach(s -> {
                    if (((Map<String, Object>) finalResponse.get(result)).containsKey(s)
                            && ((Map<String, Map<String, String>>) finalResponse.get(result))
                            .get(s) instanceof Map && ((Map<String, Map<String, String>>) finalResponse.get(result))
                            .get(s).containsKey(link)) {
                        String url = ((Map<String, Map<String, String>>) finalResponse.get(result))
                                .get(s).get(link).toString();
                        url += "?sysparm_fields=name";
                        Map<String, Object> responsetemplate = new HashMap<>();
                        responsetemplate = finalRestTemplate.exchange(url, HttpMethod.GET, entity, HashMap.class)
                                .getBody();
                        if (responsetemplate.containsKey(result)) {
                            String name = (((Map<String, String>) responsetemplate.get(result))).get("name").toString();
                            finalResultResponse.put(s, name);
                        } else {
                            finalResultResponse.remove(s);
                        }
                    }
                });
                Map<String, String> resp = (((List<Map<String, String>>) finalRestTemplate.exchange(snow_URL_FETCH_TICKET_DESCRIPTION, HttpMethod.GET, entity, HashMap.class)
                        .getBody().get(result)).get(0));
                for (Map.Entry<String, String> stringStringEntry : resp.entrySet()) {
                    finalResultResponse.put(stringStringEntry.getKey(), stringStringEntry.getValue());
                }
                response.put((String) result, finalResultResponse);


            } else {
                if (tempresponse[0].get(SFInterfaceConstants.result).size() == 0)
                    throw new Exception("sys_id not found");
                else
                    throw new Exception("Multiple sys_id is found");
            }
        } else {
            throw new Exception("Result Not found");
        }

        return response;
    }

    public static Map<String, Object> createCRSchedules(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 30); //22 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(2, params.containsKey(REQUESTER_SK) ? getValue(params.get(REQUESTER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(START_ON) ? getValue(params.get(START_ON)) : null);
                        callableStatement.setString(4, params.containsKey(END_ON) ? getValue(params.get(END_ON)) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(6, params.containsKey(MEETING_NAME) ? getValue(params.get(MEETING_NAME)) : null);
                        callableStatement.setString(7, params.containsKey(PURPOSE) ? getValue(params.get(PURPOSE)) : null);
                        callableStatement.setString(8, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(9, params.containsKey(LOCATION) ? getValue(params.get(LOCATION)) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(11, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(12, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(13, params.containsKey(CR_DISCUSSION_POINTS) ? gson.toJson(params.get(CR_DISCUSSION_POINTS)) : null);
                        callableStatement.setString(14, params.containsKey(ACTION_ITEMS) ? gson.toJson(params.get(ACTION_ITEMS)) : null);
                        callableStatement.setString(15, params.containsKey(CR_MEETING_PARTICIPANTS) ? gson.toJson(params.get(CR_MEETING_PARTICIPANTS)) : null);
                        callableStatement.setString(16, params.containsKey(DESIGN_BOARD) ? gson.toJson(params.get(DESIGN_BOARD)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(SCHEDULE_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_SCHEDULES, queryObject.get(SCHEDULE_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRSchedules(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 30); //15 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SCHEDULE_SK) ? getValue(params.get(SCHEDULE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(3, params.containsKey(REQUESTER_SK) ? getValue(params.get(REQUESTER_SK)) : null);
                        callableStatement.setString(4, params.containsKey(START_ON) ? getDBValidatedValue(params.get(START_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(5, params.containsKey(END_ON) ? getDBValidatedValue(params.get(END_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(MEETING_NAME) ? getDBValidatedValue(params.get(MEETING_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(PURPOSE) ? getDBValidatedValue(params.get(PURPOSE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(IS_MANDATORY) ? getDBValidatedValue(params.get(IS_MANDATORY), DATATYPE_BIT) : null);
                        callableStatement.setString(10, params.containsKey(LOCATION) ? getDBValidatedValue(params.get(LOCATION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(IS_DELETED) ? getDBValidatedValue(params.get(IS_DELETED), DATATYPE_BIT) : null);
                        callableStatement.setString(13, params.containsKey(CR_DISCUSSION_POINTS) ? gson.toJson(params.get(CR_DISCUSSION_POINTS)) : null);
                        callableStatement.setString(14, params.containsKey(ACTION_ITEMS) ? gson.toJson(params.get(ACTION_ITEMS)) : null);
                        callableStatement.setString(15, params.containsKey(CR_MEETING_PARTICIPANTS) ? gson.toJson(params.get(CR_MEETING_PARTICIPANTS)) : null);
                        callableStatement.setString(16, params.containsKey(DESIGN_BOARD) ? gson.toJson(params.get(DESIGN_BOARD)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(SCHEDULE_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_SCHEDULES, queryObject.get(SCHEDULE_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createCRClosure(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 42); //22 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(2, params.containsKey(REQUESTER_SK) ? getValue(params.get(REQUESTER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(START_ON) ? getValue(params.get(START_ON)) : null);
                        callableStatement.setString(4, params.containsKey(END_ON) ? getValue(params.get(END_ON)) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(6, params.containsKey(MEETING_NAME) ? getValue(params.get(MEETING_NAME)) : null);
                        callableStatement.setString(7, params.containsKey(PURPOSE) ? getValue(params.get(PURPOSE)) : null);
                        callableStatement.setString(8, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(9, params.containsKey(LOCATION) ? getValue(params.get(LOCATION)) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(11, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(12, params.containsKey(FOLLOW_UP) ? getValue(params.get(FOLLOW_UP)) : null);
                        callableStatement.setString(13, params.containsKey(FOLLOW_UP_START_DATE) ? getValue(params.get(FOLLOW_UP_START_DATE)) : null);
                        callableStatement.setString(14, params.containsKey(FOLLOW_UP_END_DATE) ? getValue(params.get(FOLLOW_UP_END_DATE)) : null);
                        callableStatement.setString(15, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(16, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(17, params.containsKey(ACTUAL_DOWNTIME) ? getValue(params.get(ACTUAL_DOWNTIME)) : null);
                        callableStatement.setString(18, params.containsKey(IMPLEMENTATION_STATUS_SK) ? getValue(params.get(IMPLEMENTATION_STATUS_SK)) : null);
                        callableStatement.setString(19, params.containsKey(RESULTS) ? getValue(params.get(RESULTS)) : null);
                        callableStatement.setString(20, params.containsKey(CR_MEETING_PARTICIPANTS) ? gson.toJson(params.get(CR_MEETING_PARTICIPANTS)) : null);
                        callableStatement.setString(21, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(22, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(SCHEDULE_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_SCHEDULES, queryObject.get(SCHEDULE_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRClosure(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 46); //24 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SCHEDULE_SK) ? getValue(params.get(SCHEDULE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(3, params.containsKey(REQUESTER_SK) ? getValue(params.get(REQUESTER_SK)) : null);
                        callableStatement.setString(4, params.containsKey(START_ON) ? getDBValidatedValue(params.get(START_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(5, params.containsKey(END_ON) ? getDBValidatedValue(params.get(END_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(MEETING_NAME) ? getDBValidatedValue(params.get(MEETING_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(PURPOSE) ? getDBValidatedValue(params.get(PURPOSE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(IS_MANDATORY) ? getDBValidatedValue(params.get(IS_MANDATORY), DATATYPE_BIT) : null);
                        callableStatement.setString(11, params.containsKey(LOCATION) ? getDBValidatedValue(params.get(LOCATION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(FOLLOW_UP) ? getValue(params.get(FOLLOW_UP)) : null);
                        callableStatement.setString(14, params.containsKey(FOLLOW_UP_START_DATE) ? getValue(params.get(FOLLOW_UP_START_DATE)) : null);
                        callableStatement.setString(15, params.containsKey(FOLLOW_UP_END_DATE) ? getValue(params.get(FOLLOW_UP_END_DATE)) : null);
                        callableStatement.setString(16, params.containsKey(DELETE_FOLLOW_UP_SCHEDULE_SK) ? getValue(params.get(DELETE_FOLLOW_UP_SCHEDULE_SK)) : null);
                        callableStatement.setString(17, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(18, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(19, params.containsKey(ACTUAL_DOWNTIME) ? getValue(params.get(ACTUAL_DOWNTIME)) : null);
                        callableStatement.setString(20, params.containsKey(IMPLEMENTATION_STATUS_SK) ? getValue(params.get(IMPLEMENTATION_STATUS_SK)) : null);
                        callableStatement.setString(21, params.containsKey(RESULTS) ? getValue(params.get(RESULTS)) : null);
                        callableStatement.setString(22, params.containsKey(CR_MEETING_PARTICIPANTS) ? gson.toJson(params.get(CR_MEETING_PARTICIPANTS)) : null);
                        callableStatement.setString(23, params.containsKey(COM_RESPONSES) ? getValue(params.get(COM_RESPONSES)) : null);
                        callableStatement.setString(24, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                if (queryObject.containsKey(SCHEDULE_SK)) {
                    jmsTemplate.convertAndSend(INDEXER_UPDATE,
                            new IndexerDomain(INDEXERNAME_FETCH_CR_SCHEDULES, queryObject.get(SCHEDULE_SK).toString(), user.getClientInstance()));
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> updateApprovers(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 0); //1 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(APPROVERS) ? gson.toJson(params) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static Map<String, Object> updateCRDiscussionBoard(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName, User user) throws IOException {

        Map<String, Object> result = new HashMap<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parametrs

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(DISCUSSION_BOARD_SK) ? getValue(params.get(DISCUSSION_BOARD_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(3, params.containsKey(NOTES) ? getDBValidatedValue(params.get(NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(JSON_ATTRIBUTE) ? getDBValidatedValue(params.get(JSON_ATTRIBUTE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(FROM_USER_SK) ? getDBValidatedValue(params.get(FROM_USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(CR_DB_RECIPIENTS) ? gson.toJson(params.get(CR_DB_RECIPIENTS)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CR_DISCUSSION_BOARD, queryObject.get(DISCUSSION_BOARD_SK).toString(), user.getClientInstance()));
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);

        }

        return queryObject;
    }


    public static Map<String, List<String>> fetchUserAccessibleEntities(String userSK, List<String> entityNames, User user) throws Exception {
        Map<String, List<String>> useraccessibleEntities = new HashMap<>();
        UserAccountNGroup userAccountAGroup = new UserAccountNGroup();
        try {
            userAccountAGroup = fetchUserAccountNGroup(null, userSK, user);
            String accountQuery = OPEN_BRACKET + userAccountAGroup.getUserAccounts()
                    .parallelStream()
                    .map(account -> ACCOUNT + COLON + account.get(ACCOUNT))
                    .collect(Collectors.joining(OR)) + CLOSE_BRACKET;
            String groupQuery = userAccountAGroup.getUserGroups()
                    .parallelStream()
                    .map(group -> GROUP_NAME + COLON + group.get(GROUP_NAME))
                    .collect(Collectors.joining(OR));
            String permissionQuery = OPEN_BRACKET + OPEN_BRACKET + USER_SK + COLON + userSK + CLOSE_BRACKET
                    + OR + accountQuery
                    + (StringUtils.isNotBlank(groupQuery) ? (OR + OPEN_BRACKET + groupQuery + CLOSE_BRACKET) : EMPTY)
                    + CLOSE_BRACKET;
            permissionQuery += AND + entityNames.parallelStream()
                    .map(entityName -> ENTITYNAME + COLON + ESCAPE_CHARACTER + entityName + ESCAPE_CHARACTER)
                    .collect(Collectors.joining(OR)) + AND + VIEW + COLON + ONE;

            List<Map<String, Object>> finalResults = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_COM_PERMISSIONS, permissionQuery,
                    null, new String[]{ENTITYNAME, ENTITY_sk},
                    ENTITYNAME + COMMA + ENTITY_sk, null,
                    TRUE, null, NUM_ZERO, Boolean.FALSE, ENTITYNAME + COMMA + ENTITY_sk, user
            );
            useraccessibleEntities = finalResults.stream()
                    .map(e -> new AbstractMap.SimpleEntry<>(e.get(ENTITYNAME), e.get(ENTITY_sk)))
                    .collect(Collectors.groupingBy(o -> o.getKey().toString().toLowerCase(),
                            Collectors.mapping(o ->
                                    o.getValue().toString(), Collectors.toList())));
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, CR_USER_PERMISSIONS, e);
            throw new Exception(e.getLocalizedMessage());
        }
        return useraccessibleEntities;
    }

    public static String fetchAuthQuery(String endpointName, String user_sk, User user) throws Exception {
        Map<String, Object> columnMapping = new HashMap<>();
        if (columnMapping == null && columnMapping.isEmpty()) {
            columnMapping = gson
                    .fromJson(SFInterfaceBase
                                    .fetchTicketJsonfromPath(AUTH_MAPPING_API_JSON_PATH)
                                    .get(endpointName)
                            , Map.class);

        }
        return fetchAuthQuery(endpointName, user_sk, columnMapping, user);
    }

    public static String fetchAuthQuery(String endpointName, String user_sk, Map<String, Object> columnMapping, User user) throws Exception {
        Map<String, List<String>> accessibleEntitySk = new HashMap<>();
        String authQuery = "";
        List<String> entities = new ArrayList<>();
        entities.add(columnMapping.get(ENTITYNAME).toString());
        accessibleEntitySk = SFInterfaceBase.fetchUserAccessibleEntities(user_sk, entities, user);
        List<String> authEntitySks = new ArrayList<>();
        if (accessibleEntitySk != null && !accessibleEntitySk.isEmpty()) {
            authEntitySks = accessibleEntitySk.get(columnMapping.get(ENTITYNAME).toString().toLowerCase());
        }
        if (authEntitySks == null || authEntitySks.isEmpty()) {
            authQuery = columnMapping.get(FIELD_NAME) + COLON + NULL_VALUE;
        } else {
            authQuery = authEntitySks.parallelStream()
                    .map(entitysk -> columnMapping.get(FIELD_NAME) + COLON + entitysk)
                    .collect(Collectors.joining(OR));
        }
        return OPEN_BRACKET + authQuery + CLOSE_BRACKET;
    }


    public static ResponseEntity createTriageMail(TicketModel ticket, String version, String endpoint_Name, User user) throws IOException {

        //To get status_sk for the given entitytype
        List<Map<String, Object>> status = fetchWhooshRecords(INDEXERNAME_FETCH_STATUS, STATUS + COLON + ESCAPE_CHARACTER + "Active" + ESCAPE_CHARACTER + AND + ENTITYTYPE + COLON
                        + ESCAPE_CHARACTER + "INC_Email" + ESCAPE_CHARACTER, null, new String[]{STATUS_SK}, null, null
                , null, null, NUM_ZERO, false, null, 1, null, user);
        Map<String, Object> mailFields = new HashMap<>();
        Map<String, Object> ticketFailureinRflow = new HashMap<>();
        Map<String, Object> resultMap = new HashMap<>();

        //To get Account_sk from the given account
        List<Map<String, Object>> accounts = fetchWhooshRecords(INDEXERNAME_FETCH_ACCOUNT, ACCOUNT + COLON + ticket.getClient().getText(), null,
                new String[]{ACCOUNT_SK, MASTER_ACCOUNT, MASTER_ACCOUNT_SK}, null, null, null, null
                , 0, false, null, 1, null, user);
        // If not a valid user then send a request to INC_email
        List<Map<String, Object>> webuser = new ArrayList<>();
        if (ticket.getUser() != null && ticket.getUser().get("username") != null) {
            webuser = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, NETWORK_LOGIN + COLON + ESCAPE_CHARACTER + ticket.getUser().get("username") + ESCAPE_CHARACTER
                            + AND + ACCOUNT + COLON + ESCAPE_CHARACTER + (ticket.getUser().get("account") != null ?
                            ticket.getUser().get("account") : CTS) + ESCAPE_CHARACTER,
                    null, new String[]{PEOPLEINFO_SK, EMAIL_ADDRESS}, null, null
                    , null, null, NUM_ONE, false, null, 1, null, user);
        }

        mailFields.put(ACCOUNT_SK, accounts.get(0).get(ACCOUNT_SK));
        mailFields.put(SOURCE, "I");
        mailFields.put(TO, ticket.getToemail() != null ? ticket.getToemail() : (ticket.getClient().getText() + SFInterfaceConstants.getOffline_toemailid()));
        mailFields.put(SUBJECT, ticket.getSummary() != null ? ticket.getSummary() : OFFLINE_TICKET_DEFAULT_SUMMARY);
        mailFields.put(MAIL_BODY, ticket.getMailbody());
        mailFields.put(STATUS_SK, status.get(NUM_ZERO).get(STATUS_SK).toString());
        mailFields.put(OFFLINE_UNIQUE_ID, ticket.getGuid());
        //To get User_sk of an webuser, if the user is not valid
        if (webuser.isEmpty()) {
            webuser = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, LOGIN_ID + COLON + ESCAPE_CHARACTER
                            + Constants.getAdminusername() + ESCAPE_CHARACTER, null, new String[]{PEOPLEINFO_SK, EMAIL_ADDRESS}, null, null
                    , null, null, NUM_ZERO, false, null, 1, null, user);
        }
        String fromEmail = webuser.get(NUM_ZERO).get(EMAIL_ADDRESS) != null ? webuser.get(NUM_ZERO).get(EMAIL_ADDRESS).toString() : SFInterfaceConstants.getOfflineemailid();

        mailFields.put(USER_SK, webuser.get(NUM_ZERO).get(PEOPLEINFO_SK));
        mailFields.put(FROM, fromEmail);

        Map<String, Object> endPointDomain = SFInterfaceBase.fetchEndpointDetails(UPDATE_INC_EMAIL, version, POST_METHOD, user);
        String spName = "";
        if (!endPointDomain.containsKey(ERRORCODE)) {
            spName = endPointDomain.get(QUERY).toString();
        }
        ticketFailureinRflow = SFInterfaceBase.updateINCEmailDetails(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), spName, mailFields, UPDATE_INC_EMAIL);
        if (!ticketFailureinRflow.containsKey(ERROR) && ticketFailureinRflow.size() > NUM_ZERO) {
            String tickettemp = ticketFailureinRflow.get("EmailSK").toString();
            resultMap = SFInterfaceServices.getInfoMap("INFO.MESSAGE.NOTAVALIDUSERREQUESTSENTTOINCEMAIL", " " + INCEMAIL_SK + " - " + tickettemp, endpoint_Name);
            resultMap.put(INCEMAIL_SK, tickettemp);
            return new ResponseEntity<>(resultMap, HttpStatus.OK);
        } else {
            resultMap = SFInterfaceServices.getErrorMap("ERROR.MESSAGE.NOTAVALIDUSERREQUESTSENTTOINCEMAIL", null, endpoint_Name);
            return new ResponseEntity<>(resultMap, HttpStatus.FAILED_DEPENDENCY);
        }

    }

    public static ResponseEntity updateOfflineTicket(TicketModel ticket, String version, String endpoint_Name, String accessToken
            , String refreshToken, String aToken, User user) throws Exception {
        Map<String, Object> resultMap = new HashMap<>();
        String workflowresturl = "";
        Map<String, Object> ticketFields = new HashMap<>();
        Map<String, Object> endPointDomain = new HashMap<>();
        Map<String, String[]> inputparams = new HashMap<>();
        String tickettype = null, ticketid = null, ticketnumber = null;
        //3. validate ticket against inc/sr/srt TicketID
        List<Map<String, Object>> ticketidexist = SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()).queryForList(String.format("EXEC API_isEntityIDExist '%s','%s'", ticket.getTicketnumber(), "Ticket"));
        for (Map<String, Object> stringObjectMap : ticketidexist) {
            if (stringObjectMap.get(TICKET_NUMBER) != null && stringObjectMap.get(TICKET_SK) != null) {
                ticketid = stringObjectMap.get(TICKET_SK) != null ? stringObjectMap.get(TICKET_SK).toString() : null;
                ticketnumber = stringObjectMap.get(TICKET_NUMBER) != null ? stringObjectMap.get(TICKET_NUMBER).toString() : null;
                tickettype = stringObjectMap.get(TICKET_TYPE) != null ? stringObjectMap.get(TICKET_TYPE).toString() : null;
            }
        }
        if ((ticketid != null && ticketnumber != null) && tickettype != null) {
            Map<String, Object> inputMapToValidateAPI = new LinkedHashMap<>();
            inputMapToValidateAPI.put(REFERENCE_NUMBER, ticketnumber);
            if (tickettype.equalsIgnoreCase(INCIDENTS)) {
                inputparams.put(TICKET, new String[]{ticketid});
                endPointDomain = SFInterfaceBase.fetchEndpointDetails(INDEXERNAME_FETCH_INCIDENT_SP, version, GET_METHOD, user);
            } else {
                inputparams.put(TICKET, new String[]{ticketid});
                endPointDomain = SFInterfaceBase.fetchEndpointDetails(INDEXERNAME_FETCH_SR_SP, version, GET_METHOD, user);
            }
            String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), inputparams);
            List<Map<String, Object>> ticketrecords = SFInterfaceBase.runjdbcQueryWithSelectedColumns(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), refdbquery
                    , new String[]{TICKET, MASTER_ACCOUNT_SK, ACCOUNT_SK, MASTER_ACCOUNT, (TICKET + ASSIGNED_GROUP_NAME)});

            if (ticketrecords.isEmpty()) {
                throw new Exception("Ticket is in Resolved or Closed Status");
            }
            workflowresturl = SFInterfaceServices.generateWorkflowAPIURL(tickettype) + WF_SUBMIT;
            inputMapToValidateAPI.put(MASTER_ACCOUNT_CODE, ticketrecords.get(0).get(MASTER_ACCOUNT));
            inputMapToValidateAPI.put(APPLICATION_CODE, SFInterfaceConstants.getOffline_ticket_applicationcode());
            ticketFields.put(TICKET_NUMBER, ticketnumber);
            ticketFields.put(TICKETSK, ticketid);
            ticketFields.put(ACCOUNT, ticketrecords.get(0).get(ACCOUNT_SK));
            ticketFields.put(MASTER_ACCOUNT, ticketrecords.get(0).get(MASTER_ACCOUNT_SK));
            ticketFields.put(MASTER_ACCOUNT_CODE, ticketrecords.get(0).get(MASTER_ACCOUNT));
            ticketFields = mapupdateTicketOffline(ticketFields, tickettype, ticket, user);
            inputMapToValidateAPI.put(DATA, ticketFields);
            ObjectMapper mapper = new ObjectMapper();
            mapper.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);
            mapper.enable(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS);

            String jsonString = mapper.writeValueAsString(inputMapToValidateAPI);
            RestTemplate restTemplate = new RestTemplate();
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            if (StringUtils.isNotBlank(accessToken) && StringUtils.isNotBlank(refreshToken)) {
                headers.set(ACCESS_TOKEN, accessToken);
                headers.set(REFRESH_TOKEN, refreshToken);
                headers.set(CLIENT_INSTANCE, user.getClientInstance());
            } else {
                headers.set(A_TOKEN, aToken);
                headers.set(CLIENT_INSTANCE, user.getClientInstance());
            }
            SFInterfaceLoggerBase.log(LOGGER, TICKET, endpoint_Name, NA, NA, NA, NA, NA, jsonString);
            HttpEntity<Object> entity = new HttpEntity<Object>(new ObjectMapper().readValue(jsonString, Object.class), headers);
            SFInterfaceLoggerBase.log(LOGGER, endpoint_Name, jsonString);
            resultMap = restTemplate.postForObject(workflowresturl, entity, HashMap.class);
            if (resultMap.size() > NUM_ZERO && (resultMap.containsKey(ERROR) && StringUtils.isBlank((String) resultMap.get(ERROR)))) {
                String tempticketnumber = resultMap.get(REFERENCE_NUMBER).toString();
                resultMap = SFInterfaceServices.getInfoMap("INFO.MESSAGE.VALIDUSERREQUESTUPDATETORFLOW", " " + TICKET_NUMBER + " = " + tempticketnumber, endpoint_Name);
                resultMap.put(TICKET_NUMBER, tempticketnumber);
                return new ResponseEntity<>(resultMap, HttpStatus.OK);
            } else {
                return SFInterfaceBase.createTriageMail(ticket, version, endpoint_Name, user);
            }
        } else {
            return SFInterfaceBase.createTriageMail(ticket, version, endpoint_Name, user);
        }
    }


    public static Map<String, Object> createCloneCR(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 6); //4 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TICKET_NUMBER) ? getValue(params.get(TICKET_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(TICKET_SK) ? getValue(params.get(TICKET_SK)) : null);
                        callableStatement.setString(3, params.containsKey(CLONED_CR) ? getValue(params.get(CLONED_CR)) : null);
                        callableStatement.setString(4, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateBusinessFunction(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUSINESS_FUNCTION_CODE) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(BUSINESS_FUNCTION) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSource(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SOURCE_SK) ? getValue(params.get(SOURCE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SOURCE_CODE) ? getValue(params.get(SOURCE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(SOURCE_NAME) ? getDBValidatedValue(params.get(SOURCE_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateBusinessTimeDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20); // 11 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BUS_TIME_DETAIL_SK) ? getValue(params.get(BUS_TIME_DETAIL_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BUS_TIME_DETAIL_CODE) ? getValue(params.get(BUS_TIME_DETAIL_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(NAME) ? getDBValidatedValue(params.get(NAME), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(START_TIME) ? getDBValidatedValue(params.get(START_TIME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(END_TIME) ? getDBValidatedValue(params.get(END_TIME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getDBValidatedValue(params.get(STATUS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(HOLIDAY_DATE) ? getValue(params.get(HOLIDAY_DATE)) : null);
                        callableStatement.setString(11, params.containsKey(AVAILABILITY) ? getValue(params.get(AVAILABILITY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateGroupType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(GROUP_TYPE_SK) ? getValue(params.get(GROUP_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(GROUP_TYPE_CODE) ? getValue(params.get(GROUP_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(GROUP_TYPE) ? getDBValidatedValue(params.get(GROUP_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateQueue(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(QUEUE_sk) ? getValue(params.get(QUEUE_sk)) : null);
                        callableStatement.setString(2, params.containsKey(QUEUE_CODE) ? getValue(params.get(QUEUE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(QUEUE) ? getDBValidatedValue(params.get(QUEUE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(PHONE_LINE) ? getDBValidatedValue(params.get(PHONE_LINE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(PRIMARY_NUMBER) ? getDBValidatedValue(params.get(PRIMARY_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(SECONDARY_NUMBER) ? getDBValidatedValue(params.get(SECONDARY_NUMBER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(10, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(11, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(IS_DEFAULT) ? getDBValidatedValue(params.get(IS_DEFAULT), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRCLMapping(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RCL_MAPPING_SK) ? getValue(params.get(RCL_MAPPING_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ROOT_CAUSE_LEVEL_SK) ? getDBValidatedValue(params.get(ROOT_CAUSE_LEVEL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(PARENT_ROOT_CAUSE_LEVEL_SK) ? getDBValidatedValue(params.get(PARENT_ROOT_CAUSE_LEVEL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getDBValidatedValue(params.get(STATUS), DATATYPE_BIT) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRootCauseLevel(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ROOT_CAUSE_LEVEL_SK) ? getValue(params.get(ROOT_CAUSE_LEVEL_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ROOT_CAUSE_LEVEL_CODE) ? getDBValidatedValue(params.get(ROOT_CAUSE_LEVEL_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ROOT_CAUSE) ? getDBValidatedValue(params.get(ROOT_CAUSE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(LEVEL) ? getDBValidatedValue(params.get(LEVEL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateGroupLevel(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(GROUP_LEVEL_SK) ? getValue(params.get(GROUP_LEVEL_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccountRoleUser(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACC_ROLE_USER_SK) ? getValue(params.get(ACC_ROLE_USER_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACC_ROLE_USER_CODE) ? getDBValidatedValue(params.get(ACC_ROLE_USER_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_ROLE_SK) ? getDBValidatedValue(params.get(ACCOUNT_ROLE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(USER_SK) ? getDBValidatedValue(params.get(USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateStatusEntity(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(STATUS_TYPE_SK) ? getDBValidatedValue(params.get(STATUS_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS_CODE) ? getDBValidatedValue(params.get(STATUS_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateStatusEntityType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 4); // 3 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(STATUS_TYPE_SK) ? getValue(params.get(STATUS_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ENTITYCODE) ? getDBValidatedValue(params.get(ENTITYCODE), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateTask(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TASK_SK) ? getValue(params.get(TASK_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_CODE) ? getValue(params.get(TASK_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(TASK) ? getDBValidatedValue(params.get(TASK), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateTaskGroup(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TASK_GROUP_SK) ? getValue(params.get(TASK_GROUP_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_GROUP_CODE) ? getValue(params.get(TASK_GROUP_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(TASK_GROUP) ? getDBValidatedValue(params.get(TASK_GROUP), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(PARENT_SK) ? getDBValidatedValue(params.get(PARENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAutoClose(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(AUTO_CLOSE_SK) ? getValue(params.get(AUTO_CLOSE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(3, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(4, params.containsKey(RESOLUTION) ? getValue(params.get(RESOLUTION)) : null);
                        callableStatement.setString(5, params.containsKey(NOTES) ? getDBValidatedValue(params.get(NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateLdapDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 28); // 15 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(LDAP_DETAILS_SK) ? getValue(params.get(LDAP_DETAILS_SK)) : null);
                        callableStatement.setString(2, params.containsKey(BASE) ? getDBValidatedValue(params.get(BASE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getDBValidatedValue(params.get(ACCOUNT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(CONN_NAME) ? getDBValidatedValue(params.get(CONN_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DOMAIN) ? getDBValidatedValue(params.get(DOMAIN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(FILTER) ? getDBValidatedValue(params.get(FILTER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(HOST) ? getDBValidatedValue(params.get(HOST), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(PASSWORD) ? getDBValidatedValue(params.get(PASSWORD), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(PORT) ? getDBValidatedValue(params.get(PORT), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(SEARCHDN) ? getDBValidatedValue(params.get(SEARCHDN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(USER_NAME) ? getDBValidatedValue(params.get(USER_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(POST_TEXT) ? getDBValidatedValue(params.get(POST_TEXT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(PRE_TEXT) ? getDBValidatedValue(params.get(PRE_TEXT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(SSO) ? getDBValidatedValue(params.get(SSO), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static List<Map<String, Object>> fetchDesignboardforEntity(
            List<Map<String, Object>> crDesignBoard,
            String entityName,
            String entity_sk) {
        if (crDesignBoard == null)
            return crDesignBoard;
        else
            return crDesignBoard.parallelStream()
                    .filter(entitydesignboard -> ((entitydesignboard.get(ENTITYNAME) != null && entitydesignboard.get(ENTITY_sk) != null)
                            && entitydesignboard.get(ENTITYNAME).toString().equalsIgnoreCase(entityName)
                            && entitydesignboard.get(ENTITY_sk).toString().equalsIgnoreCase(entity_sk)))
                    .collect(Collectors.toList());
    }

    public static EndpointValidationModel validateEndpoint(String endpointName
            , Map<String, Object> requestFields, Map<String, String[]> request
    ) throws IOException {
        Map<String, String[]> requestparametermap = new HashMap<>();
        EndpointValidationModel endpointValidationModel = new EndpointValidationModel();
        if (requestFields != null) {
            requestparametermap = convertmapObject(requestFields);
        }
        requestparametermap.putAll(request);

        endpointValidationModel.setRequestparametermap(requestparametermap);

        if (SFInterfaceBase
                .fetchTicketJsonfromPath(AUTH_MAPPING_API_JSON_PATH)
                .get(endpointName) != null) {
            endpointValidationModel.setAuth_endpoint(true);
            endpointValidationModel.setAuth_columnMapping(gson
                    .fromJson(SFInterfaceBase
                                    .fetchTicketJsonfromPath(AUTH_MAPPING_API_JSON_PATH)
                                    .get(endpointName)
                            , Map.class));
        }
        List empty_validation_whitelistedendpoints = gson
                .fromJson(SFInterfaceBase
                        .fetchTicketJsonfromPath(WHITELISTED_API_JSON_PATH)
                        .get("EMPTYVALIDATION_WHITELISTED_API")
                        .getAsJsonArray(), List.class);

        List mandatory_params_whitelistedendpoints = gson
                .fromJson(SFInterfaceBase
                        .fetchTicketJsonfromPath(WHITELISTED_API_JSON_PATH)
                        .get("WHITELISTED_API")
                        .getAsJsonArray(), List.class);

        List null_records_fetch_whiltelistedendpoints = gson
                .fromJson(SFInterfaceBase
                        .fetchTicketJsonfromPath(WHITELISTED_API_JSON_PATH)
                        .get("FETCH_NULL_RECORDS_IF_EMPTY_ENDPOINTS")
                        .getAsJsonArray(), List.class);

        if (mandatory_params_whitelistedendpoints.contains(endpointName)) {
            endpointValidationModel.setMandatoryParams_Whitelisted(true);
        }
        if (empty_validation_whitelistedendpoints.contains(endpointName)) {
            endpointValidationModel.setEmptyParams_Whitelisted(true);
        }
        if (null_records_fetch_whiltelistedendpoints.contains(endpointName)) {
            endpointValidationModel.setFetch_null_records_endpoint_Whitelisted(true);
        }

        if (requestparametermap != null) {
            endpointValidationModel.setMissingParam_Value(
                    requestparametermap.entrySet()
                            .stream()
                            .anyMatch(stringEntry -> {
                                        if ((stringEntry.getValue() == null)
                                                || Arrays.asList(stringEntry.getValue())
                                                .parallelStream()
                                                .anyMatch(s -> StringUtils.isBlank(s))) {
                                            endpointValidationModel.setMissingParam_name(stringEntry.getKey());
                                            return true;
                                        }
                                        return false;
                                    }
                            ));
        }
        return endpointValidationModel;
    }

    public static Object[] convertListtoarray(List list) {
        return list.toArray();
    }

    public static String[] convertListtostringarray(List<String> list) {
        return list.toArray(new String[0]);
    }

    public static String[] removevaluefromArray(String[] array, String value) {
        if (array == null) {
            return null;
        }
        List<String> list = new ArrayList<String>(Arrays.asList(array));
        list.remove(value);
        if (list.isEmpty())
            return null;
        return list.toArray(new String[0]);
    }


    public static void configureproxy() {
        System.setProperty("https.proxyHost", "10.1.9.61");
        System.setProperty("https.proxyPort", "8080");
        System.setProperty("http.proxyHost", "10.1.9.61");
        System.setProperty("http.proxyPort", "8080");
        System.setProperty("java.net.socks.username", "kvivek");
        System.setProperty("java.net.socks.password", "12345Welcome@");
    }

    public static void throwException(String exception) throws Exception {
        throw new Exception(exception);
    }

    //checks whether CR and type is draft if so provides businessfunction of DFT
    public static String fetchbusinessfunction_sk(Map<String, Object> ticketFields, User user) {
        String businessfunction_sk = ticketFields.containsKey(BUSINESS_FUNCTION_SK) ? (String) ticketFields.get(BUSINESS_FUNCTION_SK) : (String) ticketFields.get(BUSINESS_FUNCTION);
        List<Map<String, Object>> result = new ArrayList<>();
        if (StringUtils.isNotBlank(businessfunction_sk) && ticketFields.containsKey(TYPE)) { //specific for CR
            result = fetchWhooshRecords(INDEXERNAME_FETCH_BUSINESSFUNCTION,
                    BUSINESS_FUNCTION_SK + COLON + businessfunction_sk
                            + AND + BUSINESS_FUNCTION_CODE + COLON + CR
                    , null, new String[]{BUSINESS_FUNCTION_CODE}, null, null, null
                    , null, NUM_ZERO, user);
            if (!result.isEmpty()) {        //if CR based on type return businessfunction_sk
                String type = "";
                if (ticketFields.get(TYPE).toString().equalsIgnoreCase("T")) {
                    type = "TMP";
                } else {
                    type = (String) ticketFields.get(TYPE);
                }
                result = fetchWhooshRecords(INDEXERNAME_FETCH_BUSINESSFUNCTION,
                        BUSINESS_FUNCTION_CODE + COLON + type
                        , null, new String[]{BUSINESS_FUNCTION_SK}, null, null, null
                        , null, NUM_ZERO, user);
                if (!result.isEmpty()) {
                    businessfunction_sk = result.get(NUM_ZERO).get(BUSINESS_FUNCTION_SK).toString();
                }
            }
        }
        return businessfunction_sk;
    }

    public static List<Map<String, Object>> updateBuildingDepartment(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(BUILDING_DEPARTMENT) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }


    public static List<Map<String, Object>> fetchComActionItems(String entityName, String entity_sk
            , String endpoint, String version
            , String[] requiredColumns, User user) throws IOException {
        Map<String, Object> endPointDomain = new HashMap<>();
        endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpoint, version, GET_METHOD, user);
        Map<String, String[]> parameter = new HashMap<>();
        parameter.put(ENTITYNAME, new String[]{entityName});
        parameter.put(ENTITY_sk, new String[]{entity_sk});
        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), parameter);
        return SFInterfaceBase.runjdbcQueryWithSelectedColumns(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), refdbquery
                , requiredColumns);
    }

    public static List<Map<String, Object>> fetchADFSDetails(
            String account, String version
            , String[] requiredColumns, User user) {
        return SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_ADFS_CONFIGURATION
                , OPEN_BRACKET + ACCOUNT + COLON + account + OR + MASTER_ACCOUNT + COLON + account + CLOSE_BRACKET
                        + AND + STATUS + COLON + NUM_ONE
                , null, requiredColumns, null, null, null, null, NUM_ZERO, user);

    }

    public static List<Map<String, Object>> fetchProfileDetails(
            String account, String networkLogin
            , String[] requiredColumns, User user) {
        return fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE
                , NETWORK_LOGIN + COLON + ESCAPE_CHARACTER + networkLogin + ESCAPE_CHARACTER +
                        AND + OPEN_BRACKET + ACCOUNT + COLON + account + OR + MASTER_ACCOUNT + COLON + account + CLOSE_BRACKET
                , null, requiredColumns
                , null, null, null, null, NUM_ZERO, user);

    }

    public static Response fetchSamlResponse(String samlToken) throws ParserConfigurationException, InitializationException, IOException, SAXException, UnmarshallingException {
        byte[] base64DecodedResponse = Base64.getDecoder().decode(samlToken);
        ByteArrayInputStream is = new ByteArrayInputStream(base64DecodedResponse);
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setNamespaceAware(true);
        DocumentBuilder docBuilder = documentBuilderFactory.newDocumentBuilder();
        InitializationService.initialize();
        org.w3c.dom.Document document = docBuilder.parse(is);
        Element element = document.getDocumentElement();

        UnmarshallerFactory unmarshallerFactory = XMLObjectProviderRegistrySupport.getUnmarshallerFactory();
        Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);
        assert unmarshaller != null;
        XMLObject responseXmlObj = unmarshaller.unmarshall(element);
        return (Response) responseXmlObj;
    }

    public static OAuth2AccessToken createaccessToken(String userName,
                                                      String user_sk,
                                                      String account
            , HttpServletRequest req) throws HttpRequestMethodNotSupportedException {
        UsernamePasswordAuthenticationToken authReq
                = new UsernamePasswordAuthenticationToken("ctssp", "secret", null);
        Map<String, String> parameters = new HashMap<>();
        parameters.put("grant_type", "password");
        parameters.put("password", "");
        parameters.put("username", userName);
        parameters.put("client", account);
        parameters.put("auth_type", "adfs");
        parameters.put("code", "adfs");

        return tokenEndpoint.postAccessToken(authReq, parameters).getBody();

    }

    public static String failedURL(String url, String account, String message) {
        return "adfs/failure";
        //return REDIRECT_URL + url + account + "?msg=" + message;
    }

    public static String unauthorizedURL(String account, String message) {
        return "unauthorized";
        //return REDIRECT_URL + url + account + "?msg=" + message;
    }

    public static String adfsLogoutURL(String url) {
        return "adfs/logout";
        //return REDIRECT_URL + url + account + "?msg=" + message;
    }

    public static String validateAndreturnPage(String successPage, HttpServletRequest request) {
        try {
            User user = SFInterfaceConnectionBase.fetchRequestInfo(request);
            if (user.getUserID() != null) {
                request.getSession().setAttribute(LOGIN_ID, user.getUserID());
                request.getSession().setAttribute(ACCESS_TOKEN, request.getHeaders(ACCESS_TOKEN));
                return successPage;
            } else if (request.getSession().getAttribute(LOGIN_ID) != null) {
                return successPage;
            } else {
                return unauthorizedURL(null, null);
            }
        } catch (Exception e) {
            LOGGER.error(e);
            return unauthorizedURL(null, null);
        }
        //return REDIRECT_URL + url + account + "?msg=" + message;
    }


    public static List<Map<String, Object>> updateBuildingSuite(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(BUILDING_SUITE) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateDepartmentFloor(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(DEPARTMENT_FLOOR) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateBuildingFloor(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(BUILDING_FLOOR) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateDepartmentSuite(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(DEPARTMENT_SUITE) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateBuildingCategory(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(BUILDING_CATEGORY) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static Map<String, Object> updateCRLocations(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CR_LOCATION_SK) ? getValue(params.get(CR_LOCATION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_LOCATION_CODE) ? getValue(params.get(CR_LOCATION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CR_LOCATIONS) ? getValue(params.get(CR_LOCATIONS)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAlertAccountRel(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ALERT_ACC_REL_SK) ? getValue(params.get(ALERT_ACC_REL_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ALERT_SK) ? getDBValidatedValue(params.get(ALERT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(NOTIFICATION_TEMPLATE) ? getDBValidatedValue(params.get(NOTIFICATION_TEMPLATE), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateContactType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CONTACT_TYPE_SK) ? getValue(params.get(CONTACT_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CONTACT_TYPE_CODE) ? getValue(params.get(CONTACT_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CONTACT_TYPE) ? getDBValidatedValue(params.get(CONTACT_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateObjects(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 32); // 17 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(OBJECT_SK) ? getValue(params.get(OBJECT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(OBJECT_CODE) ? getValue(params.get(OBJECT_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(PARENT_OBJECT_SK) ? getDBValidatedValue(params.get(PARENT_OBJECT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(OBJECT) ? getDBValidatedValue(params.get(OBJECT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DISPLAYNAME) ? getDBValidatedValue(params.get(DISPLAYNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(OBJECT_URL) ? getDBValidatedValue(params.get(OBJECT_URL), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(10, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(11, params.containsKey(OBJECT_TYPE) ? getDBValidatedValue(params.get(OBJECT_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(THUMBNAIL_URL) ? getDBValidatedValue(params.get(THUMBNAIL_URL), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(SORT_ORDER) ? getDBValidatedValue(params.get(SORT_ORDER), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(NAV_ICON) ? getDBValidatedValue(params.get(NAV_ICON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(CSS_CLASS_1) ? getDBValidatedValue(params.get(CSS_CLASS_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(TARGET) ? getDBValidatedValue(params.get(TARGET), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(17, params.containsKey(JSON_ATTRIBUTE) ? getDBValidatedValue(params.get(JSON_ATTRIBUTE), DATATYPE_VARCHAR) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);

                if (queryObject.containsKey(OBJECT_SK)) {
                    String updatedKey = fetchAlternateKeyIndexerJsonfromPath(INDEXERNAME_FETCH_OBJECT_PERMISSIONS, OBJECT_SK);
                    IndexerDomain indexerDomain = new IndexerDomain(INDEXERNAME_FETCH_OBJECT_PERMISSIONS, queryObject.get(OBJECT_SK).toString(), user.getClientInstance());
                    indexerDomain.setIndexerkey(updatedKey);
                    jmsTemplate.convertAndSend(INDEXER_UPDATE, indexerDomain);
                }
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBTypeAheadCategories(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TYPE_AHEAD_CATEGORIES_SK) ? getValue(params.get(TYPE_AHEAD_CATEGORIES_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(TYPE_AHEAD_CATEGORY) ? getValue(params.get(TYPE_AHEAD_CATEGORY)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(ARTICLE_TYPE_SK) ? getDBValidatedValue(params.get(ARTICLE_TYPE_SK), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateGeoCity(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CITY_SK) ? getValue(params.get(CITY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CITY_CODE) ? getDBValidatedValue(params.get(CITY_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(CITY) ? getDBValidatedValue(params.get(CITY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(COUNTRY_SK) ? getDBValidatedValue(params.get(COUNTRY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATE_SK) ? getDBValidatedValue(params.get(STATE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateGeoCountry(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(COUNTRY_SK) ? getValue(params.get(COUNTRY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(COUNTRY_CODE) ? getDBValidatedValue(params.get(COUNTRY_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(TELEPHONIC_CODE) ? getDBValidatedValue(params.get(TELEPHONIC_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(COUNTRY_SHORT_CODE) ? getDBValidatedValue(params.get(COUNTRY_SHORT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(COUNTRY) ? getDBValidatedValue(params.get(COUNTRY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateGeoState(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(STATE_SK) ? getValue(params.get(STATE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(STATE_POSTAL_CODE) ? getDBValidatedValue(params.get(STATE_POSTAL_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(STATE_CODE) ? getDBValidatedValue(params.get(STATE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(STATE) ? getDBValidatedValue(params.get(STATE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(COUNTRY_SK) ? getDBValidatedValue(params.get(COUNTRY_SK), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateEntity(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ENTITY_sk) ? getValue(params.get(ENTITY_sk)) : null);
                        callableStatement.setString(2, params.containsKey(ENTITYNAME) ? getValue(params.get(ENTITYNAME)) : null);
                        callableStatement.setString(3, params.containsKey(NAME) ? getValue(params.get(NAME)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(TYPE) ? getDBValidatedValue(params.get(TYPE), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBArticleType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ARTICLE_TYPE_SK) ? getValue(params.get(ARTICLE_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(LEVEL) ? getValue(params.get(LEVEL)) : null);
                        callableStatement.setString(3, params.containsKey(NAME) ? getValue(params.get(NAME)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBContentType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 8); // 5 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CONTENT_TYPE_SK) ? getValue(params.get(CONTENT_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CONTENT_TYPE) ? getValue(params.get(CONTENT_TYPE)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(4, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(5, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBDocContentType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(DOC_CONTENT_TYPE_SK) ? getValue(params.get(DOC_CONTENT_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(DOCUMENT_TYPE_SK) ? getValue(params.get(DOCUMENT_TYPE_SK)) : null);
                        callableStatement.setString(3, params.containsKey(CONTENT_TYPE_SK) ? getValue(params.get(CONTENT_TYPE_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateKBDocumentType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 8); // 5 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(DOCUMENT_TYPE_SK) ? getValue(params.get(DOCUMENT_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(DOCUMENT_TYPE) ? getValue(params.get(DOCUMENT_TYPE)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(4, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(5, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateObjectPermissions(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 24); // 13 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(OBJECT_PERMISSION_SK) ? getValue(params.get(OBJECT_PERMISSION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(OBJECT_SK) ? getValue(params.get(OBJECT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(USER_SK) ? getDBValidatedValue(params.get(USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(VIEW) ? getValue(params.get(VIEW)) : null);
                        callableStatement.setString(7, params.containsKey(ADD) ? getValue(params.get(ADD)) : null);
                        callableStatement.setString(8, params.containsKey(EDIT) ? getValue(params.get(EDIT)) : null);
                        callableStatement.setString(9, params.containsKey(DELETE) ? getValue(params.get(DELETE)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(12, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> UpdateRDYKBPhraseDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(KBPhraseDetails_sk) ? getValue(params.get(KBPhraseDetails_sk)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(CTI_SK) ? getValue(params.get(CTI_SK)) : null);
                        callableStatement.setString(4, params.containsKey(KBPHRASES_SK) ? getDBValidatedValue(params.get(KBPHRASES_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(6, params.containsKey(RDY_MAPPING_SK) ? getValue(params.get(RDY_MAPPING_SK)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> UpdateSkillSet(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(Skillset_sk) ? getValue(params.get(Skillset_sk)) : null);
                        callableStatement.setString(2, params.containsKey(SkillsetCode) ? getDBValidatedValue(params.get(SkillsetCode), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(NAME) ? getDBValidatedValue(params.get(NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> UpdateTitle(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(TITLE_SK) ? getValue(params.get(TITLE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TITLE_CODE) ? getDBValidatedValue(params.get(TITLE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(NAME) ? getDBValidatedValue(params.get(NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRDYQueriesDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RDY_QUERY_SK) ? getValue(params.get(RDY_QUERY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(RDY_MAPPING_SK) ? getDBValidatedValue(params.get(RDY_MAPPING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(KB_PHRASES_SK) ? getDBValidatedValue(params.get(KB_PHRASES_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(QUESTION_SK) ? getValue(params.get(QUESTION_SK)) : null);
                        callableStatement.setString(5, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(JSON_QUESTION) ? getDBValidatedValue(params.get(JSON_QUESTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(CONTROL_SK) ? getDBValidatedValue(params.get(CONTROL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(ENTITYNAME) ? getDBValidatedValue(params.get(ENTITYNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(ENTITY_sk) ? getDBValidatedValue(params.get(ENTITY_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRDYRootCauseDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RDY_ROOTCAUSE_SK) ? getValue(params.get(RDY_ROOTCAUSE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(RDY_MAPPING_SK) ? getValue(params.get(RDY_MAPPING_SK)) : null);
                        callableStatement.setString(3, params.containsKey(RCL_MAPPING_SK) ? getValue(params.get(RCL_MAPPING_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> updateEntityLink(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ENTITY_LINK) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static List<Map<String, Object>> updateLinks(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, NUM_ZERO);

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(LINKS) ? gson.toJson(params) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                result = (List<Map<String, Object>>) resultMap.get(RESULT_SET_1);
                return result;
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            result.add(queryObject);
        }

        return result;
    }

    public static Map<String, Object> updateAssetCategory(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CATEGORY_SK) ? getValue(params.get(CATEGORY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(CATEGORY_CODE) ? getDBValidatedValue(params.get(CATEGORY_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(CATEGORY) ? getDBValidatedValue(params.get(CATEGORY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAssetAttachment(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); // 10 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ATTACHMENT_SK) ? getValue(params.get(ATTACHMENT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ATTACHMENT_CODE) ? getDBValidatedValue(params.get(ATTACHMENT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ATTACHMENT_NAME) ? getDBValidatedValue(params.get(ATTACHMENT_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ENTITY_sk) ? getDBValidatedValue(params.get(ENTITY_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ENTITYNAME) ? getDBValidatedValue(params.get(ENTITYNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(PATH) ? getDBValidatedValue(params.get(PATH), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(FILE_SIZE) ? getDBValidatedValue(params.get(FILE_SIZE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(9, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAssetProcurement(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20); // 11 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(PROCUREMENT_SK1) ? getValue(params.get(PROCUREMENT_SK1)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(PROCUREMENT_CODE) ? getDBValidatedValue(params.get(PROCUREMENT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(CATEGORY_SK) ? getDBValidatedValue(params.get(CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(EQUIPMENT) ? getDBValidatedValue(params.get(EQUIPMENT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(PRICE) ? getDBValidatedValue(params.get(PRICE), DATATYPE_FLOAT) : null);
                        callableStatement.setString(8, params.containsKey(SORT_ORDER) ? getDBValidatedValue(params.get(SORT_ORDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAssetProcurementDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 20); // 11 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(PROCUREMENT_DETAILS_SK1) ? getValue(params.get(PROCUREMENT_DETAILS_SK1)) : null);
                        callableStatement.setString(2, params.containsKey(PROCUREMENT_SK1) ? getDBValidatedValue(params.get(PROCUREMENT_SK1), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(PROCUREMENT_DETAILS_CODE) ? getDBValidatedValue(params.get(PROCUREMENT_DETAILS_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(CHILDEQUIPMENTNAME) ? getDBValidatedValue(params.get(CHILDEQUIPMENTNAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(PRICE) ? getDBValidatedValue(params.get(PRICE), DATATYPE_FLOAT) : null);
                        callableStatement.setString(7, params.containsKey(SORT_ORDER) ? getDBValidatedValue(params.get(SORT_ORDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(IS_REQUIRED) ? getValue(params.get(IS_REQUIRED)) : null);
                        callableStatement.setString(9, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRCabMember(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CAB_MEMBER_SK) ? getValue(params.get(CAB_MEMBER_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getDBValidatedValue(params.get(USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRRequestType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CR_REQUEST_TYPE_SK) ? getValue(params.get(CR_REQUEST_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(CR_REQUEST_TYPE_CODE) ? getDBValidatedValue(params.get(CR_REQUEST_TYPE_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CR_REQUEST_TYPE) ? getDBValidatedValue(params.get(CR_REQUEST_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(ORDER) ? getDBValidatedValue(params.get(ORDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_CRREQUESTTYPE, queryObject.get(CR_REQUEST_TYPE_SK).toString(), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRMilestone(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(MILESTONE_SK) ? getValue(params.get(MILESTONE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(MILESTONE_CODE) ? getValue(params.get(MILESTONE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(MILESTONE) ? getDBValidatedValue(params.get(MILESTONE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(TASK_TYPE_SK) ? getDBValidatedValue(params.get(TASK_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCRProject(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(PROJECT_SK) ? getValue(params.get(PROJECT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PROJECT_CODE) ? getDBValidatedValue(params.get(PROJECT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(PROJECT_NAME) ? getDBValidatedValue(params.get(PROJECT_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_PROJECT, queryObject.get(PROJECT_SK).toString(), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSlmAgreementType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(AGREEMENT_TYPE_SK) ? getValue(params.get(AGREEMENT_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(AGREEMENT_TYPE_CODE) ? getValue(params.get(AGREEMENT_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(AGREEMENT_TYPE) ? getValue(params.get(AGREEMENT_TYPE)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateOPSBOTAlerts(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ALERT_SK) ? getValue(params.get(ALERT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ALERT_NAME) ? getValue(params.get(ALERT_NAME)) : null);
                        callableStatement.setString(3, params.containsKey(NOTIFICATION_TEMPLATE) ? getDBValidatedValue(params.get(NOTIFICATION_TEMPLATE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ALERT_CODE) ? getValue(params.get(ALERT_CODE)) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSlmDefintion(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 46); // 24 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SLM_DEFINTION_SK) ? getValue(params.get(SLM_DEFINTION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SLM_DEFINTION_CODE) ? getValue(params.get(SLM_DEFINTION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(SLM_DEFINTION) ? getValue(params.get(SLM_DEFINTION)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(7, params.containsKey(GOAL_TYPE_SK) ? getValue(params.get(GOAL_TYPE_SK)) : null);
                        callableStatement.setString(8, params.containsKey(AGREEMENT_TYPE_SK) ? getValue(params.get(AGREEMENT_TYPE_SK)) : null);
                        callableStatement.setString(9, params.containsKey(EFFECTIVE_FROM) ? getValue(params.get(EFFECTIVE_FROM)) : null);
                        callableStatement.setString(10, params.containsKey(EFFECTIVE_TO) ? getDBValidatedValue(params.get(EFFECTIVE_TO), DATATYPE_DATETIME) : null);
                        callableStatement.setString(11, params.containsKey(GOAL_HOURS) ? getDBValidatedValue(params.get(GOAL_HOURS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(GOAL_MINUTES) ? getDBValidatedValue(params.get(GOAL_MINUTES), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(WARNING_PERCENTAGE) ? getDBValidatedValue(params.get(WARNING_PERCENTAGE), DATATYPE_FLOAT) : null);
                        callableStatement.setString(14, params.containsKey(IS_RESTART_DEFINITION) ? getValue(params.get(IS_RESTART_DEFINITION)) : null);
                        callableStatement.setString(15, params.containsKey(IS_REOPEN_DEFINITION) ? getValue(params.get(IS_REOPEN_DEFINITION)) : null);
                        callableStatement.setString(16, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(17, params.containsKey(USE_BUSINESS_HOURS) ? getValue(params.get(USE_BUSINESS_HOURS)) : null);
                        callableStatement.setString(18, params.containsKey(SLA_NOTES) ? getDBValidatedValue(params.get(SLA_NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(19, params.containsKey(TERMS_AND_CONDITIONS) ? getDBValidatedValue(params.get(TERMS_AND_CONDITIONS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(20, params.containsKey(RUN_WHILE) ? getDBValidatedValue(params.get(RUN_WHILE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(21, params.containsKey(PAUSE_WHEN) ? getDBValidatedValue(params.get(PAUSE_WHEN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(22, params.containsKey(STOP_WHEN) ? getDBValidatedValue(params.get(STOP_WHEN), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(23, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static String generateQuery(Map<String, Object> ticketfields, String endpointName, String account_sk, User user) throws Exception {
        String insertquery = "", updatequery = "", finalquery = "", selectquery = "";
        Map<String, Object> endPointDomain = new HashMap<>();
        endPointDomain = SFInterfaceBase.fetchEndpointDetails("EntityLink", V1, GET_METHOD, user);

        Map<String, String[]> params = new HashMap<>();
        params.put(ACCOUNT, new String[]{account_sk});
        params.put(LINK_NAME, new String[]{endpointName});

        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), params);
        List<Map<String, Object>> results = runjdbcQueryWithSelectedColumns(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), refdbquery, new String[]{ENTITYNAME});
        if (results.isEmpty()) {
            throw new Exception("EntityLink Endpoint Not Found!");
        } else {
            endpointName = results
                    .stream()
                    .filter(stringObjectMap -> stringObjectMap.get(ENTITYNAME) != null)
                    .limit(1)
                    .map(stringObjectMap -> stringObjectMap.get(ENTITYNAME).toString())
                    .collect(Collectors.joining());
            if (StringUtils.isBlank(endpointName)) {
                throw new Exception("EntityLink Endpoint Not Found!");
            }

        }
        Map<String, Object> mappingjson = SFInterfaceBase.fetchValuefromTableMapping(endpointName.toLowerCase());
        if (mappingjson == null || mappingjson.isEmpty()) {
            throw new Exception("Link Mapping Not Found!");
        }
        ticketfields = fetchInsertUpdateJson(ticketfields, mappingjson);
        insertquery = generateInsertQuery((List<Map<String, Object>>) ticketfields.get("insert"), mappingjson);
        updatequery = generateUpdateQuery((List<Map<String, Object>>) ticketfields.get("update"), mappingjson);
        selectquery = generateselectQuery((List<Map<String, Object>>) ticketfields.get("update"), mappingjson);
        finalquery = generateconsolidatedQuery(insertquery, updatequery, selectquery);
        return finalquery;
    }

    public static String generateQueryEntity(Map<String, Object> ticketfields, String endpointName, String account_sk) throws Exception {
        String insertquery = "", updatequery = "", finalquery = "", selectquery = "";

        Map<String, Object> mappingjson = SFInterfaceBase.fetchValuefromTableMapping(endpointName.toLowerCase());
        if (mappingjson == null || mappingjson.isEmpty()) {
            throw new Exception("Link Mapping Not Found!");
        }
        ticketfields = fetchInsertUpdateJson(ticketfields, mappingjson);
        insertquery = generateInsertQuery((List<Map<String, Object>>) ticketfields.get("insert"), mappingjson);
        updatequery = generateUpdateQuery((List<Map<String, Object>>) ticketfields.get("update"), mappingjson);
        selectquery = generateselectQuery((List<Map<String, Object>>) ticketfields.get("update"), mappingjson);
        finalquery = generateconsolidatedQuery(insertquery, updatequery, selectquery);
        return finalquery;
    }

    public static Map<String, Object> fetchInsertUpdateJson(Map<String, Object> ticketfields,
                                                            Map<String, Object> mappingjson) {
        //based on primary key split into insert or update
        String primarykey = (String) mappingjson.get("primarykey");
        List<Map<String, Object>> ticketfieldss = (List<Map<String, Object>>) ticketfields.get(mappingjson.get("arrayname"));
        List<Map<String, Object>> updatejson = ticketfieldss.parallelStream()
                .filter(stringObjectMap -> stringObjectMap.containsKey(primarykey)
                        &&
                        (StringUtils.isNotBlank((String) stringObjectMap.get(primarykey))))
                .collect(Collectors.toList());
        List<Map<String, Object>> insertjson = ticketfieldss.parallelStream()
                .filter(stringObjectMap -> !stringObjectMap.containsKey(primarykey)
                        ||
                        (StringUtils.isBlank((String) stringObjectMap.get(primarykey))))
                .collect(Collectors.toList());
        ticketfields.put("insert", insertjson);
        ticketfields.put("update", updatejson);
        return ticketfields;
    }

    public static Map<String, Object> codeValidation(Map<String, Object> ticketfields) {
        //validate and append code generation

        return ticketfields;
    }

    public static String generateInsertQuery(List<Map<String, Object>> insertJson, Map<String, Object> mappingJson) {
        StringBuilder insertQuery = new StringBuilder("");
        String primarykey = (String) mappingJson.get("primarykey");
        if (insertJson != null && mappingJson.get("fields") != null) {
            String tablename = (String) mappingJson.get("tablename");
            String createdon = (String) mappingJson.get("createdon");
            insertJson.stream()
                    .forEach(stringObjectMap -> {
                        String query = "";
                        String columnName = "";
                        String values = "";
                        columnName = ((List<String>) mappingJson.get("fields")).stream()
                                .filter(field -> !field.equalsIgnoreCase(MODIFIED_BY))
                                .filter(field -> stringObjectMap.containsKey(field))
                                .map(s -> OPEN_SQUARE_BRACKET + s + CLOSE_SQUARE_BRACKET
                                ).collect(Collectors.joining(COMMA));
                        values = ((List<String>) mappingJson.get("fields")).stream()
                                .filter(field -> !field.equalsIgnoreCase(MODIFIED_BY))
                                .filter(field -> stringObjectMap.containsKey(field))
                                .map(s -> (String) (StringUtils.isNotBlank((String) stringObjectMap.get(s))
                                                ?
                                                (SINGLE_QUOTE + stringObjectMap.get(s) + SINGLE_QUOTE)
                                                :
                                                null
                                        )
                                ).collect(Collectors.joining(COMMA));
                        query = ESCAPE_CHARACTER_TAB + " INSERT INTO " + tablename + EMPTY + OPEN_BRACKET + columnName + COMMA + createdon + CLOSE_BRACKET + ESCAPE_CHARACTER_NEWLINE
                                + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + " OUTPUT inserted." + primarykey + " INTO @identity (ID)" + ESCAPE_CHARACTER_NEWLINE
                                + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + " VALUES " + OPEN_BRACKET + values + COMMA + GETUTC_DATE + CLOSE_BRACKET + SEMI_COLON + ESCAPE_CHARACTER_NEWLINE;
                        insertQuery.append(query);
                    });
        } else {
            return EMPTY;
        }
        return insertQuery.toString();
    }

    public static String generateUpdateQuery(List<Map<String, Object>> updateJson, Map<String, Object> mappingJson) {
        String primarykey = (String) mappingJson.get("primarykey");
        StringBuilder updateQuery = new StringBuilder("");
        if (updateJson != null && mappingJson.get("fields") != null) {
            String tablename = (String) mappingJson.get("tablename");
            String modifiedon = (String) mappingJson.get("modifiedon");
            updateJson.stream()
                    .forEach(stringObjectMap -> {
                        final String[] columnName = {""};
                        final String[] values = {""};
                        String query = ((List<String>) mappingJson.get("fields")).stream()
                                .filter(field -> !field.equalsIgnoreCase(CREATED_BY))
                                .filter(field -> stringObjectMap.containsKey(field))
                                .map(s ->
                                        EMPTY + OPEN_SQUARE_BRACKET + s + CLOSE_SQUARE_BRACKET + EQUAL +
                                                (StringUtils.isNotBlank((String) stringObjectMap.get(s)) ?
                                                        (SINGLE_QUOTE + stringObjectMap.get(s) + SINGLE_QUOTE) : null)
                                )
                                .collect(Collectors.joining(COMMA));
                        query = ESCAPE_CHARACTER_TAB + " UPDATE " + tablename + EMPTY + ESCAPE_CHARACTER_NEWLINE
                                + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + " SET " + query + COMMA + modifiedon + EQUAL + GETUTC_DATE + ESCAPE_CHARACTER_NEWLINE
                                + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + "OUTPUT inserted." + primarykey + " INTO @identity (ID)" + ESCAPE_CHARACTER_NEWLINE
                                + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + WHERE + EMPTY + primarykey + EQUAL + stringObjectMap.get(primarykey) + EMPTY + SEMI_COLON + ESCAPE_CHARACTER_NEWLINE;
                        updateQuery.append(query);
                    });
        } else {
            return EMPTY;
        }
        return updateQuery.toString();
    }

    public static String generateselectQuery(List<Map<String, Object>> updateJson, Map<String, Object> mappingJson) {
        StringBuilder updateQuery = new StringBuilder("");
        if (updateJson != null && mappingJson.get("fields") != null) {
            String tablename = (String) mappingJson.get("tablename");
            String primarykey = (String) mappingJson.get("primarykey");
            updateQuery.append(ESCAPE_CHARACTER_TAB + " SELECT " + primarykey + ",1 AS Status From " + tablename + " WITH (NOLOCK)" + ESCAPE_CHARACTER_NEWLINE +
                    ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + ESCAPE_CHARACTER_TAB + "WHERE " + primarykey + " in (SELECT ID FROM @identity)" + ESCAPE_CHARACTER_NEWLINE);
        } else {
            return EMPTY;
        }
        return updateQuery.toString();
    }

    public static String generateconsolidatedQuery(String insertquery, String updatequery, String selectquery) {
        StringBuilder updateQuery = new StringBuilder("");
        if (insertquery != null || updatequery != null) {

            String startquery = "DECLARE @identity TABLE(ID INT);" + ESCAPE_CHARACTER_NEWLINE
                    + ESCAPE_CHARACTER_TAB + "BEGIN TRANSACTION T1" + ESCAPE_CHARACTER_NEWLINE
                    + ESCAPE_CHARACTER_TAB + "BEGIN TRY" + ESCAPE_CHARACTER_NEWLINE;
            String endquery = ESCAPE_CHARACTER_TAB + "COMMIT TRANSACTION T1" + ESCAPE_CHARACTER_NEWLINE +
                    ESCAPE_CHARACTER_TAB + "END TRY" + ESCAPE_CHARACTER_NEWLINE +
                    ESCAPE_CHARACTER_TAB + "BEGIN CATCH\t" + ESCAPE_CHARACTER_NEWLINE +
                    ESCAPE_CHARACTER_TAB + "ROLLBACK TRANSACTION T1" + ESCAPE_CHARACTER_NEWLINE +
                    ESCAPE_CHARACTER_TAB + "SELECT ISNULL(ERROR_MESSAGE(),'') As Error,-1 as Status" + ESCAPE_CHARACTER_NEWLINE +
                    ESCAPE_CHARACTER_TAB + "END CATCH";

            return updateQuery.append(startquery + insertquery + updatequery + selectquery + endquery).toString();
        } else {
            return EMPTY;
        }
    }


    public static List<Map<String, Object>> returnQueryresult(String query, String endpointName, User user) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        List<Map<String, Object>> resultMap = new ArrayList<>();
        try {
            resultMap = SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()).queryForList(query);
        } catch (Exception e) {
            resultMap.clear();
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            resultMap.add(queryObject);
        }

        return resultMap;
    }


    public static Map<String, Object> createDmartAccount(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 36); // 19 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(2, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_NAME) ? getValue(params.get(ACCOUNT_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_TYPE) ? getValue(params.get(ACCOUNT_TYPE)) : null);
                        callableStatement.setString(6, params.containsKey(TIME_ZONE_OFFSET) ? getValue(params.get(TIME_ZONE_OFFSET)) : null);
                        callableStatement.setString(7, params.containsKey(DST) ? getValue(params.get(DST)) : null);
                        callableStatement.setString(8, params.containsKey(URL_KEY) ? getValue(params.get(URL_KEY)) : null);
                        callableStatement.setString(9, params.containsKey(ALIAS) ? getValue(params.get(ALIAS)) : null);
                        callableStatement.setString(10, params.containsKey(SUB_TYPE) ? getValue(params.get(SUB_TYPE)) : null);
                        callableStatement.setString(11, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(12, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(13, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(14, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(15, params.containsKey(LAST_MODIFIED_DATE) ? getValue(params.get(LAST_MODIFIED_DATE)) : null);
                        callableStatement.setString(16, params.containsKey(ASSIGNEE_GROUP) ? getValue(params.get(ASSIGNEE_GROUP)) : null);
                        callableStatement.setString(17, params.containsKey(COLOR_R) ? getValue(params.get(COLOR_R)) : null);
                        callableStatement.setString(18, params.containsKey(COLOR_G) ? getValue(params.get(COLOR_G)) : null);
                        callableStatement.setString(19, params.containsKey(COLOR_B) ? getValue(params.get(COLOR_B)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createFdnPeopleInfo(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 116); // 59 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varString); // 35
            paramList.add(varString); // 36
            paramList.add(varString); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39
            paramList.add(varString); // 40
            paramList.add(varString); // 41
            paramList.add(varString); // 42
            paramList.add(varString); // 43
            paramList.add(varString); // 44
            paramList.add(varString); // 45
            paramList.add(varString); // 46
            paramList.add(varString); // 47
            paramList.add(varString); // 48
            paramList.add(varString); // 49
            paramList.add(varString); // 50
            paramList.add(varString); // 51
            paramList.add(varString); // 52
            paramList.add(varString); // 53
            paramList.add(varString); // 54
            paramList.add(varString); // 55
            paramList.add(varString); // 56
            paramList.add(varString); // 57
            paramList.add(varString); // 58
            paramList.add(varString); // 59

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FNAME) ? getValue(params.get(FNAME)) : null);
                        callableStatement.setString(2, params.containsKey(MIDDLE_INIT) ? getValue(params.get(MIDDLE_INIT)) : null);
                        callableStatement.setString(3, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);
                        callableStatement.setString(4, params.containsKey(FULL_NAME) ? getValue(params.get(FULL_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(EMPLOYEE_NUMBER) ? getValue(params.get(EMPLOYEE_NUMBER)) : null);
                        callableStatement.setString(6, params.containsKey(BUS_EMAILID) ? getValue(params.get(BUS_EMAILID)) : null);
                        callableStatement.setString(7, params.containsKey(REFID_1) ? getValue(params.get(REFID_1)) : null);
                        callableStatement.setString(8, params.containsKey(REFID_2) ? getValue(params.get(REFID_2)) : null);
                        callableStatement.setString(9, params.containsKey(REFID_3) ? getValue(params.get(REFID_3)) : null);
                        callableStatement.setString(10, params.containsKey(REFID_4) ? getValue(params.get(REFID_4)) : null);
                        callableStatement.setString(11, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(12, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(13, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(14, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(15, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(16, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(17, params.containsKey(PAGER_ALPHA) ? getValue(params.get(PAGER_ALPHA)) : null);
                        callableStatement.setString(18, params.containsKey(PAGER_NUMERIC) ? getValue(params.get(PAGER_NUMERIC)) : null);
                        callableStatement.setString(19, params.containsKey(PHONE_CELL) ? getValue(params.get(PHONE_CELL)) : null);
                        callableStatement.setString(20, params.containsKey(PHONE_HOME) ? getValue(params.get(PHONE_HOME)) : null);
                        callableStatement.setString(21, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(22, params.containsKey(PHONE_EXTN) ? getValue(params.get(PHONE_EXTN)) : null);
                        callableStatement.setString(23, params.containsKey(FAX) ? getValue(params.get(FAX)) : null);
                        callableStatement.setString(24, params.containsKey(CLIENT) ? getValue(params.get(CLIENT)) : null);
                        callableStatement.setString(25, params.containsKey(SUPERVISOR_LOGIN) ? getValue(params.get(SUPERVISOR_LOGIN)) : null);
                        callableStatement.setString(26, params.containsKey(SUPERVISOR_NAME) ? getValue(params.get(SUPERVISOR_NAME)) : null);
                        callableStatement.setString(27, params.containsKey(IS_SUPPORT_PERSON) ? getValue(params.get(IS_SUPPORT_PERSON)) : null);
                        callableStatement.setString(28, params.containsKey(COST_CODE) ? getValue(params.get(COST_CODE)) : null);
                        callableStatement.setString(29, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(30, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(31, params.containsKey(NOTIFY_METHOD) ? getValue(params.get(NOTIFY_METHOD)) : null);
                        callableStatement.setString(32, params.containsKey(CST) ? getValue(params.get(CST)) : null);
                        callableStatement.setString(33, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(34, params.containsKey(ROLE) ? getValue(params.get(ROLE)) : null);
                        callableStatement.setString(35, params.containsKey(ROLE_DESC) ? getValue(params.get(ROLE_DESC)) : null);
                        callableStatement.setString(36, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(37, params.containsKey(CLIENT_NOTES) ? getValue(params.get(CLIENT_NOTES)) : null);
                        callableStatement.setString(38, params.containsKey(AD_COMPANY) ? getValue(params.get(AD_COMPANY)) : null);
                        callableStatement.setString(39, params.containsKey(AD_DEPARTMENT) ? getValue(params.get(AD_DEPARTMENT)) : null);
                        callableStatement.setString(40, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(41, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(42, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(43, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(44, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(45, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(46, params.containsKey(ISACTIVE) ? getValue(params.get(ISACTIVE)) : null);
                        callableStatement.setString(47, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(48, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(49, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(50, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(51, params.containsKey(PER_EMAIL_ID) ? getValue(params.get(PER_EMAIL_ID)) : null);
                        callableStatement.setString(52, params.containsKey(PASSWORD) ? getValue(params.get(PASSWORD)) : null);
                        callableStatement.setString(53, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(54, params.containsKey(GUID) ? getValue(params.get(GUID)) : null);
                        callableStatement.setString(55, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(56, params.containsKey(PAGER_PIN) ? getValue(params.get(PAGER_PIN)) : null);
                        callableStatement.setString(57, params.containsKey(EXTSYSID) ? getValue(params.get(EXTSYSID)) : null);
                        callableStatement.setString(58, params.containsKey(CLIENT_NOTE_EXPIRATION_DATE) ? getValue(params.get(CLIENT_NOTE_EXPIRATION_DATE)) : null);
                        callableStatement.setString(59, params.containsKey(PEOPLE_SOFT_EMP_ID) ? getValue(params.get(PEOPLE_SOFT_EMP_ID)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createDmartGroup(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(GROUP_ID) ? getValue(params.get(GROUP_ID)) : null);
                        callableStatement.setString(2, params.containsKey(GROUP_NAME) ? getValue(params.get(GROUP_NAME)) : null);
                        callableStatement.setString(3, params.containsKey(LONG_GROUP_NAME) ? getValue(params.get(LONG_GROUP_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATOR) ? getValue(params.get(CREATOR)) : null);
                        callableStatement.setString(6, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(7, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createDmartGrpOptionsDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 42); // 22 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FUNCTIONAL_TYPE) ? getValue(params.get(FUNCTIONAL_TYPE)) : null);
                        callableStatement.setString(2, params.containsKey(A1st_LEVEL_GROUP) ? getValue(params.get(A1st_LEVEL_GROUP)) : null);
                        callableStatement.setString(3, params.containsKey(GROUP_ID) ? getValue(params.get(GROUP_ID)) : null);
                        callableStatement.setString(4, params.containsKey(LONG_GROUP_NAME) ? getValue(params.get(LONG_GROUP_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(GROUP_NAME) ? getValue(params.get(GROUP_NAME)) : null);
                        callableStatement.setString(6, params.containsKey(CLIENT) ? getValue(params.get(CLIENT)) : null);
                        callableStatement.setString(7, params.containsKey(MASTER_CLIENT) ? getValue(params.get(MASTER_CLIENT)) : null);
                        callableStatement.setString(8, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(9, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(10, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(11, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(12, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(13, params.containsKey(GROUPING) ? getValue(params.get(GROUPING)) : null);
                        callableStatement.setString(14, params.containsKey(GROUP_NOTIFY_METHOD) ? getValue(params.get(GROUP_NOTIFY_METHOD)) : null);
                        callableStatement.setString(15, params.containsKey(ZASSIGNED_GROUP) ? getValue(params.get(ZASSIGNED_GROUP)) : null);
                        callableStatement.setString(16, params.containsKey(APPROVAL_EMAIL) ? getValue(params.get(APPROVAL_EMAIL)) : null);
                        callableStatement.setString(17, params.containsKey(ASSET_TAG_REQUIRED) ? getValue(params.get(ASSET_TAG_REQUIRED)) : null);
                        callableStatement.setString(18, params.containsKey(SECURITY_ACCESS) ? getValue(params.get(SECURITY_ACCESS)) : null);
                        callableStatement.setString(19, params.containsKey(AUTO_CLOSE) ? getValue(params.get(AUTO_CLOSE)) : null);
                        callableStatement.setString(20, params.containsKey(GROUP_EMAIL_ADDRESS) ? getValue(params.get(GROUP_EMAIL_ADDRESS)) : null);
                        callableStatement.setString(21, params.containsKey(REQUIRE_TIME_SPENT) ? getValue(params.get(REQUIRE_TIME_SPENT)) : null);
                        callableStatement.setString(22, params.containsKey(GROUP) ? getValue(params.get(GROUP)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createDMartUserDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FULL_NAME) ? getValue(params.get(FULL_NAME)) : null);
                        callableStatement.setString(2, params.containsKey(LOGIN_NAME) ? getValue(params.get(LOGIN_NAME)) : null);
                        callableStatement.setString(3, params.containsKey(PASSWORD) ? getValue(params.get(PASSWORD)) : null);
                        callableStatement.setString(4, params.containsKey(EMAIL_ADDRESS) ? getValue(params.get(EMAIL_ADDRESS)) : null);
                        callableStatement.setString(5, params.containsKey(GROUP_LIST) ? getValue(params.get(GROUP_LIST)) : null);
                        callableStatement.setString(6, params.containsKey(COMPUTED_GRP_LIST) ? getValue(params.get(COMPUTED_GRP_LIST)) : null);
                        callableStatement.setString(7, params.containsKey(LOGIN_ALIAS) ? getValue(params.get(LOGIN_ALIAS)) : null);
                        callableStatement.setString(8, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(9, params.containsKey(CREATOR) ? getValue(params.get(CREATOR)) : null);
                        callableStatement.setString(10, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(11, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartAccount(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 34); // 18 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(2, params.containsKey(MASTER_ACCOUNT) ? getValue(params.get(MASTER_ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_NAME) ? getValue(params.get(ACCOUNT_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_TYPE) ? getValue(params.get(ACCOUNT_TYPE)) : null);
                        callableStatement.setString(6, params.containsKey(TIME_ZONE_OFFSET) ? getValue(params.get(TIME_ZONE_OFFSET)) : null);
                        callableStatement.setString(7, params.containsKey(DST) ? getValue(params.get(DST)) : null);
                        callableStatement.setString(8, params.containsKey(URL_KEY) ? getValue(params.get(URL_KEY)) : null);
                        callableStatement.setString(9, params.containsKey(ALIAS) ? getValue(params.get(ALIAS)) : null);
                        callableStatement.setString(10, params.containsKey(SUB_TYPE) ? getValue(params.get(SUB_TYPE)) : null);
                        callableStatement.setString(11, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(12, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(13, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(14, params.containsKey(LAST_MODIFIED_DATE) ? getValue(params.get(LAST_MODIFIED_DATE)) : null);
                        callableStatement.setString(15, params.containsKey(ASSIGNEE_GROUP) ? getValue(params.get(ASSIGNEE_GROUP)) : null);
                        callableStatement.setString(16, params.containsKey(COLOR_R) ? getValue(params.get(COLOR_R)) : null);
                        callableStatement.setString(17, params.containsKey(COLOR_G) ? getValue(params.get(COLOR_G)) : null);
                        callableStatement.setString(18, params.containsKey(COLOR_B) ? getValue(params.get(COLOR_B)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartGroup(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(GROUP_ID) ? getValue(params.get(GROUP_ID)) : null);
                        callableStatement.setString(2, params.containsKey(GROUP_NAME) ? getValue(params.get(GROUP_NAME)) : null);
                        callableStatement.setString(3, params.containsKey(LONG_GROUP_NAME) ? getValue(params.get(LONG_GROUP_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDMartUserDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); // 10 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FULL_NAME) ? getValue(params.get(FULL_NAME)) : null);
                        callableStatement.setString(2, params.containsKey(LOGIN_NAME) ? getValue(params.get(LOGIN_NAME)) : null);
                        callableStatement.setString(3, params.containsKey(PASSWORD) ? getValue(params.get(PASSWORD)) : null);
                        callableStatement.setString(4, params.containsKey(EMAIL_ADDRESS) ? getValue(params.get(EMAIL_ADDRESS)) : null);
                        callableStatement.setString(5, params.containsKey(GROUP_LIST) ? getValue(params.get(GROUP_LIST)) : null);
                        callableStatement.setString(6, params.containsKey(COMPUTED_GRP_LIST) ? getValue(params.get(COMPUTED_GRP_LIST)) : null);
                        callableStatement.setString(7, params.containsKey(LOGIN_ALIAS) ? getValue(params.get(LOGIN_ALIAS)) : null);
                        callableStatement.setString(8, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(9, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(10, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartGrpOptionsDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 40); // 21 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FUNCTIONAL_TYPE) ? getValue(params.get(FUNCTIONAL_TYPE)) : null);
                        callableStatement.setString(2, params.containsKey(A1st_LEVEL_GROUP) ? getValue(params.get(A1st_LEVEL_GROUP)) : null);
                        callableStatement.setString(3, params.containsKey(GROUP_ID) ? getValue(params.get(GROUP_ID)) : null);
                        callableStatement.setString(4, params.containsKey(LONG_GROUP_NAME) ? getValue(params.get(LONG_GROUP_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(GROUP_NAME) ? getValue(params.get(GROUP_NAME)) : null);
                        callableStatement.setString(6, params.containsKey(CLIENT) ? getValue(params.get(CLIENT)) : null);
                        callableStatement.setString(7, params.containsKey(MASTER_CLIENT) ? getValue(params.get(MASTER_CLIENT)) : null);
                        callableStatement.setString(8, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(10, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(11, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(12, params.containsKey(GROUPING) ? getValue(params.get(GROUPING)) : null);
                        callableStatement.setString(13, params.containsKey(GROUP_NOTIFY_METHOD) ? getValue(params.get(GROUP_NOTIFY_METHOD)) : null);
                        callableStatement.setString(14, params.containsKey(ZASSIGNED_GROUP) ? getValue(params.get(ZASSIGNED_GROUP)) : null);
                        callableStatement.setString(15, params.containsKey(APPROVAL_EMAIL) ? getValue(params.get(APPROVAL_EMAIL)) : null);
                        callableStatement.setString(16, params.containsKey(ASSET_TAG_REQUIRED) ? getValue(params.get(ASSET_TAG_REQUIRED)) : null);
                        callableStatement.setString(17, params.containsKey(SECURITY_ACCESS) ? getValue(params.get(SECURITY_ACCESS)) : null);
                        callableStatement.setString(18, params.containsKey(AUTO_CLOSE) ? getValue(params.get(AUTO_CLOSE)) : null);
                        callableStatement.setString(19, params.containsKey(GROUP_EMAIL_ADDRESS) ? getValue(params.get(GROUP_EMAIL_ADDRESS)) : null);
                        callableStatement.setString(20, params.containsKey(REQUIRE_TIME_SPENT) ? getValue(params.get(REQUIRE_TIME_SPENT)) : null);
                        callableStatement.setString(21, params.containsKey(GROUP) ? getValue(params.get(GROUP)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSlmGoalType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(GOAL_TYPE_SK) ? getValue(params.get(GOAL_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(GOAL_TYPE_CODE) ? getValue(params.get(GOAL_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(GOAL_TYPE) ? getValue(params.get(GOAL_TYPE)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRdyAttachments(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ATTACHMENT_SK) ? getValue(params.get(ATTACHMENT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ATTACHMENT_CODE) ? getDBValidatedValue(params.get(ATTACHMENT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(RDY_MAPPING_SK) ? getDBValidatedValue(params.get(RDY_MAPPING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(FILE_NAME) ? getDBValidatedValue(params.get(FILE_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(FILE_PATH) ? getDBValidatedValue(params.get(FILE_PATH), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(FILE_TYPE) ? getDBValidatedValue(params.get(FILE_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRdyMappingSLA(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 48); // 25 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RDY_MAPPING_SLA_SK) ? getValue(params.get(RDY_MAPPING_SLA_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(X_CRITERIA_1) ? getDBValidatedValue(params.get(X_CRITERIA_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(X_CRITERIA_2) ? getDBValidatedValue(params.get(X_CRITERIA_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(X_CRITERIA_3) ? getDBValidatedValue(params.get(X_CRITERIA_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(X_CRITERIA_4) ? getDBValidatedValue(params.get(X_CRITERIA_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(X_CRITERIA_5) ? getDBValidatedValue(params.get(X_CRITERIA_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(X_BUSINESS_FUNCTION_SK) ? getValue(params.get(X_BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(9, params.containsKey(X_SEVERITY_SK) ? getDBValidatedValue(params.get(X_SEVERITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(X_IMPACT_SK) ? getDBValidatedValue(params.get(X_IMPACT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(X_PRIORITY_SK) ? getDBValidatedValue(params.get(X_PRIORITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(X_IS_VIP) ? getValue(params.get(X_IS_VIP)) : null);
                        callableStatement.setString(13, params.containsKey(X_TITLE_SK) ? getDBValidatedValue(params.get(X_TITLE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(Y_SLM_DEFINITION_SK) ? getValue(params.get(Y_SLM_DEFINITION_SK)) : null);
                        callableStatement.setString(15, params.containsKey(Y_VALUE1) ? getDBValidatedValue(params.get(Y_VALUE1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(16, params.containsKey(Y_VALUE2) ? getDBValidatedValue(params.get(Y_VALUE2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(17, params.containsKey(Y_VALUE3) ? getDBValidatedValue(params.get(Y_VALUE3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(Y_VALUE4) ? getDBValidatedValue(params.get(Y_VALUE4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(19, params.containsKey(Y_VALUE5) ? getDBValidatedValue(params.get(Y_VALUE5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(20, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(21, params.containsKey(X_MASTER_TYPE1_SK) ? getDBValidatedValue(params.get(X_MASTER_TYPE1_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(22, params.containsKey(X_MASTER_TYPE2_SK) ? getDBValidatedValue(params.get(X_MASTER_TYPE2_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(23, params.containsKey(X_MASTER_TYPE3_SK) ? getDBValidatedValue(params.get(X_MASTER_TYPE3_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(25, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRdyMapping(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 124); // 63 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30
            paramList.add(varString); //31
            paramList.add(varString); //32
            paramList.add(varString); //33
            paramList.add(varString); //34
            paramList.add(varString); //35
            paramList.add(varString); //36
            paramList.add(varString); //37
            paramList.add(varString); //38
            paramList.add(varString); //39
            paramList.add(varString); //40
            paramList.add(varString); //41
            paramList.add(varString); //42
            paramList.add(varString); //43
            paramList.add(varString); //44
            paramList.add(varString); //45
            paramList.add(varString); //46
            paramList.add(varString); //47
            paramList.add(varString); //48
            paramList.add(varString); //49
            paramList.add(varString); //50
            paramList.add(varString); //51
            paramList.add(varString); //52
            paramList.add(varString); //53
            paramList.add(varString); //54
            paramList.add(varString); //55
            paramList.add(varString); //56
            paramList.add(varString); //57
            paramList.add(varString); //58
            paramList.add(varString); //59
            paramList.add(varString); //60
            paramList.add(varString); //61
            paramList.add(varString); //62
            paramList.add(varString); //63

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(RDY_MAPPING_SK) ? getValue(params.get(RDY_MAPPING_SK)) : null);
                        callableStatement.setString(2, params.containsKey(RDY_MAPPING_CODE) ? getDBValidatedValue(params.get(RDY_MAPPING_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(X_CRITERIA_1) ? getDBValidatedValue(params.get(X_CRITERIA_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(X_CRITERIA_2) ? getDBValidatedValue(params.get(X_CRITERIA_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(X_CRITERIA_3) ? getDBValidatedValue(params.get(X_CRITERIA_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(X_CRITERIA_4) ? getDBValidatedValue(params.get(X_CRITERIA_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(X_CRITERIA_5) ? getDBValidatedValue(params.get(X_CRITERIA_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(X_BUILDING_SK) ? getDBValidatedValue(params.get(X_BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(X_DEPARTMENT_SK) ? getDBValidatedValue(params.get(X_DEPARTMENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(X_CTI_SK) ? getDBValidatedValue(params.get(X_CTI_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(X_PRIORITY_SK) ? getDBValidatedValue(params.get(X_PRIORITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(X_BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(X_BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(X_PROCESS_CODE) ? getDBValidatedValue(params.get(X_PROCESS_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(15, params.containsKey(X_SEVERITY_SK) ? getDBValidatedValue(params.get(X_SEVERITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(X_IMPACT_SK) ? getDBValidatedValue(params.get(X_IMPACT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(X_USER_TYPE_SK) ? getDBValidatedValue(params.get(X_USER_TYPE_SK), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(Y_CTI_SK) ? getDBValidatedValue(params.get(Y_CTI_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(Y_ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(Y_ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(Y_ASSIGED_INDIVIDUAL_SK) ? getDBValidatedValue(params.get(Y_ASSIGED_INDIVIDUAL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(21, params.containsKey(Y_VALUE1) ? getDBValidatedValue(params.get(Y_VALUE1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(22, params.containsKey(Y_VALUE2) ? getDBValidatedValue(params.get(Y_VALUE2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(23, params.containsKey(Y_VALUE3) ? getDBValidatedValue(params.get(Y_VALUE3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(24, params.containsKey(Y_VALUE4) ? getDBValidatedValue(params.get(Y_VALUE4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(25, params.containsKey(Y_VALUE5) ? getDBValidatedValue(params.get(Y_VALUE5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(26, params.containsKey(Y_PRIORITY_SK) ? getDBValidatedValue(params.get(Y_PRIORITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(27, params.containsKey(Y_SEVERITY_SK) ? getDBValidatedValue(params.get(Y_SEVERITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(28, params.containsKey(Y_IMPACT_SK) ? getDBValidatedValue(params.get(Y_IMPACT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(29, params.containsKey(Y_PRIMARY_APPROVER_SK) ? getDBValidatedValue(params.get(Y_PRIMARY_APPROVER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(30, params.containsKey(Y_SECONDARY_APPROVER_SK) ? getDBValidatedValue(params.get(Y_SECONDARY_APPROVER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(31, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(32, params.containsKey(X_PRIMARY_APPROVER_SK) ? getDBValidatedValue(params.get(X_PRIMARY_APPROVER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(33, params.containsKey(X_CATEGORY_SK) ? getDBValidatedValue(params.get(X_CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(34, params.containsKey(X_TYPE_SK) ? getDBValidatedValue(params.get(X_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(35, params.containsKey(X_ITEM_SK) ? getDBValidatedValue(params.get(X_ITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(36, params.containsKey(Y_CATEGORY_SK) ? getDBValidatedValue(params.get(Y_CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(37, params.containsKey(Y_TYPE_SK) ? getDBValidatedValue(params.get(Y_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(38, params.containsKey(Y_ITEM_SK) ? getDBValidatedValue(params.get(Y_ITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(39, params.containsKey(Y_CASE_TYPE_SK) ? getDBValidatedValue(params.get(Y_CASE_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(40, params.containsKey(Y_INC_STATUS_SK) ? getDBValidatedValue(params.get(Y_INC_STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(41, params.containsKey(YSR_STATUS_SK) ? getDBValidatedValue(params.get(YSR_STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(42, params.containsKey(TASK_GROUP_SK) ? getDBValidatedValue(params.get(TASK_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(43, params.containsKey(X_ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(X_ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(44, params.containsKey(X_ASSIGNED_INDIVIDUAL_SK) ? getDBValidatedValue(params.get(X_ASSIGNED_INDIVIDUAL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(45, params.containsKey(X_REQUESTER_SK) ? getDBValidatedValue(params.get(X_REQUESTER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(46, params.containsKey(Y_APPROVAL_CRITERIA_SK) ? getDBValidatedValue(params.get(Y_APPROVAL_CRITERIA_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(47, params.containsKey(MAPPING_TYPE) ? getDBValidatedValue(params.get(MAPPING_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(48, params.containsKey(Y_SIZE) ? getDBValidatedValue(params.get(Y_SIZE), DATATYPE_FLOAT) : null);
                        callableStatement.setString(49, params.containsKey(X_ARTICLE_METADATA_SK) ? getDBValidatedValue(params.get(X_ARTICLE_METADATA_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(50, params.containsKey(IS_TIME_SPENT_REQUIRED) ? getValue(params.get(IS_TIME_SPENT_REQUIRED)) : null);
                        callableStatement.setString(51, params.containsKey(Y_SOURCE_SK) ? getDBValidatedValue(params.get(Y_SOURCE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(52, params.containsKey(Y_QUEUE_SK) ? getDBValidatedValue(params.get(Y_QUEUE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(53, params.containsKey(X_APPROVAL_CRITERIA_SK) ? getDBValidatedValue(params.get(X_APPROVAL_CRITERIA_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(54, params.containsKey(SET_TO_AUTO_ACK) ? getValue(params.get(SET_TO_AUTO_ACK)) : null);
                        callableStatement.setString(55, params.containsKey(DIRECT_TO_CLOSE) ? getValue(params.get(DIRECT_TO_CLOSE)) : null);
                        callableStatement.setString(56, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(57, params.containsKey(X_TITLE_SK) ? getDBValidatedValue(params.get(X_TITLE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(58, params.containsKey(X_IS_VIP) ? getValue(params.get(X_IS_VIP)) : null);
                        callableStatement.setString(59, params.containsKey(X_DESIGNATION_SK) ? getDBValidatedValue(params.get(X_DESIGNATION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(60, params.containsKey(X_SOURCE_SK) ? getDBValidatedValue(params.get(X_SOURCE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(61, params.containsKey(LEVEL) ? getDBValidatedValue(params.get(LEVEL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(62, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(63, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateFdnPeopleInfo(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 116); // 59 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31
            paramList.add(varString); // 32
            paramList.add(varString); // 33
            paramList.add(varString); // 34
            paramList.add(varString); // 35
            paramList.add(varString); // 36
            paramList.add(varString); // 37
            paramList.add(varString); // 38
            paramList.add(varString); // 39
            paramList.add(varString); // 40
            paramList.add(varString); // 41
            paramList.add(varString); // 42
            paramList.add(varString); // 43
            paramList.add(varString); // 44
            paramList.add(varString); // 45
            paramList.add(varString); // 46
            paramList.add(varString); // 47
            paramList.add(varString); // 48
            paramList.add(varString); // 49
            paramList.add(varString); // 50
            paramList.add(varString); // 51
            paramList.add(varString); // 52
            paramList.add(varString); // 53
            paramList.add(varString); // 54
            paramList.add(varString); // 55
            paramList.add(varString); // 56
            paramList.add(varString); // 57
            paramList.add(varString); // 58
            paramList.add(varString); // 59

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(FNAME) ? getValue(params.get(FNAME)) : null);
                        callableStatement.setString(2, params.containsKey(MIDDLE_INIT) ? getValue(params.get(MIDDLE_INIT)) : null);
                        callableStatement.setString(3, params.containsKey(LASTNAME) ? getValue(params.get(LASTNAME)) : null);
                        callableStatement.setString(4, params.containsKey(FULL_NAME) ? getValue(params.get(FULL_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(EMPLOYEE_NUMBER) ? getValue(params.get(EMPLOYEE_NUMBER)) : null);
                        callableStatement.setString(6, params.containsKey(BUS_EMAILID) ? getValue(params.get(BUS_EMAILID)) : null);
                        callableStatement.setString(7, params.containsKey(REFID_1) ? getValue(params.get(REFID_1)) : null);
                        callableStatement.setString(8, params.containsKey(REFID_2) ? getValue(params.get(REFID_2)) : null);
                        callableStatement.setString(9, params.containsKey(REFID_3) ? getValue(params.get(REFID_3)) : null);
                        callableStatement.setString(10, params.containsKey(REFID_4) ? getValue(params.get(REFID_4)) : null);
                        callableStatement.setString(11, params.containsKey(DESIGNATION) ? getValue(params.get(DESIGNATION)) : null);
                        callableStatement.setString(12, params.containsKey(SUITE) ? getValue(params.get(SUITE)) : null);
                        callableStatement.setString(13, params.containsKey(FLOOR) ? getValue(params.get(FLOOR)) : null);
                        callableStatement.setString(14, params.containsKey(DEPARTMENT) ? getValue(params.get(DEPARTMENT)) : null);
                        callableStatement.setString(15, params.containsKey(BUILDING) ? getValue(params.get(BUILDING)) : null);
                        callableStatement.setString(16, params.containsKey(OFFICE) ? getValue(params.get(OFFICE)) : null);
                        callableStatement.setString(17, params.containsKey(PAGER_ALPHA) ? getValue(params.get(PAGER_ALPHA)) : null);
                        callableStatement.setString(18, params.containsKey(PAGER_NUMERIC) ? getValue(params.get(PAGER_NUMERIC)) : null);
                        callableStatement.setString(19, params.containsKey(PHONE_CELL) ? getValue(params.get(PHONE_CELL)) : null);
                        callableStatement.setString(20, params.containsKey(PHONE_HOME) ? getValue(params.get(PHONE_HOME)) : null);
                        callableStatement.setString(21, params.containsKey(PHONE_WORK) ? getValue(params.get(PHONE_WORK)) : null);
                        callableStatement.setString(22, params.containsKey(PHONE_EXTN) ? getValue(params.get(PHONE_EXTN)) : null);
                        callableStatement.setString(23, params.containsKey(FAX) ? getValue(params.get(FAX)) : null);
                        callableStatement.setString(24, params.containsKey(CLIENT) ? getValue(params.get(CLIENT)) : null);
                        callableStatement.setString(25, params.containsKey(SUPERVISOR_LOGIN) ? getValue(params.get(SUPERVISOR_LOGIN)) : null);
                        callableStatement.setString(26, params.containsKey(SUPERVISOR_NAME) ? getValue(params.get(SUPERVISOR_NAME)) : null);
                        callableStatement.setString(27, params.containsKey(IS_SUPPORT_PERSON) ? getValue(params.get(IS_SUPPORT_PERSON)) : null);
                        callableStatement.setString(28, params.containsKey(COST_CODE) ? getValue(params.get(COST_CODE)) : null);
                        callableStatement.setString(29, params.containsKey(TITLE) ? getValue(params.get(TITLE)) : null);
                        callableStatement.setString(30, params.containsKey(VIP) ? getValue(params.get(VIP)) : null);
                        callableStatement.setString(31, params.containsKey(NOTIFY_METHOD) ? getValue(params.get(NOTIFY_METHOD)) : null);
                        callableStatement.setString(32, params.containsKey(CST) ? getValue(params.get(CST)) : null);
                        callableStatement.setString(33, params.containsKey(QUEUE) ? getValue(params.get(QUEUE)) : null);
                        callableStatement.setString(34, params.containsKey(ROLE) ? getValue(params.get(ROLE)) : null);
                        callableStatement.setString(35, params.containsKey(ROLE_DESC) ? getValue(params.get(ROLE_DESC)) : null);
                        callableStatement.setString(36, params.containsKey(BUSINESS_ORGANIZATION) ? getValue(params.get(BUSINESS_ORGANIZATION)) : null);
                        callableStatement.setString(37, params.containsKey(CLIENT_NOTES) ? getValue(params.get(CLIENT_NOTES)) : null);
                        callableStatement.setString(38, params.containsKey(AD_COMPANY) ? getValue(params.get(AD_COMPANY)) : null);
                        callableStatement.setString(39, params.containsKey(AD_DEPARTMENT) ? getValue(params.get(AD_DEPARTMENT)) : null);
                        callableStatement.setString(40, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(41, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(42, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(43, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(44, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(45, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(46, params.containsKey(ISACTIVE) ? getValue(params.get(ISACTIVE)) : null);
                        callableStatement.setString(47, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(48, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(49, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(50, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(51, params.containsKey(PER_EMAIL_ID) ? getValue(params.get(PER_EMAIL_ID)) : null);
                        callableStatement.setString(52, params.containsKey(PASSWORD) ? getValue(params.get(PASSWORD)) : null);
                        callableStatement.setString(53, params.containsKey(ASSIGNED_GROUP) ? getValue(params.get(ASSIGNED_GROUP)) : null);
                        callableStatement.setString(54, params.containsKey(GUID) ? getValue(params.get(GUID)) : null);
                        callableStatement.setString(55, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(56, params.containsKey(PAGER_PIN) ? getValue(params.get(PAGER_PIN)) : null);
                        callableStatement.setString(57, params.containsKey(EXTSYSID) ? getValue(params.get(EXTSYSID)) : null);
                        callableStatement.setString(58, params.containsKey(CLIENT_NOTE_EXPIRATION_DATE) ? getValue(params.get(CLIENT_NOTE_EXPIRATION_DATE)) : null);
                        callableStatement.setString(59, params.containsKey(PEOPLE_SOFT_EMP_ID) ? getValue(params.get(PEOPLE_SOFT_EMP_ID)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static Map<String, Object> CreateDMartCMNCategorization(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 30); // 16 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(2, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(3, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(4, params.containsKey(Z_APPLICATION) ? getValue(params.get(Z_APPLICATION)) : null);
                        callableStatement.setString(5, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(6, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(CREATE_DATE) ? getValue(params.get(CREATE_DATE)) : null);
                        callableStatement.setString(8, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(9, params.containsKey(REQUESTED_BY) ? getValue(params.get(REQUESTED_BY)) : null);
                        callableStatement.setString(10, params.containsKey(ASSOCIATED_REQUEST) ? getValue(params.get(ASSOCIATED_REQUEST)) : null);
                        callableStatement.setString(11, params.containsKey(REMEDY_MESSAGE) ? getValue(params.get(REMEDY_MESSAGE)) : null);
                        callableStatement.setString(12, params.containsKey(QUESTIONS_INFORMATION) ? getValue(params.get(QUESTIONS_INFORMATION)) : null);
                        callableStatement.setString(13, params.containsKey(FLR_POSSIBLE) ? getValue(params.get(FLR_POSSIBLE)) : null);
                        callableStatement.setString(14, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(15, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(16, params.containsKey(CTI_CODE) ? getValue(params.get(CTI_CODE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> UpdateDMartCMNCategorization(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 28); // 15 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(2, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(3, params.containsKey(ITEM) ? getValue(params.get(ITEM)) : null);
                        callableStatement.setString(4, params.containsKey(Z_APPLICATION) ? getValue(params.get(Z_APPLICATION)) : null);
                        callableStatement.setString(5, params.containsKey(MODIFIED_DATE) ? getValue(params.get(MODIFIED_DATE)) : null);
                        callableStatement.setString(6, params.containsKey(LAST_MODIFIED_BY) ? getValue(params.get(LAST_MODIFIED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(SUBMITTER) ? getValue(params.get(SUBMITTER)) : null);
                        callableStatement.setString(8, params.containsKey(REQUESTED_BY) ? getValue(params.get(REQUESTED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(ASSOCIATED_REQUEST) ? getValue(params.get(ASSOCIATED_REQUEST)) : null);
                        callableStatement.setString(10, params.containsKey(REMEDY_MESSAGE) ? getValue(params.get(REMEDY_MESSAGE)) : null);
                        callableStatement.setString(11, params.containsKey(QUESTIONS_INFORMATION) ? getValue(params.get(QUESTIONS_INFORMATION)) : null);
                        callableStatement.setString(12, params.containsKey(FLR_POSSIBLE) ? getValue(params.get(FLR_POSSIBLE)) : null);
                        callableStatement.setString(13, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(14, params.containsKey(PRIORITY) ? getValue(params.get(PRIORITY)) : null);
                        callableStatement.setString(15, params.containsKey(CTI_CODE) ? getValue(params.get(CTI_CODE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> CreateUpdateRDYKBPhrases(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(KB_PHRASES_SK) ? getValue(params.get(KB_PHRASES_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PHRASES) ? getValue(params.get(PHRASES)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(4, params.containsKey(AGENT_SPECIFIC_PHRASE) ? getValue(params.get(AGENT_SPECIFIC_PHRASE)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);


                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> CreateUpdateFDNBackUpApprovers(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 18); // 10 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varDateTime); // 8
            paramList.add(varString); // 9
            paramList.add(varDateTime); // 10


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(BACK_UP_APPROVER_SK) ? getValue(params.get(BACK_UP_APPROVER_SK)) : null);
                        callableStatement.setString(2, params.containsKey(Approver_sk) ? getValue(params.get(Approver_sk)) : null);
                        callableStatement.setString(3, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(5, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> CreateUpdateFDN_Controls(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CONTROLSK) ? getValue(params.get(CONTROLSK)) : null);
                        callableStatement.setString(2, params.containsKey(CONTROL_CODE) ? getValue(params.get(CONTROL_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(CONTROL_TYPE) ? getValue(params.get(CONTROL_TYPE)) : null);
                        callableStatement.setString(4, params.containsKey(JSON_PROPERTIES) ? getValue(params.get(JSON_PROPERTIES)) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> CreateUpdateFDNSupportUsers(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);
            SqlParameter varDateTime = new SqlParameter(Types.DATE);
            SqlParameter varBinary = new SqlParameter(Types.BINARY);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SUPPORT_USER_SK) ? getValue(params.get(SUPPORT_USER_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SUPPORT_SK) ? getValue(params.get(SUPPORT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(LEVEL) ? getValue(params.get(LEVEL)) : null);
                        callableStatement.setString(4, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(5, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(ASSIGNED_TICKET_COUNT) ? getValue(params.get(ASSIGNED_TICKET_COUNT)) : null);
                        callableStatement.setString(8, params.containsKey(RESOLVER) ? getValue(params.get(RESOLVER)) : null);
                        callableStatement.setString(9, params.containsKey(PRIORITY_SK) ? getValue(params.get(PRIORITY_SK)) : null);
                        callableStatement.setString(10, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> getChildNodes(List<Map<String, Object>> mainset, Map<String, Object> currentObject) {
        List<Map<String, Object>> tempresponse = mainset.stream()
                .filter(eachNode ->
                        StringUtils.isNotBlank((String) eachNode.get(PARENT_OBJECT_SK))
                                &&
                                ((String) eachNode.get(PARENT_OBJECT_SK)).equalsIgnoreCase(currentObject.get(OBJECT_SK).toString()))
                .collect(Collectors.toList());

        tempresponse = getChildElements(mainset, tempresponse);
        currentObject.put("children", tempresponse);
        return currentObject;
    }

    public static Boolean isChildNode(List<Map<String, Object>> mainset, Map<String, Object> currentObject) {
        boolean response = Boolean.FALSE;
        try {
            response =
                    mainset.stream()
                            .filter(stringObjectMap ->
                                    (StringUtils.isNotBlank((String) currentObject.get(OBJECT_SK))
                                            &&
                                            (
                                                    StringUtils.isBlank((String) currentObject.get(PARENT_OBJECT_SK))
                                                            ||
                                                            (StringUtils.isNotBlank((String) currentObject.get(PARENT_OBJECT_SK))
                                                                    &&
                                                                    !currentObject.get(PARENT_OBJECT_SK).toString().equalsIgnoreCase(currentObject.get(OBJECT_SK).toString())
                                                            )
                                            )
                                    )
                            )
                            .anyMatch(eachNode ->
                                    StringUtils.isNotBlank((String) eachNode.get(PARENT_OBJECT_SK))
                                            &&
                                            ((String) eachNode.get(PARENT_OBJECT_SK)).equalsIgnoreCase(currentObject.get(OBJECT_SK).toString())
                            );
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, null, e);
        }
        return response;
    }

    public static Map<String, Object> recursiveCurrentObjectwithChilds(List<Map<String, Object>> mainset, Map<String, Object> currentObject) {
        if (isChildNode(mainset, currentObject)) {
            return getChildNodes(mainset, currentObject);
        } else {
            return currentObject;
        }
    }


    public static List<Map<String, Object>> getChildElements(List<Map<String, Object>> mainset, List<Map<String, Object>> currentListObject) {
        return currentListObject.stream()
                .map(stringObjectMap ->
                        recursiveCurrentObjectwithChilds(mainset, stringObjectMap)
                ).collect(Collectors.toList());
    }

    public static List<Map<String, Object>> getResultsfilteredbyObjectCode(List<Map<String, Object>> mainset, String objectCode, String objectType) {
        if (checkBlankorEmpty(objectType)) {
            return mainset.parallelStream()
                    .filter(stringObjectMap -> checkBlankorEmpty((String) stringObjectMap.get(OBJECT_CODE)))
                    .filter(stringObjectMap -> ((String) stringObjectMap.get(OBJECT_CODE)).toString().trim().equalsIgnoreCase(objectCode)
                            ||
                            (checkBlankorEmpty((String) stringObjectMap.get(OBJECT_TYPE)) && stringObjectMap.get(OBJECT_TYPE).toString().trim().equalsIgnoreCase(objectType))
                    ).collect(Collectors.toList());
        } else {
            return mainset;
        }
    }

    public static List<Map<String, Object>> getResultsfilteredbyObjectType(List<Map<String, Object>> mainset, String objectCode) {
        return mainset.parallelStream()
                .filter(stringObjectMap -> (/*checkBlankorEmpty((String) stringObjectMap.get(OBJECT_TYPE)) && stringObjectMap.get(OBJECT_TYPE).toString().trim().equalsIgnoreCase(objectType))
                        ||*/
                        (checkBlankorEmpty((String) stringObjectMap.get(OBJECT_CODE)) &&
                                ((String) stringObjectMap.get(OBJECT_CODE)).toString().trim().equalsIgnoreCase(objectCode))
                ))
                .collect(Collectors.toList());
    }

    public static Boolean checkBlankorEmpty(String inputString) {
        return StringUtils.isNotBlank(inputString);
    }

    public static Boolean isNull(Object input) {
        return input == null;
    }

    public static Boolean isExist(String[] inputarray, String string) {
        if (string == null)
            return false;
        else if (inputarray != null)
            return Arrays.stream(inputarray).anyMatch(string::equals);
        else
            return true;
    }

    public static Map<String, Object> updateIAMApplication(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(APPLICATION_sk) ? getValue(params.get(APPLICATION_sk)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(APPLICATION_CODE) ? getValue(params.get(APPLICATION_CODE)) : null);
                        callableStatement.setString(4, params.containsKey(APPLICATION_NAME) ? getValue(params.get(APPLICATION_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateWorknoteType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(WORKNOTES_UPDATE_SK) ? getValue(params.get(WORKNOTES_UPDATE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(WORKNOTES_UPDATE_CODE) ? getValue(params.get(WORKNOTES_UPDATE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(WORKNOTES_UPDATE_TYPE) ? getValue(params.get(WORKNOTES_UPDATE_TYPE)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(SHOW_QUEUE) ? getValue(params.get(SHOW_QUEUE)) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateEmailOptions(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(EMAIL_OPTION_SK) ? getValue(params.get(EMAIL_OPTION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(EMAIL_OPTION_CODE) ? getValue(params.get(EMAIL_OPTION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(EMAIL_OPTION) ? getDBValidatedValue(params.get(EMAIL_OPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateCaseType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(CASE_TYPE_sk) ? getValue(params.get(CASE_TYPE_sk)) : null);
                        callableStatement.setString(2, params.containsKey(CASE_TYPE_CODE) ? getValue(params.get(CASE_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CASE_TYPE) ? getDBValidatedValue(params.get(CASE_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateBookmarks(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(BOOKMARK_SK) ? getValue(params.get(BOOKMARK_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(3, params.containsKey(BOOKMARK) ? getValue(params.get(BOOKMARK)) : null);
                        callableStatement.setString(4, params.containsKey(URL) ? getDBValidatedValue(params.get(URL), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateApprovalCriteria(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName, User user) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 66); // 34 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21
            paramList.add(varString); //22
            paramList.add(varString); //23
            paramList.add(varString); //24
            paramList.add(varString); //25
            paramList.add(varString); //26
            paramList.add(varString); //27
            paramList.add(varString); //28
            paramList.add(varString); //29
            paramList.add(varString); //30
            paramList.add(varString); //31
            paramList.add(varString); //32
            paramList.add(varString); //33
            paramList.add(varString); //34


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(APPROVAL_CRITERIA_SK) ? getValue(params.get(APPROVAL_CRITERIA_SK)) : null);
                        callableStatement.setString(2, params.containsKey(APPROVAL_CRITERIA_CODE) ? getValue(params.get(APPROVAL_CRITERIA_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(X_CRITERIA_1) ? getDBValidatedValue(params.get(X_CRITERIA_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(X_CRITERIA_2) ? getDBValidatedValue(params.get(X_CRITERIA_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(X_CRITERIA_3) ? getDBValidatedValue(params.get(X_CRITERIA_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(X_CRITERIA_4) ? getDBValidatedValue(params.get(X_CRITERIA_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(X_CRITERIA_5) ? getDBValidatedValue(params.get(X_CRITERIA_5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(X_BUILDING_SK) ? getDBValidatedValue(params.get(X_BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(X_DEPARTMENT_SK) ? getDBValidatedValue(params.get(X_DEPARTMENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(X_CATEGORY_SK) ? getDBValidatedValue(params.get(X_CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(X_TYPE_SK) ? getDBValidatedValue(params.get(X_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(X_ITEM_SK) ? getDBValidatedValue(params.get(X_ITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(X_CTI_SK) ? getDBValidatedValue(params.get(X_CTI_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(X_PRIORITY_SK) ? getDBValidatedValue(params.get(X_PRIORITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(X_BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(X_BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(X_PROCESS_CODE) ? getDBValidatedValue(params.get(X_PROCESS_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(X_SEVERITY_SK) ? getDBValidatedValue(params.get(X_SEVERITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(X_IMPACT_SK) ? getDBValidatedValue(params.get(X_IMPACT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(X_USER_TYPE_SK) ? getDBValidatedValue(params.get(X_USER_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(21, params.containsKey(X_ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(X_ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(22, params.containsKey(X_ASSIGNED_INDIVIDUAL_SK) ? getDBValidatedValue(params.get(X_ASSIGNED_INDIVIDUAL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(23, params.containsKey(X_REQUESTER_SK) ? getDBValidatedValue(params.get(X_REQUESTER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(24, params.containsKey(X_BUS_TIME_DETAIL_SK) ? getDBValidatedValue(params.get(X_BUS_TIME_DETAIL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(25, params.containsKey(YAD) ? getDBValidatedValue(params.get(YAD), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(26, params.containsKey(Y_VALUE1) ? getDBValidatedValue(params.get(Y_VALUE1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(27, params.containsKey(Y_VALUE2) ? getDBValidatedValue(params.get(Y_VALUE2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(28, params.containsKey(Y_VALUE3) ? getDBValidatedValue(params.get(Y_VALUE3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(29, params.containsKey(Y_VALUE4) ? getDBValidatedValue(params.get(Y_VALUE4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(30, params.containsKey(Y_VALUE5) ? getDBValidatedValue(params.get(Y_VALUE5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(31, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(32, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(33, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(34, params.containsKey(X_TASK_DETAILS_SK) ? getDBValidatedValue(params.get(X_TASK_DETAILS_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
                jmsTemplate.convertAndSend(INDEXER_UPDATE,
                        new IndexerDomain(INDEXERNAME_FETCH_APPROVALCRITERIA, queryObject.get(APPROVAL_CRITERIA_SK).toString(), user.getClientInstance()));
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateImpact(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(IMPACT_SK) ? getValue(params.get(IMPACT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(IMPACT_CODE) ? getValue(params.get(IMPACT_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(IMPACT) ? getDBValidatedValue(params.get(IMPACT), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(WEIGHTAGE) ? getDBValidatedValue(params.get(WEIGHTAGE), DATATYPE_FLOAT) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> convertChangeRequesttoCalendar(List<Map<String, Object>> results, String refresh_token) {
        results.stream()
                .map(stringObjectMap -> {
                            String url = CR_TICKET_DEFAULT_URL;
                            Map<String, String[]> params = new HashMap<>();
                            params.put(REFRESH_TOKEN, new String[]{refresh_token});
                            params.put(TICKET, new String[]{(String) stringObjectMap.get(TICKET)});
                            params.put(TICKET_SK, new String[]{(String) stringObjectMap.get(TICKET_SK)});
                            params.put(ACCOUNT, new String[]{(String) stringObjectMap.get(ACCOUNT)});
                            params.put(MASTER_ACCOUNT, new String[]{(String) stringObjectMap.get(MASTER_ACCOUNT)});
                            url = getDBQuery(url, params);
                            //map fields
                            stringObjectMap.put("Change Request #", stringObjectMap.get(TICKET));
                            stringObjectMap.put("Text Start Date", stringObjectMap.get(REQUESTED_ON));
                            stringObjectMap.put("Change/Project Name", stringObjectMap.get(PROJECT));
                            stringObjectMap.put("Text End Date", addminutestoUTCDatetime((String) stringObjectMap.get(REQUESTED_ON)
                                    , (String) stringObjectMap.get(ESTIMATED_DOWN_TIME)));
                            stringObjectMap.put("Detailed Description", stringObjectMap.get(DESCRIPTION));
                            stringObjectMap.put("URL", url);
                            stringObjectMap.put("Risk Level", stringObjectMap.get(RISK_LEVEL));
                            stringObjectMap.put("Requester Group Name", stringObjectMap.get(REQUESTERGROUPNAME));
                            stringObjectMap.put("Requester Name", stringObjectMap.get(REQUESTER_FULL_NAME));
                            stringObjectMap.put("Location of Change", null);
                            stringObjectMap.put("Type of Change", stringObjectMap.get(CHANGE_TYPE));
                            stringObjectMap.put("Reason for Change", stringObjectMap.get(CHANGE_REASON));
                            stringObjectMap.put("Platform", stringObjectMap.get("Platform"));
                            stringObjectMap.put("Category", stringObjectMap.get(CR_CATEGORY));
                            stringObjectMap.put("System", stringObjectMap.get(CRSYSTEM));
                            stringObjectMap.put("Est. Down Time", stringObjectMap.get(ESTIMATED_DOWN_TIME));
                            stringObjectMap.put("Est. Backout Time", null);
                            stringObjectMap.put("Duration", stringObjectMap.get(ESTIMATED_TIME));
                            stringObjectMap.put("Status of Change", stringObjectMap.get(STATUS));

                            return stringObjectMap;
                        }
                ).collect(Collectors.toList());
        return results;
    }

    public static List<Map<String, Object>> convertStatustoCalendar(List<Map<String, Object>> results, String refresh_token) {
        results.stream()
                .map(stringObjectMap -> {

                            stringObjectMap.put("name", stringObjectMap.get(STATUS));
                            stringObjectMap.put("id", stringObjectMap.get(STATUS_SK));
                            return stringObjectMap;
                        }
                ).collect(Collectors.toList());
        return results;
    }

    public static String addminutestoUTCDatetime(String datetime, String minutes) {
        if (minutes != null && datetime != null) {
            long timestamp = Long.parseLong(convertToTimestamp(datetime));
            timestamp = timestamp + (Long.parseLong(minutes) * 60 * 1000);
            return convertTimestampTODatetime(String.valueOf(timestamp));
        } else
            return null;
    }

    public static List<Map<String, Object>> appendUserinapproval(List<Map<String, Object>> results, UserAccountNGroup userAccountNGroup, User user) {
        results = mapLoggedinUserBackUpApprovers(userAccountNGroup, results);
        results = mapBackUpApprover(results, userAccountNGroup, user);
        return results;
    }

    public static List<Map<String, Object>> appendUserinCRapproval(List<Map<String, Object>> results, UserAccountNGroup userAccountNGroup, User user) {

        results = mapLoggedinUserBackUpApprovers(userAccountNGroup, results);

        //crapproval
        List<Map<String, Object>> unapprovedrecords = fetchUnapprovedRecords(results, user);
        unapprovedrecords = mapLoggedinUserBackUpApprovers(userAccountNGroup, unapprovedrecords);
        List<Map<String, Object>> approvedrecords = fetchapprovedRecords(results);
        unapprovedrecords = mapBackUpApprover(unapprovedrecords, userAccountNGroup, user);
        approvedrecords.addAll(unapprovedrecords);

        return approvedrecords;
    }

    public static List<Map<String, Object>> mapLoggedinUserBackUpApprovers(UserAccountNGroup userAccountNGroup, List<Map<String, Object>> results) {
        userAccountNGroup.getUserGroups().addAll(userAccountNGroup.getUserPermission());

        return results.stream()
                .map(stringObjectMap -> {
                            if (stringObjectMap.get(USER_SK) == null && stringObjectMap.get(GROUP_NAME) != null) {
                                if (userAccountNGroup.getUserGroups().parallelStream()
                                        .filter(stringObjectMap1 -> stringObjectMap1.get(GROUP_NAME) != null)
                                        .anyMatch(stringObjectMap1 -> stringObjectMap1.get(GROUP_NAME).toString().equalsIgnoreCase(stringObjectMap.get(GROUP_NAME).toString()))) {
                                    stringObjectMap.put(BackUpApprover_sk, userAccountNGroup.getUser_sk());
                                    stringObjectMap.put(BackUpApproverName, userAccountNGroup.getFull_name());
                                } else {
                                    stringObjectMap.put(BackUpApprover_sk, null);
                                    stringObjectMap.put(BackUpApproverName, null);
                                }
                            } else {
                                stringObjectMap.put(BackUpApprover_sk, null);
                                stringObjectMap.put(BackUpApproverName, null);
                            }
                            return stringObjectMap;
                        }
                ).collect(Collectors.toList());
    }

    public static Map<String, Object> updateSupport1(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 30); // 16 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SUPPORT_SK) ? getValue(params.get(SUPPORT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT_SK) ? getDBValidatedValue(params.get(PARENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_GROUP_SK) ? getValue(params.get(ACCOUNT_GROUP_SK)) : null);
                        callableStatement.setString(5, params.containsKey(CATEGORY_SK) ? getDBValidatedValue(params.get(CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(TYPE_SK) ? getDBValidatedValue(params.get(TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(START_DATE) ? getDBValidatedValue(params.get(START_DATE), DATATYPE_DATETIME) : null);
                        callableStatement.setString(8, params.containsKey(END_DATE) ? getDBValidatedValue(params.get(END_DATE), DATATYPE_DATETIME) : null);
                        callableStatement.setString(9, params.containsKey(SUPPORT_TYPE) ? getValue(params.get(SUPPORT_TYPE)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(NOTES) ? getDBValidatedValue(params.get(NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(EXECUTION_ORDER) ? getDBValidatedValue(params.get(EXECUTION_ORDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(ROUND_ROBIN_RULE_SK) ? getDBValidatedValue(params.get(ROUND_ROBIN_RULE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(RELATED_TYPE) ? getDBValidatedValue(params.get(RELATED_TYPE), DATATYPE_CHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSupportAttachments(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SUPPORT_ATTACHMENT_SK) ? getValue(params.get(SUPPORT_ATTACHMENT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SUPPORT_SK) ? getDBValidatedValue(params.get(SUPPORT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(FILE_NAME) ? getDBValidatedValue(params.get(FILE_NAME), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(FILE_PATH) ? getDBValidatedValue(params.get(FILE_PATH), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(FILE_TYPE) ? getDBValidatedValue(params.get(FILE_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(FILE_SIZE) ? getDBValidatedValue(params.get(FILE_SIZE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateTaskDetails(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 40); // 21 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TASK_DETAILS_SK1) ? getValue(params.get(TASK_DETAILS_SK1)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_SK) ? getDBValidatedValue(params.get(TASK_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(TASK_GROUP_SK) ? getDBValidatedValue(params.get(TASK_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(TASK_DETAILS_CODE) ? getValue(params.get(TASK_DETAILS_CODE)) : null);
                        callableStatement.setString(5, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(APPROVAL_TYPE_SK) ? getDBValidatedValue(params.get(APPROVAL_TYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(IS_AUTO_ASSIGN) ? getValue(params.get(IS_AUTO_ASSIGN)) : null);
                        callableStatement.setString(8, params.containsKey(AUTO_ACK_AFTER_ASSIGNED) ? getValue(params.get(AUTO_ACK_AFTER_ASSIGNED)) : null);
                        callableStatement.setString(9, params.containsKey(REMOVE_TASK_CODE) ? getDBValidatedValue(params.get(REMOVE_TASK_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(TASK_DETAILS) ? getDBValidatedValue(params.get(TASK_DETAILS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(IS_IAM) ? getValue(params.get(IS_IAM)) : null);
                        callableStatement.setString(15, params.containsKey(APPLICATION_sk) ? getDBValidatedValue(params.get(APPLICATION_sk), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(APPLICATION_LOGIN_ID) ? getDBValidatedValue(params.get(APPLICATION_LOGIN_ID), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(17, params.containsKey(APPLICATION_TEMP_PASSWORD) ? getDBValidatedValue(params.get(APPLICATION_TEMP_PASSWORD), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(NOTES) ? getDBValidatedValue(params.get(NOTES), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(19, params.containsKey(SIZE) ? getDBValidatedValue(params.get(SIZE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(TASK_TYPE) ? getDBValidatedValue(params.get(TASK_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(21, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateUserPosition(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_POSITION_SK) ? getValue(params.get(USER_POSITION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_POSITION_CODE) ? getValue(params.get(USER_POSITION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(USER_SK) ? getDBValidatedValue(params.get(USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(BUILDING_SK) ? getDBValidatedValue(params.get(BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(BUS_ORG_SK) ? getDBValidatedValue(params.get(BUS_ORG_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(DEPARTMENT_SK) ? getDBValidatedValue(params.get(DEPARTMENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(FLOOR_SK) ? getDBValidatedValue(params.get(FLOOR_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(SUITE_SK) ? getDBValidatedValue(params.get(SUITE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(IS_PRIMARY_LOCATION) ? getValue(params.get(IS_PRIMARY_LOCATION)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static List<Map<String, Object>> fetchattachments(String businessfunctioncode, String ticket, User user) throws Exception {
        String endpoint;
        List<Map<String, Object>> results = new ArrayList<>();
        Map<String, Object> endPointDomain = new HashMap<>();
        if (businessfunctioncode.equalsIgnoreCase(INCIDENTS))
            endpoint = INDEXERNAME_FETCH_INC_ATTACHMENTS;
        else if (businessfunctioncode.equalsIgnoreCase(SR))
            endpoint = INDEXERNAME_FETCH_SR_ATTACHMENTS;
        else if (businessfunctioncode.equalsIgnoreCase(SRT))
            endpoint = INDEXERNAME_FETCH_SRT_ATTACHMENTS;
        else {
            throw new Exception("not a valid businessfunction");
        }

        Map<String, String[]> params = new HashMap<>();
        params.put(TICKET, new String[]{ticket});
        endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpoint
                , V1, GET_METHOD, user);
        CustomWhooshModel attachmentsWhooshModel = SFInterfaceBase.generateWhooshModel(params, user);
        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), attachmentsWhooshModel.getParams());
        results = SFInterfaceBase.runjdbcQueryWithSelectedColumns(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), refdbquery
                , attachmentsWhooshModel.getRequiredColumns());

        results.stream()
                .map(stringObjectMap -> {
                    try {
                        String filepath = SFInterfaceConstants.getFileserverURL() + (String) stringObjectMap.get(FILE_PATH);
                        String bytestring = encodeFileToBase64Binary(filepath);
                        stringObjectMap.put("FileBytes", bytestring);
                    } catch (IOException e) {
                        SFInterfaceLoggerBase.exception(LOGGER, "Attachments", e);
                        stringObjectMap.put("FileBytes", null);
                    }
                    return stringObjectMap;
                }).collect(Collectors.toList());
        return results;
    }

    private static String encodeFileToBase64Binary(String fileName)
            throws IOException {
        File file = new File(fileName);
        byte[] bytes = loadFile(file);
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] loadFile(File file) throws IOException {
        InputStream is = new FileInputStream(file);

        long length = file.length();
        if (length > Integer.MAX_VALUE) {
        }
        byte[] bytes = new byte[(int) length];

        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length
                && (numRead = is.read(bytes, offset, bytes.length - offset)) >= 0) {
            offset += numRead;
        }

        if (offset < bytes.length) {
            throw new IOException("Could not completely read file " + file.getName());
        }

        is.close();
        return bytes;
    }

    public static List<Map<String, Object>> fetchObjectPermissions(CustomWhooshModel customWhooshModel, Map<String, Object> endPointDomain, User user, Boolean pagination) throws Exception {
        List<Map<String, Object>> result = new ArrayList<>();
        UserAccountNGroup userAccountNGroup = fetchUserAccountNGroup(null, user.getUserID(), user);
        if (userAccountNGroup.getAdministrator() && userAccountNGroup.getPrimaryMasterAccount().equalsIgnoreCase(CTS)) {
            customWhooshModel.getParams().remove(ACCOUNT);
            customWhooshModel.getParams().remove(ACCOUNT_SK);
        } else {
            customWhooshModel.getParams().put(ACCOUNT, new String[]{userAccountNGroup.getPrimaryMasterAccount()});
        }
        if (customWhooshModel.getParams().containsKey(OBJECT_SK)) {
            String[] object_sks = customWhooshModel.getParams().get(OBJECT_SK);
            customWhooshModel.getParams().put(OBJECT_SK, new String[]{String.join(COMMA, object_sks)});
        }

        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), customWhooshModel.getParams());
        result = SFInterfaceBase.runjdbcQueryWithPagination(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName())
                , refdbquery
                , customWhooshModel.getRequiredColumns()
                , customWhooshModel.getSortfields()
                , customWhooshModel.getSortorder()
                , customWhooshModel.getDistinct()
                , customWhooshModel.getDistinctfield()
                , customWhooshModel.getPageno()
                , customWhooshModel.getCount()
                , pagination);
        return result;
    }


    public static List<Map<String, Object>> fetchObjectPermissions(CustomWhooshModel customWhooshModel, Map<String, Object> endPointDomain, User user) throws Exception {
        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, String[]> params = new HashMap<>();
        UserAccountNGroup userAccountNGroup = fetchUserAccountNGroup(null, user.getUserID(), user);

        userAccountNGroup.getAccountGroup_sk().add(NULL_VALUE);
        params.put(ACCOUNT_GROUP_SK, userAccountNGroup.getAccountGroup_sk().toArray(new String[0]));

        List<String> accounts = userAccountNGroup.getUserAccounts()
                .parallelStream()
                .filter(stringObjectMap -> checkBlankorEmpty((String) stringObjectMap.get(GROUP_NAME)))
                .map(stringObjectMap -> (String) stringObjectMap.get(GROUP_NAME))
                .collect(Collectors.toList());
        accounts.add(NULL_VALUE);
        params.put(ACCOUNT, convertListtostringarray(accounts));
        params.put(USER_SK, new String[]{user.getUserID(), NULL_VALUE});
        params.put(STATUS_CODE, new String[]{"A"});
        String refdbquery = SFInterfaceBase.generateWhooshQueryDynamic(params);
        refdbquery += AND + OPEN_BRACKET
                + VIEW + COLON + NUM_ONE + OR
                + EDIT + COLON + NUM_ONE + OR
                + DELETE + COLON + NUM_ONE + OR
                + ADD + COLON + NUM_ONE +
                CLOSE_BRACKET;
        result = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_OBJECT_PERMISSIONS, refdbquery, null, customWhooshModel.getRequiredColumns(), null, null, null, null, user);
        return result;
    }

    public static List<Map<String, Object>> fetchObjectPermissionsformenus(CustomWhooshModel customWhooshModel, Map<String, Object> endPointDomain, User user) throws Exception {
        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, String[]> params = new HashMap<>();
        UserAccountNGroup userAccountNGroup = fetchUserAccountNGroup(null, user.getUserID(), user);

        userAccountNGroup.getAccountGroup_sk().add(NULL_VALUE);
        params.put(ACCOUNT_GROUP_SK, userAccountNGroup.getAccountGroup_sk().toArray(new String[0]));

        List<String> accounts = userAccountNGroup.getUserAccounts()
                .parallelStream()
                .filter(stringObjectMap -> checkBlankorEmpty((String) stringObjectMap.get(GROUP_NAME)))
                .map(stringObjectMap -> (String) stringObjectMap.get(GROUP_NAME))
                .collect(Collectors.toList());
        accounts.add(NULL_VALUE);
        params.put(ACCOUNT, convertListtostringarray(accounts));
        params.put(USER_SK, new String[]{user.getUserID(), NULL_VALUE});
        params.put(STATUS_CODE, new String[]{"A"});
        String refdbquery = SFInterfaceBase.generateWhooshQueryDynamic(params);
        result = SFInterfaceBase.fetchWhooshRecords(INDEXERNAME_FETCH_OBJECT_PERMISSIONS, refdbquery, null, customWhooshModel.getRequiredColumns(), null, null, null, null, user);
        return result;
    }


    public static void updateEntitiesIndexer(List<Map<String, Object>> resultMap, String endpointName, User user) throws IOException {
        Map<String, Object> mappingjson = SFInterfaceBase.fetchValuefromTableMapping(endpointName.toLowerCase());
        String key = (String) mappingjson.get("indexerkey");
        String indexername = (String) mappingjson.get("indexername");
        if (checkBlankorEmpty(key) && checkBlankorEmpty(indexername)) {
            List<String> updatedkey = resultMap.stream()
                    .filter(
                            stringObjectMap -> stringObjectMap.get(key) != null)
                    .map(
                            stringObjectMap -> stringObjectMap.get(key).toString())
                    .collect(Collectors.toList());
            jmsTemplate.convertAndSend(INDEXER_UPDATE,
                    new IndexerDomain(indexername, SFInterfaceServices.GetStringArray(updatedkey), user.getClientInstance()));
        }
    }

    public static String[] convertcommaseparatedStringtoStringarray(String inputString) {
        if (inputString != null)
            return inputString.split(COMMA);
        else
            return new String[]{};
    }

    public static List<ApprovalModel> mapsspDetails(List<Map<String, Object>> approvals, String refreshtoken) {
        List<ApprovalModel> approvalsList = new ArrayList<>();
        approvalsList = approvals.stream()
                .map(stringObjectMap -> {
                    ApprovalModel approvalModel = new ApprovalModel();
                    approvalModel.setTicket_sk((String) stringObjectMap.get(TICKET_SK));
                    approvalModel.setTicketNumber((String) stringObjectMap.get("fbticketNumber"));
                    approvalModel.setCreatedOn((String) stringObjectMap.get(CREATED_DATE));
                    approvalModel.setSummary((String) stringObjectMap.get(SUMMARY));
                    approvalModel.setDescription((String) stringObjectMap.get("SR_Description"));
                    approvalModel.setTaskName((String) stringObjectMap.get(TASK_NAME));
                    approvalModel.setBusinessFunctionCode("SSP_TICKETS");
                    approvalModel.setApprover_sk((String) stringObjectMap.get(Approver_sk));
                    approvalModel.setFullName((String) stringObjectMap.get("ApproverLoginID"));
                    approvalModel.setStatus((String) stringObjectMap.get(STATUS));
                    approvalModel.setStatus_sk((String) stringObjectMap.get(STATUS_SK));
                    approvalModel.setStatusCode((String) stringObjectMap.get(STATUS_CODE));
                    approvalModel.setXCriteria1((String) stringObjectMap.get(X_CRITERIA_1));
                    approvalModel.setXCriteria2((String) stringObjectMap.get(X_CRITERIA_2));
                    approvalModel.setLevel((String) stringObjectMap.get(LEVEL));
                    approvalModel.setSequence((String) stringObjectMap.get(SEQUENCE));
                    approvalModel.setURL((String) stringObjectMap.get("LINK"));
                    approvalModel.setRequester((String) stringObjectMap.get("Requester"));
                    approvalModel.setAccountSecurityKey((String) stringObjectMap.get("AccountSecurityKey"));
                    approvalModel.setProcess_sk((String) stringObjectMap.get("Processsk"));
                    approvalModel.setSubmission_sk((String) stringObjectMap.get("Submission"));
                    approvalModel.setAssignedTo((String) stringObjectMap.get(ASSIGNED_INDIVIDUAL));
                    approvalModel.setPendingDate(null);
                    approvalModel.setFormID((String) stringObjectMap.get("FormId"));
                    approvalModel.setURL(generateSSPApprovalURL(approvalModel, refreshtoken));
                    return approvalModel;
                }).collect(Collectors.toList());
        return approvalsList;
    }


    public static List<ApprovalModel> mapConsolidatedApprovals(List<Map<String, Object>> approvals, String refresh_token) {
        List<ApprovalModel> approvalsList = new ArrayList<>();
        approvalsList = approvals.stream()
                .map(stringObjectMap -> {
                    ApprovalModel approvalModel = new ApprovalModel();
                    approvalModel.setTicket_sk((String) stringObjectMap.get(TICKET_SK));
                    approvalModel.setTicketNumber((String) stringObjectMap.get(TICKET_NUMBER));
                    approvalModel.setCreatedOn((String) stringObjectMap.get(CREATED_ON));
                    approvalModel.setSummary((String) stringObjectMap.get(SUMMARY));
                    approvalModel.setDescription((String) stringObjectMap.get(DESCRIPTION));
                    approvalModel.setTaskName((String) stringObjectMap.get(TASK_NAME));
                    approvalModel.setBusinessFunctionCode((String) stringObjectMap.get(BUSINESS_FUNCTION_CODE));
                    approvalModel.setApprover_sk((String) stringObjectMap.get(Approver_sk));
                    approvalModel.setFullName((String) stringObjectMap.get(FULL_NAME));
                    approvalModel.setStatus((String) stringObjectMap.get(STATUS));
                    approvalModel.setStatus_sk((String) stringObjectMap.get(STATUS_SK));
                    approvalModel.setStatusCode((String) stringObjectMap.get(STATUS_CODE));
                    approvalModel.setXCriteria1((String) stringObjectMap.get(X_CRITERIA_1));
                    approvalModel.setXCriteria2((String) stringObjectMap.get(X_CRITERIA_2));
                    approvalModel.setLevel((String) stringObjectMap.get(LEVEL));
                    approvalModel.setSequence((String) stringObjectMap.get(SEQUENCE));
                    approvalModel.setAssignedTo((String) stringObjectMap.get(URL));
                    approvalModel.setPendingDate(null);
                    approvalModel.setParentTicket((String) stringObjectMap.get("ParentTicket_sk"));
                    approvalModel.setParentTicketNumber((String) stringObjectMap.get("ParentTicketNumber"));
                    approvalModel.setAccount((String) stringObjectMap.get(ACCOUNT));
                    approvalModel.setMasterAccount((String) stringObjectMap.get(MASTER_ACCOUNT));
                    approvalModel.setPendingDate(null);
                    approvalModel.setURL(generateCRApprovalURL(approvalModel, refresh_token));
                    return approvalModel;
                }).collect(Collectors.toList());
        return approvalsList;
    }

    public static String generateSSPApprovalURL(ApprovalModel approvalmodel, String refreshtoken) {
        if (checkBlankorEmpty(approvalmodel.getAccountSecurityKey())
                && checkBlankorEmpty(approvalmodel.getFormID())
                && checkBlankorEmpty(approvalmodel.getSubmission_sk())
                && checkBlankorEmpty(approvalmodel.getProcess_sk())
        ) {
            Map<String, String[]> params = new HashMap<>();
            params.put(REFRESH_TOKEN, new String[]{refreshtoken});
            params.put(SF_FORM_ID, new String[]{approvalmodel.getFormID()});
            params.put(SF_PROCESS_ID, new String[]{approvalmodel.getProcess_sk()});
            params.put(SF_SUBMISSION_ID, new String[]{approvalmodel.getSubmission_sk()});
            params.put(URL_KEY, new String[]{approvalmodel.getAccountSecurityKey()});
            return getDBQuery(SFInterfaceConstants.getSsp_approval_url(), params);
        }
        return null;
    }


    public static String generateCRApprovalURL(ApprovalModel approvalmodel, String refreshtoken) {
        if (checkBlankorEmpty(approvalmodel.getParentTicketNumber())
                && checkBlankorEmpty(approvalmodel.getParentTicket())
                && checkBlankorEmpty(approvalmodel.getAccount())
                && checkBlankorEmpty(approvalmodel.getMasterAccount())
        ) {
            String url = CR_TICKET_DEFAULT_URL;
            Map<String, String[]> params = new HashMap<>();
            params.put(REFRESH_TOKEN, new String[]{refreshtoken});
            params.put(TICKET, new String[]{approvalmodel.getParentTicketNumber()});
            params.put(TICKET_SK, new String[]{approvalmodel.getParentTicket()});
            params.put(ACCOUNT, new String[]{approvalmodel.getAccount()});
            params.put(MASTER_ACCOUNT, new String[]{approvalmodel.getMasterAccount()});
            if (checkBlankorEmpty(approvalmodel.getBusinessFunctionCode()) && approvalmodel.getBusinessFunctionCode().equalsIgnoreCase(CRT)) {
                params.put(TASK_SK, new String[]{approvalmodel.getTicket_sk()});
                params.put("TaskNumber", new String[]{approvalmodel.getTicketNumber()});
            }
            if (checkBlankorEmpty(approvalmodel.getBusinessFunctionCode()) && approvalmodel.getBusinessFunctionCode().equalsIgnoreCase(CRAPPR)) {
                params.put(APPROVAL_SK, new String[]{approvalmodel.getTicket_sk()});
                params.put(APPROVAL_NUMBER, new String[]{approvalmodel.getTicketNumber()});
            }
            return getDBQuery(url, params);
        }
        return null;
    }

    public static Map<String, Object> createDmartChangeRequest(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 148); // 75 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(2, params.containsKey(CR_NUMBER) ? getValue(params.get(CR_NUMBER)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(4, params.containsKey(LEVEL) ? getValue(params.get(LEVEL)) : null);
                        callableStatement.setString(5, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(7, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(8, params.containsKey(AUDIT_LOG) ? getValue(params.get(AUDIT_LOG)) : null);
                        callableStatement.setString(9, params.containsKey(REQUEST_TYPE) ? getValue(params.get(REQUEST_TYPE)) : null);
                        callableStatement.setString(10, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(11, params.containsKey(PLATFORM) ? getValue(params.get(PLATFORM)) : null);
                        callableStatement.setString(12, params.containsKey(RISK_LEVEL) ? getValue(params.get(RISK_LEVEL)) : null);
                        callableStatement.setString(13, params.containsKey(SYSTEM) ? getValue(params.get(SYSTEM)) : null);
                        callableStatement.setString(14, params.containsKey(REQUESTER_LOGIN) ? getValue(params.get(REQUESTER_LOGIN)) : null);
                        callableStatement.setString(15, params.containsKey(LOCATION_OF_CHANGE) ? getValue(params.get(LOCATION_OF_CHANGE)) : null);
                        callableStatement.setString(16, params.containsKey(TYPE_OF_CHANGE) ? getValue(params.get(TYPE_OF_CHANGE)) : null);
                        callableStatement.setString(17, params.containsKey(REASON_FOR_CHANGE) ? getValue(params.get(REASON_FOR_CHANGE)) : null);
                        callableStatement.setString(18, params.containsKey(REFERENCE) ? getValue(params.get(REFERENCE)) : null);
                        callableStatement.setString(19, params.containsKey(CLIENT_USER_IMPACT) ? getValue(params.get(CLIENT_USER_IMPACT)) : null);
                        callableStatement.setString(20, params.containsKey(EXTERNAL_ACCOUNTCODE) ? getValue(params.get(EXTERNAL_ACCOUNTCODE)) : null);
                        callableStatement.setString(21, params.containsKey(EFFECTED_ACCOUNTCODE) ? getValue(params.get(EFFECTED_ACCOUNTCODE)) : null);
                        callableStatement.setString(22, params.containsKey(EFFECTED_LOCATION) ? getValue(params.get(EFFECTED_LOCATION)) : null);
                        callableStatement.setString(23, params.containsKey(REQUESTER_GROUP_NAME) ? getValue(params.get(REQUESTER_GROUP_NAME)) : null);
                        callableStatement.setString(24, params.containsKey(REQUESTER_NAME) ? getValue(params.get(REQUESTER_NAME)) : null);
                        callableStatement.setString(25, params.containsKey(IS_CAB_MEMBER) ? getValue(params.get(IS_CAB_MEMBER)) : null);
                        callableStatement.setString(26, params.containsKey(REVIEWER_COMMENTS) ? getValue(params.get(REVIEWER_COMMENTS)) : null);
                        callableStatement.setString(27, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(28, params.containsKey(IMPLEMENTATION_RESULTS) ? getValue(params.get(IMPLEMENTATION_RESULTS)) : null);
                        callableStatement.setString(29, params.containsKey(RESULT_DETAILS) ? getValue(params.get(RESULT_DETAILS)) : null);
                        callableStatement.setString(30, params.containsKey(STATUS_OF_CHANGE) ? getValue(params.get(STATUS_OF_CHANGE)) : null);
                        callableStatement.setString(31, params.containsKey(ATTACHMENT_FIELD1) ? getValue(params.get(ATTACHMENT_FIELD1)) : null);
                        callableStatement.setString(32, params.containsKey(ATTACHMENT_FIELD2) ? getValue(params.get(ATTACHMENT_FIELD2)) : null);
                        callableStatement.setString(33, params.containsKey(ATTACHMENT_FIELD3) ? getValue(params.get(ATTACHMENT_FIELD3)) : null);
                        callableStatement.setString(34, params.containsKey(ATTACHMENT_FIELD4) ? getValue(params.get(ATTACHMENT_FIELD4)) : null);
                        callableStatement.setString(35, params.containsKey(ATTACHMENT_FIELD5) ? getValue(params.get(ATTACHMENT_FIELD5)) : null);
                        callableStatement.setString(36, params.containsKey(CHANGE_PROJECT_NAME) ? getValue(params.get(CHANGE_PROJECT_NAME)) : null);
                        callableStatement.setString(37, params.containsKey(CLIENT_CHANGE_NAME) ? getValue(params.get(CLIENT_CHANGE_NAME)) : null);
                        callableStatement.setString(38, params.containsKey(PROJECT_NAME) ? getValue(params.get(PROJECT_NAME)) : null);
                        callableStatement.setString(39, params.containsKey(CHANGE_OWNER_NAME) ? getValue(params.get(CHANGE_OWNER_NAME)) : null);
                        callableStatement.setString(40, params.containsKey(ESTIMATED_DOWN_TIME) ? getValue(params.get(ESTIMATED_DOWN_TIME)) : null);
                        callableStatement.setString(41, params.containsKey(DOWNTIME) ? getValue(params.get(DOWNTIME)) : null);
                        callableStatement.setString(42, params.containsKey(DURATION) ? getValue(params.get(DURATION)) : null);
                        callableStatement.setString(43, params.containsKey(EST_BACKOUT_TIME) ? getValue(params.get(EST_BACKOUT_TIME)) : null);
                        callableStatement.setString(44, params.containsKey(ACTUAL_DOWNTIME) ? getValue(params.get(ACTUAL_DOWNTIME)) : null);
                        callableStatement.setString(45, params.containsKey(LEAD_DAYS) ? getValue(params.get(LEAD_DAYS)) : null);
                        callableStatement.setString(46, params.containsKey(OVERRIDE) ? getValue(params.get(OVERRIDE)) : null);
                        callableStatement.setString(47, params.containsKey(OVERRIDE_REASON) ? getValue(params.get(OVERRIDE_REASON)) : null);
                        callableStatement.setString(48, params.containsKey(ReadinessRemarks) ? getValue(params.get(ReadinessRemarks)) : null);
                        callableStatement.setString(49, params.containsKey(REQUESTED_ON) ? getValue(params.get(REQUESTED_ON)) : null);
                        callableStatement.setString(50, params.containsKey(SCHEDULED_ON) ? getValue(params.get(SCHEDULED_ON)) : null);
                        callableStatement.setString(51, params.containsKey(CANCELLED_ON) ? getValue(params.get(CANCELLED_ON)) : null);
                        callableStatement.setString(52, params.containsKey(ACTUAL_INSTALL_DATE) ? getValue(params.get(ACTUAL_INSTALL_DATE)) : null);
                        callableStatement.setString(53, params.containsKey(TASK_START_DATE) ? getValue(params.get(TASK_START_DATE)) : null);
                        callableStatement.setString(54, params.containsKey(TASK_END_DATE) ? getValue(params.get(TASK_END_DATE)) : null);
                        callableStatement.setString(55, params.containsKey(EST_CRITICAL_USERDOWNTIME) ? getValue(params.get(EST_CRITICAL_USERDOWNTIME)) : null);
                        callableStatement.setString(56, params.containsKey(EST_IMPACTED_USERS) ? getValue(params.get(EST_IMPACTED_USERS)) : null);
                        callableStatement.setString(57, params.containsKey(EMAIL_SUBJECT) ? getValue(params.get(EMAIL_SUBJECT)) : null);
                        callableStatement.setString(58, params.containsKey(REQUEST_COUNT) ? getValue(params.get(REQUEST_COUNT)) : null);
                        callableStatement.setString(59, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(60, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(61, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(62, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(63, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(64, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(65, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(66, params.containsKey(ATTRIBUTE_8) ? getValue(params.get(ATTRIBUTE_8)) : null);
                        callableStatement.setString(67, params.containsKey(ATTRIBUTE_9) ? getValue(params.get(ATTRIBUTE_9)) : null);
                        callableStatement.setString(68, params.containsKey(SUBMITTED_BY) ? getValue(params.get(SUBMITTED_BY)) : null);
                        callableStatement.setString(69, params.containsKey(CREATED_ON) ? getValue(params.get(CREATED_ON)) : null);
                        callableStatement.setString(70, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(71, params.containsKey(IMPACTED_COMMUNITY) ? getValue(params.get(IMPACTED_COMMUNITY)) : null);
                        callableStatement.setString(72, params.containsKey(ACTUAL_START_DATE) ? getValue(params.get(ACTUAL_START_DATE)) : null);
                        callableStatement.setString(73, params.containsKey(ACTUAL_END_DATE) ? getValue(params.get(ACTUAL_END_DATE)) : null);
                        callableStatement.setString(74, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(75, params.containsKey(RISK_LEVEL_SK) ? getValue(params.get(RISK_LEVEL_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartChangeRequest(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 148); // 75 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(2, params.containsKey(CR_NUMBER) ? getValue(params.get(CR_NUMBER)) : null);
                        callableStatement.setString(3, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(4, params.containsKey(LEVEL) ? getValue(params.get(LEVEL)) : null);
                        callableStatement.setString(5, params.containsKey(TYPE) ? getValue(params.get(TYPE)) : null);
                        callableStatement.setString(6, params.containsKey(DESCRIPTION) ? getValue(params.get(DESCRIPTION)) : null);
                        callableStatement.setString(7, params.containsKey(WORK_LOG) ? getValue(params.get(WORK_LOG)) : null);
                        callableStatement.setString(8, params.containsKey(AUDIT_LOG) ? getValue(params.get(AUDIT_LOG)) : null);
                        callableStatement.setString(9, params.containsKey(REQUEST_TYPE) ? getValue(params.get(REQUEST_TYPE)) : null);
                        callableStatement.setString(10, params.containsKey(CATEGORY) ? getValue(params.get(CATEGORY)) : null);
                        callableStatement.setString(11, params.containsKey(PLATFORM) ? getValue(params.get(PLATFORM)) : null);
                        callableStatement.setString(12, params.containsKey(RISK_LEVEL) ? getValue(params.get(RISK_LEVEL)) : null);
                        callableStatement.setString(13, params.containsKey(SYSTEM) ? getValue(params.get(SYSTEM)) : null);
                        callableStatement.setString(14, params.containsKey(REQUESTER_LOGIN) ? getValue(params.get(REQUESTER_LOGIN)) : null);
                        callableStatement.setString(15, params.containsKey(LOCATION_OF_CHANGE) ? getValue(params.get(LOCATION_OF_CHANGE)) : null);
                        callableStatement.setString(16, params.containsKey(TYPE_OF_CHANGE) ? getValue(params.get(TYPE_OF_CHANGE)) : null);
                        callableStatement.setString(17, params.containsKey(REASON_FOR_CHANGE) ? getValue(params.get(REASON_FOR_CHANGE)) : null);
                        callableStatement.setString(18, params.containsKey(REFERENCE) ? getValue(params.get(REFERENCE)) : null);
                        callableStatement.setString(19, params.containsKey(CLIENT_USER_IMPACT) ? getValue(params.get(CLIENT_USER_IMPACT)) : null);
                        callableStatement.setString(20, params.containsKey(EXTERNAL_ACCOUNTCODE) ? getValue(params.get(EXTERNAL_ACCOUNTCODE)) : null);
                        callableStatement.setString(21, params.containsKey(EFFECTED_ACCOUNTCODE) ? getValue(params.get(EFFECTED_ACCOUNTCODE)) : null);
                        callableStatement.setString(22, params.containsKey(EFFECTED_LOCATION) ? getValue(params.get(EFFECTED_LOCATION)) : null);
                        callableStatement.setString(23, params.containsKey(REQUESTER_GROUP_NAME) ? getValue(params.get(REQUESTER_GROUP_NAME)) : null);
                        callableStatement.setString(24, params.containsKey(REQUESTER_NAME) ? getValue(params.get(REQUESTER_NAME)) : null);
                        callableStatement.setString(25, params.containsKey(IS_CAB_MEMBER) ? getValue(params.get(IS_CAB_MEMBER)) : null);
                        callableStatement.setString(26, params.containsKey(REVIEWER_COMMENTS) ? getValue(params.get(REVIEWER_COMMENTS)) : null);
                        callableStatement.setString(27, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(28, params.containsKey(IMPLEMENTATION_RESULTS) ? getValue(params.get(IMPLEMENTATION_RESULTS)) : null);
                        callableStatement.setString(29, params.containsKey(RESULT_DETAILS) ? getValue(params.get(RESULT_DETAILS)) : null);
                        callableStatement.setString(30, params.containsKey(STATUS_OF_CHANGE) ? getValue(params.get(STATUS_OF_CHANGE)) : null);
                        callableStatement.setString(31, params.containsKey(ATTACHMENT_FIELD1) ? getValue(params.get(ATTACHMENT_FIELD1)) : null);
                        callableStatement.setString(32, params.containsKey(ATTACHMENT_FIELD2) ? getValue(params.get(ATTACHMENT_FIELD2)) : null);
                        callableStatement.setString(33, params.containsKey(ATTACHMENT_FIELD3) ? getValue(params.get(ATTACHMENT_FIELD3)) : null);
                        callableStatement.setString(34, params.containsKey(ATTACHMENT_FIELD4) ? getValue(params.get(ATTACHMENT_FIELD4)) : null);
                        callableStatement.setString(35, params.containsKey(ATTACHMENT_FIELD5) ? getValue(params.get(ATTACHMENT_FIELD5)) : null);
                        callableStatement.setString(36, params.containsKey(CHANGE_PROJECT_NAME) ? getValue(params.get(CHANGE_PROJECT_NAME)) : null);
                        callableStatement.setString(37, params.containsKey(CLIENT_CHANGE_NAME) ? getValue(params.get(CLIENT_CHANGE_NAME)) : null);
                        callableStatement.setString(38, params.containsKey(PROJECT_NAME) ? getValue(params.get(PROJECT_NAME)) : null);
                        callableStatement.setString(39, params.containsKey(CHANGE_OWNER_NAME) ? getValue(params.get(CHANGE_OWNER_NAME)) : null);
                        callableStatement.setString(40, params.containsKey(ESTIMATED_DOWN_TIME) ? getValue(params.get(ESTIMATED_DOWN_TIME)) : null);
                        callableStatement.setString(41, params.containsKey(DOWNTIME) ? getValue(params.get(DOWNTIME)) : null);
                        callableStatement.setString(42, params.containsKey(DURATION) ? getValue(params.get(DURATION)) : null);
                        callableStatement.setString(43, params.containsKey(EST_BACKOUT_TIME) ? getValue(params.get(EST_BACKOUT_TIME)) : null);
                        callableStatement.setString(44, params.containsKey(ACTUAL_DOWNTIME) ? getValue(params.get(ACTUAL_DOWNTIME)) : null);
                        callableStatement.setString(45, params.containsKey(LEAD_DAYS) ? getValue(params.get(LEAD_DAYS)) : null);
                        callableStatement.setString(46, params.containsKey(OVERRIDE) ? getValue(params.get(OVERRIDE)) : null);
                        callableStatement.setString(47, params.containsKey(OVERRIDE_REASON) ? getValue(params.get(OVERRIDE_REASON)) : null);
                        callableStatement.setString(48, params.containsKey(ReadinessRemarks) ? getValue(params.get(ReadinessRemarks)) : null);
                        callableStatement.setString(49, params.containsKey(REQUESTED_ON) ? getValue(params.get(REQUESTED_ON)) : null);
                        callableStatement.setString(50, params.containsKey(SCHEDULED_ON) ? getValue(params.get(SCHEDULED_ON)) : null);
                        callableStatement.setString(51, params.containsKey(CANCELLED_ON) ? getValue(params.get(CANCELLED_ON)) : null);
                        callableStatement.setString(52, params.containsKey(ACTUAL_INSTALL_DATE) ? getValue(params.get(ACTUAL_INSTALL_DATE)) : null);
                        callableStatement.setString(53, params.containsKey(TASK_START_DATE) ? getValue(params.get(TASK_START_DATE)) : null);
                        callableStatement.setString(54, params.containsKey(TASK_END_DATE) ? getValue(params.get(TASK_END_DATE)) : null);
                        callableStatement.setString(55, params.containsKey(EST_CRITICAL_USERDOWNTIME) ? getValue(params.get(EST_CRITICAL_USERDOWNTIME)) : null);
                        callableStatement.setString(56, params.containsKey(EST_IMPACTED_USERS) ? getValue(params.get(EST_IMPACTED_USERS)) : null);
                        callableStatement.setString(57, params.containsKey(EMAIL_SUBJECT) ? getValue(params.get(EMAIL_SUBJECT)) : null);
                        callableStatement.setString(58, params.containsKey(REQUEST_COUNT) ? getValue(params.get(REQUEST_COUNT)) : null);
                        callableStatement.setString(59, params.containsKey(ATTRIBUTE_1) ? getValue(params.get(ATTRIBUTE_1)) : null);
                        callableStatement.setString(60, params.containsKey(ATTRIBUTE_2) ? getValue(params.get(ATTRIBUTE_2)) : null);
                        callableStatement.setString(61, params.containsKey(ATTRIBUTE_3) ? getValue(params.get(ATTRIBUTE_3)) : null);
                        callableStatement.setString(62, params.containsKey(ATTRIBUTE_4) ? getValue(params.get(ATTRIBUTE_4)) : null);
                        callableStatement.setString(63, params.containsKey(ATTRIBUTE_5) ? getValue(params.get(ATTRIBUTE_5)) : null);
                        callableStatement.setString(64, params.containsKey(ATTRIBUTE_6) ? getValue(params.get(ATTRIBUTE_6)) : null);
                        callableStatement.setString(65, params.containsKey(ATTRIBUTE_7) ? getValue(params.get(ATTRIBUTE_7)) : null);
                        callableStatement.setString(66, params.containsKey(ATTRIBUTE_8) ? getValue(params.get(ATTRIBUTE_8)) : null);
                        callableStatement.setString(67, params.containsKey(ATTRIBUTE_9) ? getValue(params.get(ATTRIBUTE_9)) : null);
                        callableStatement.setString(68, params.containsKey(SUBMITTED_BY) ? getValue(params.get(SUBMITTED_BY)) : null);
                        callableStatement.setString(69, params.containsKey(MODIFIED_ON) ? getValue(params.get(MODIFIED_ON)) : null);
                        callableStatement.setString(70, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(71, params.containsKey(IMPACTED_COMMUNITY) ? getValue(params.get(IMPACTED_COMMUNITY)) : null);
                        callableStatement.setString(72, params.containsKey(ACTUAL_START_DATE) ? getValue(params.get(ACTUAL_START_DATE)) : null);
                        callableStatement.setString(73, params.containsKey(ACTUAL_END_DATE) ? getValue(params.get(ACTUAL_END_DATE)) : null);
                        callableStatement.setString(74, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(75, params.containsKey(RISK_LEVEL_SK) ? getValue(params.get(RISK_LEVEL_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> createDmartCRTask(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 58); // 30 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CRT_NUMBER) ? getValue(params.get(CRT_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_CODE) ? getValue(params.get(TASK_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(CR_NUMBER) ? getValue(params.get(CR_NUMBER)) : null);
                        callableStatement.setString(4, params.containsKey(PARENT_CRT) ? getValue(params.get(PARENT_CRT)) : null);
                        callableStatement.setString(5, params.containsKey(TASK_DETAIL) ? getValue(params.get(TASK_DETAIL)) : null);
                        callableStatement.setString(6, params.containsKey(TASK_NAME) ? getValue(params.get(TASK_NAME)) : null);
                        callableStatement.setString(7, params.containsKey(TASK_TYPE) ? getValue(params.get(TASK_TYPE)) : null);
                        callableStatement.setString(8, params.containsKey(CLIENT_VENDOR) ? getValue(params.get(CLIENT_VENDOR)) : null);
                        callableStatement.setString(9, params.containsKey(VENDOR_TICKET_NUMBER) ? getValue(params.get(VENDOR_TICKET_NUMBER)) : null);
                        callableStatement.setString(10, params.containsKey(IMPLEMENTATION_STATUS) ? getValue(params.get(IMPLEMENTATION_STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(RESULTS) ? getValue(params.get(RESULTS)) : null);
                        callableStatement.setString(12, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(13, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(14, params.containsKey(INSTALL_ON) ? getValue(params.get(INSTALL_ON)) : null);
                        callableStatement.setString(15, params.containsKey(DOWN_TIME) ? getValue(params.get(DOWN_TIME)) : null);
                        callableStatement.setString(16, params.containsKey(EST_START_TIME) ? getValue(params.get(EST_START_TIME)) : null);
                        callableStatement.setString(17, params.containsKey(EST_END_TIME) ? getValue(params.get(EST_END_TIME)) : null);
                        callableStatement.setString(18, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(19, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(20, params.containsKey(ESTIMATED_EFFORT) ? getValue(params.get(ESTIMATED_EFFORT)) : null);
                        callableStatement.setString(21, params.containsKey(ACTUAL_EFFORT) ? getValue(params.get(ACTUAL_EFFORT)) : null);
                        callableStatement.setString(22, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(23, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(24, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(25, params.containsKey(APPROVAL_CRITERIA) ? getValue(params.get(APPROVAL_CRITERIA)) : null);
                        callableStatement.setString(26, params.containsKey(CREATED_ON) ? getValue(params.get(CREATED_ON)) : null);
                        callableStatement.setString(27, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(28, params.containsKey(ACCOUNT_CODE) ? getValue(params.get(ACCOUNT_CODE)) : null);
                        callableStatement.setString(29, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(30, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartCRTask(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 58); // 30 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CRT_NUMBER) ? getValue(params.get(CRT_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_CODE) ? getValue(params.get(TASK_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(CR_NUMBER) ? getValue(params.get(CR_NUMBER)) : null);
                        callableStatement.setString(4, params.containsKey(PARENT_CRT) ? getValue(params.get(PARENT_CRT)) : null);
                        callableStatement.setString(5, params.containsKey(TASK_DETAIL) ? getValue(params.get(TASK_DETAIL)) : null);
                        callableStatement.setString(6, params.containsKey(TASK_NAME) ? getValue(params.get(TASK_NAME)) : null);
                        callableStatement.setString(7, params.containsKey(TASK_TYPE) ? getValue(params.get(TASK_TYPE)) : null);
                        callableStatement.setString(8, params.containsKey(CLIENT_VENDOR) ? getValue(params.get(CLIENT_VENDOR)) : null);
                        callableStatement.setString(9, params.containsKey(VENDOR_TICKET_NUMBER) ? getValue(params.get(VENDOR_TICKET_NUMBER)) : null);
                        callableStatement.setString(10, params.containsKey(IMPLEMENTATION_STATUS) ? getValue(params.get(IMPLEMENTATION_STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(RESULTS) ? getValue(params.get(RESULTS)) : null);
                        callableStatement.setString(12, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(13, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(14, params.containsKey(INSTALL_ON) ? getValue(params.get(INSTALL_ON)) : null);
                        callableStatement.setString(15, params.containsKey(DOWN_TIME) ? getValue(params.get(DOWN_TIME)) : null);
                        callableStatement.setString(16, params.containsKey(EST_START_TIME) ? getValue(params.get(EST_START_TIME)) : null);
                        callableStatement.setString(17, params.containsKey(EST_END_TIME) ? getValue(params.get(EST_END_TIME)) : null);
                        callableStatement.setString(18, params.containsKey(ACTUAL_START_TIME) ? getValue(params.get(ACTUAL_START_TIME)) : null);
                        callableStatement.setString(19, params.containsKey(ACTUAL_END_TIME) ? getValue(params.get(ACTUAL_END_TIME)) : null);
                        callableStatement.setString(20, params.containsKey(ESTIMATED_EFFORT) ? getValue(params.get(ESTIMATED_EFFORT)) : null);
                        callableStatement.setString(21, params.containsKey(ACTUAL_EFFORT) ? getValue(params.get(ACTUAL_EFFORT)) : null);
                        callableStatement.setString(22, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(23, params.containsKey(IS_MANDATORY) ? getValue(params.get(IS_MANDATORY)) : null);
                        callableStatement.setString(24, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(25, params.containsKey(APPROVAL_CRITERIA) ? getValue(params.get(APPROVAL_CRITERIA)) : null);
                        callableStatement.setString(26, params.containsKey(MODIFIED_ON) ? getValue(params.get(MODIFIED_ON)) : null);
                        callableStatement.setString(27, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(28, params.containsKey(ACCOUNT_CODE) ? getValue(params.get(ACCOUNT_CODE)) : null);
                        callableStatement.setString(29, params.containsKey(ASSIGNED_INDIVIDUAL) ? getValue(params.get(ASSIGNED_INDIVIDUAL)) : null);
                        callableStatement.setString(30, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }


    public static List<Map<String, Object>> fetchWhooshDynamic(HttpServletRequest request, String version, String endpointName, User user, EndpointValidationModel endpointValidationModel, Boolean pagination) throws Exception {
        return fetchWhooshDynamicwithLikeOperator(request, version, endpointName, user, endpointValidationModel, pagination, false);
    }

    public static List<Map<String, Object>> fetchWhooshDynamic(HttpServletRequest request, String version, String endpointName, User user,
                                                               EndpointValidationModel endpointValidationModel, Boolean pagination, Boolean likeoperator, Boolean defaultnull) throws Exception {
        Map<String, Object> endPointDomain = new HashMap<>();
        endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpointName, version, BOTH_METHOD, user);
        CustomWhooshModel customWhooshModel = SFInterfaceBase.generateWhooshModel(endpointValidationModel.getRequestparametermap(), Boolean.TRUE
                , endPointDomain.get(ENDPOINT_SK).toString(), likeoperator, defaultnull, user);

        SFInterfaceLoggerBase.log(LOGGER, Constants.FETCH, endpointName, customWhooshModel.getQuery(), version,
                endpointValidationModel.getRequestparametermap() != null ? endpointValidationModel.getRequestparametermap().toString() : "",
                user.getUserID(), user.getAuthUserName(), null);
        if (endpointValidationModel.isAuth_endpoint()) {
            String authQuery = SFInterfaceBase.fetchAuthQuery(endpointName
                    , user.getUserID()
                    , endpointValidationModel.getAuth_columnMapping(), user);
            if (authQuery != null && !authQuery.isEmpty()) {
                customWhooshModel.setQuery(customWhooshModel.getQuery() + AND + authQuery);
            }
        }
        return SFInterfaceBase.fetchWhooshRecords(endPointDomain.get(INDEX_NAME).toString()
                , customWhooshModel.getQuery()
                , customWhooshModel.getSort()
                , customWhooshModel.getRequiredColumns()
                , customWhooshModel.getSortfields()
                , customWhooshModel.getSortorder()
                , customWhooshModel.getDistinct()
                , customWhooshModel.getFieldaliass()
                , customWhooshModel.getCount()
                , likeoperator
                , customWhooshModel.getDistinctfield()
                , customWhooshModel.getPageno()
                , pagination, user);
    }

    public static List<Map<String, Object>> fetchWhooshDynamicwithLikeOperator(HttpServletRequest request, String version, String endpointName, User user, EndpointValidationModel endpointValidationModel, Boolean pagination, Boolean likeoperator) throws Exception {
        return fetchWhooshDynamic(request, version, endpointName, user, endpointValidationModel, pagination, likeoperator, false);
    }

    public static Map<String, Object> mapApproversinApprovalCriteria(Map<String, Object> approvalCriteria, List<Map<String, Object>> approvers) {

        //approvers = sortApproversoneachlevel(approvers);
        approvalCriteria.put(APPROVERS, approvers);
        return approvalCriteria;
    }

  /*  public static List<Map<String, Object>> sortApproversoneachlevel(List<Map<String, Object>> approvers) {
        approvers = sortNDistinct(approvers, "Level,Sequence", ASC, null, null);
        return approvers;
    }
*/

    public static Map<String, Object> updateRDYWizard(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 34); // 18 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(WIZ_ITEM_SK) ? getValue(params.get(WIZ_ITEM_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(PARENT_WIZITEM_SK) ? getDBValidatedValue(params.get(PARENT_WIZITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(CATEGORY_SK) ? getDBValidatedValue(params.get(CATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(CATEGORY) ? getDBValidatedValue(params.get(CATEGORY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(LEVEL_NO) ? getDBValidatedValue(params.get(LEVEL_NO), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(SEQ_NO) ? getDBValidatedValue(params.get(SEQ_NO), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(BUTTON_TYPE) ? getDBValidatedValue(params.get(BUTTON_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(9, params.containsKey(ATTRIBUTE) ? getDBValidatedValue(params.get(ATTRIBUTE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(10, params.containsKey(SUBMISSION_TYPE) ? getDBValidatedValue(params.get(SUBMISSION_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(11, params.containsKey(ICON) ? getDBValidatedValue(params.get(ICON), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(12, params.containsKey(LABEL) ? getDBValidatedValue(params.get(LABEL), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(13, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(14, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(15, params.containsKey(IS_DELETED) ? getValue(params.get(IS_DELETED)) : null);
                        callableStatement.setString(16, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(17, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(18, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateRoundRobinRule(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ROUND_ROBIN_RULE_SK) ? getValue(params.get(ROUND_ROBIN_RULE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ROUND_ROBIN_RULE_CODE) ? getValue(params.get(ROUND_ROBIN_RULE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ROUND_ROBIN_RULE) ? getValue(params.get(ROUND_ROBIN_RULE)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAuthenticationType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(AUTH_TYPE_SK) ? getValue(params.get(AUTH_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(AUTH_TYPE_CODE) ? getValue(params.get(AUTH_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(AUTH_TYPE) ? getValue(params.get(AUTH_TYPE)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateMasterType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 40); // 21 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18
            paramList.add(varString); //19
            paramList.add(varString); //20
            paramList.add(varString); //21

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(MASTER_TYPE_SK) ? getValue(params.get(MASTER_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(PARENT_SK) ? getDBValidatedValue(params.get(PARENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(MASTER_TYPE_CODE) ? getValue(params.get(MASTER_TYPE_CODE)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(MASTER_TYPE) ? getDBValidatedValue(params.get(MASTER_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(7, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(8, params.containsKey(LEVEL) ? getDBValidatedValue(params.get(LEVEL), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(13, params.containsKey(START) ? getDBValidatedValue(params.get(START), DATATYPE_DATETIME) : null);
                        callableStatement.setString(14, params.containsKey(END) ? getDBValidatedValue(params.get(END), DATATYPE_DATETIME) : null);
                        callableStatement.setString(15, params.containsKey(TYPE) ? getDBValidatedValue(params.get(TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(16, params.containsKey(SELECTION_TYPE) ? getDBValidatedValue(params.get(SELECTION_TYPE), DATATYPE_CHAR) : null);
                        callableStatement.setString(17, params.containsKey(ATTRIBUTE_1) ? getDBValidatedValue(params.get(ATTRIBUTE_1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(18, params.containsKey(ATTRIBUTE_2) ? getDBValidatedValue(params.get(ATTRIBUTE_2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(19, params.containsKey(ATTRIBUTE_3) ? getDBValidatedValue(params.get(ATTRIBUTE_3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(20, params.containsKey(ATTRIBUTE_4) ? getDBValidatedValue(params.get(ATTRIBUTE_4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(21, params.containsKey(ATTRIBUTE_5) ? getDBValidatedValue(params.get(ATTRIBUTE_5), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAlertStatus(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ALERT_STATUS_SK) ? getValue(params.get(ALERT_STATUS_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ALERT_STATUS_CODE) ? getValue(params.get(ALERT_STATUS_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ALERT_STATUS) ? getDBValidatedValue(params.get(ALERT_STATUS), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateUserType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_TYPE_SK) ? getValue(params.get(USER_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_TYPE_CODE) ? getValue(params.get(USER_TYPE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(USER_TYPE) ? getDBValidatedValue(params.get(USER_TYPE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSeverity(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SEVERITY_SK) ? getValue(params.get(SEVERITY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SEVERITY_CODE) ? getValue(params.get(SEVERITY_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(SEVERITY) ? getDBValidatedValue(params.get(SEVERITY), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateTaskAssignmentGroup(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9


            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TASK_ASSIGNMENT_GROUP_SK) ? getValue(params.get(TASK_ASSIGNMENT_GROUP_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_DETAILS_SK) ? getDBValidatedValue(params.get(TASK_DETAILS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ASSIGNED_GROUP_SK) ? getDBValidatedValue(params.get(ASSIGNED_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(ASSIGNED_INDIVIDUALSK) ? getDBValidatedValue(params.get(ASSIGNED_INDIVIDUALSK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(APPROVAL_CRITERIA_SK) ? getDBValidatedValue(params.get(APPROVAL_CRITERIA_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(STATUS_SK) ? getDBValidatedValue(params.get(STATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(9, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateTitle(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(TITLE_SK) ? getValue(params.get(TITLE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(TITLE_CODE) ? getValue(params.get(TITLE_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(TITLE) ? getDBValidatedValue(params.get(TITLE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateUserHierarchy(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_HIERARCHY_SK) ? getValue(params.get(USER_HIERARCHY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(REPORTING_SK) ? getValue(params.get(REPORTING_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MENTOR_SK) ? getDBValidatedValue(params.get(MENTOR_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateUserNotesVisibility(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_NOTES_VISIBILITY_SK) ? getValue(params.get(USER_NOTES_VISIBILITY_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USERNOTE_SK) ? getValue(params.get(USERNOTE_SK)) : null);
                        callableStatement.setString(3, params.containsKey(VISBILITY_USER_SK) ? getDBValidatedValue(params.get(VISBILITY_USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(VISIBILITY_GROUP_SK) ? getDBValidatedValue(params.get(VISIBILITY_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateUserSkillSets(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_SKILL_SET_SK) ? getValue(params.get(USER_SKILL_SET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(USER_SK) ? getValue(params.get(USER_SK)) : null);
                        callableStatement.setString(3, params.containsKey(SKILL_SET_SK) ? getValue(params.get(SKILL_SET_SK)) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateInstructions(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 60); // 31 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); // 1
            paramList.add(varString); // 2
            paramList.add(varString); // 3
            paramList.add(varString); // 4
            paramList.add(varString); // 5
            paramList.add(varString); // 6
            paramList.add(varString); // 7
            paramList.add(varString); // 8
            paramList.add(varString); // 9
            paramList.add(varString); // 10
            paramList.add(varString); // 11
            paramList.add(varString); // 12
            paramList.add(varString); // 13
            paramList.add(varString); // 14
            paramList.add(varString); // 15
            paramList.add(varString); // 16
            paramList.add(varString); // 17
            paramList.add(varString); // 18
            paramList.add(varString); // 19
            paramList.add(varString); // 20
            paramList.add(varString); // 21
            paramList.add(varString); // 22
            paramList.add(varString); // 23
            paramList.add(varString); // 24
            paramList.add(varString); // 25
            paramList.add(varString); // 26
            paramList.add(varString); // 27
            paramList.add(varString); // 28
            paramList.add(varString); // 29
            paramList.add(varString); // 30
            paramList.add(varString); // 31

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(INSTRUCTION_SK) ? getValue(params.get(INSTRUCTION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(INSTRUCTION_CODE) ? getValue(params.get(INSTRUCTION_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(X_BUILDING_SK) ? getDBValidatedValue(params.get(X_BUILDING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(5, params.containsKey(X_DEPARTMENT_SK) ? getDBValidatedValue(params.get(X_DEPARTMENT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(6, params.containsKey(X_BUSINESS_FUNCTION_SK) ? getDBValidatedValue(params.get(X_BUSINESS_FUNCTION_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(XCATEGORY_SK) ? getDBValidatedValue(params.get(XCATEGORY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(XTYPE_SK) ? getDBValidatedValue(params.get(XTYPE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(XITEM_SK) ? getDBValidatedValue(params.get(XITEM_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(X_PRIORITY_SK) ? getDBValidatedValue(params.get(X_PRIORITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(X_ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(X_ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(XSTATUS_SK) ? getDBValidatedValue(params.get(XSTATUS_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(13, params.containsKey(X_IS_VIP) ? getValue(params.get(X_IS_VIP)) : null);
                        callableStatement.setString(14, params.containsKey(X_REQUESTER_SK) ? getDBValidatedValue(params.get(X_REQUESTER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(X_TITLE_SK) ? getDBValidatedValue(params.get(X_TITLE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(16, params.containsKey(X_SEVERITY_SK) ? getDBValidatedValue(params.get(X_SEVERITY_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(17, params.containsKey(X_IMPACT_SK) ? getDBValidatedValue(params.get(X_IMPACT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(18, params.containsKey(X_SOURCE_SK) ? getDBValidatedValue(params.get(X_SOURCE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(19, params.containsKey(XQUEUE_SK) ? getDBValidatedValue(params.get(XQUEUE_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(20, params.containsKey(X_ASSIGNED_INDIVIDUAL_SK) ? getDBValidatedValue(params.get(X_ASSIGNED_INDIVIDUAL_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(21, params.containsKey(Y_VALUE1) ? getDBValidatedValue(params.get(Y_VALUE1), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(22, params.containsKey(Y_VALUE2) ? getDBValidatedValue(params.get(Y_VALUE2), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(23, params.containsKey(Y_VALUE3) ? getDBValidatedValue(params.get(Y_VALUE3), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(24, params.containsKey(Y_VALUE4) ? getDBValidatedValue(params.get(Y_VALUE4), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(25, params.containsKey(Y_VALUE5) ? getDBValidatedValue(params.get(Y_VALUE5), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(26, params.containsKey(GROUP_LIST) ? getDBValidatedValue(params.get(GROUP_LIST), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(27, params.containsKey(SEQUENCE) ? getDBValidatedValue(params.get(SEQUENCE), DATATYPE_INTEGER) : null);
                        callableStatement.setString(28, params.containsKey(EXPIRE_ON) ? getDBValidatedValue(params.get(EXPIRE_ON), DATATYPE_DATETIME) : null);
                        callableStatement.setString(29, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(30, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(31, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateEmailDomains(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(EMAIL_DOMAINS_SK) ? getValue(params.get(EMAIL_DOMAINS_SK)) : null);
                        callableStatement.setString(2, params.containsKey(LOVVALUES_SK) ? getDBValidatedValue(params.get(LOVVALUES_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(RDY_MAPPING_SK) ? getDBValidatedValue(params.get(RDY_MAPPING_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateSkillSet(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 14); // 8 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(SKILL_SET_SK) ? getValue(params.get(SKILL_SET_SK)) : null);
                        callableStatement.setString(2, params.containsKey(SKILL_SET_CODE) ? getValue(params.get(SKILL_SET_CODE)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getValue(params.get(ACCOUNT_SK)) : null);
                        callableStatement.setString(4, params.containsKey(SKILL_SET) ? getValue(params.get(SKILL_SET)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAutomationServices(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 12); // 7 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(AUTOMATION_SERVICES_SK) ? getValue(params.get(AUTOMATION_SERVICES_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(3, params.containsKey(SERVICE_NAME) ? getValue(params.get(SERVICE_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(5, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);
                        callableStatement.setString(6, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(7, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateAccountType(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 8); // 5 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ACCOUNT_TYPE_SK) ? getValue(params.get(ACCOUNT_TYPE_SK)) : null);
                        callableStatement.setString(2, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(CODE) ? getDBValidatedValue(params.get(CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(4, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static List<Map<String, Object>> isEndpointWhiteListedwithNull(List<Map<String, Object>> result, CustomWhooshModel customWhooshModel,
                                                                          EndpointValidationModel endpointValidationModel, Map<String, Object> endPointDomain, User user) throws IOException {
        if (result.isEmpty() && endpointValidationModel.isFetch_null_records_endpoint_Whitelisted()) {
            endpointValidationModel.getRequestparametermap().remove(ACCOUNT);
            endpointValidationModel.getRequestparametermap().put(ACCOUNT, new String[]{NULL_VALUE});
            customWhooshModel = SFInterfaceBase.generateWhooshModel(endpointValidationModel.getRequestparametermap(), Boolean.TRUE
                    , endPointDomain.get(ENDPOINT_SK).toString(), user);
            return SFInterfaceBase.fetchWhooshRecords(endPointDomain.get(INDEX_NAME).toString()
                    , customWhooshModel.getQuery()
                    , customWhooshModel.getSort()
                    , customWhooshModel.getRequiredColumns()
                    , customWhooshModel.getSortfields()
                    , customWhooshModel.getSortorder()
                    , customWhooshModel.getDistinct()
                    , customWhooshModel.getFieldaliass()
                    , customWhooshModel.getCount()
                    , Boolean.FALSE
                    , customWhooshModel.getDistinctfield()
                    , customWhooshModel.getPageno()
                    , Boolean.TRUE, user);
        } else {
            return result;
        }
    }

    public static List<Map<String, Object>> mapBackUpApprover(List<Map<String, Object>> recordsList, UserAccountNGroup userAccountNGroup, User user) {
        //is_backup_needed = true && user_sk is in vacation && user_sk is not an loggedin user
        recordsList.stream()
                .filter(stringObjectMap -> checkBlankorEmpty((String) stringObjectMap.get(USER_SK))
                        && checkBlankorEmpty((String) stringObjectMap.get(IS_BACKUP_NEEDED))
                        && stringObjectMap.get(IS_BACKUP_NEEDED).toString().equalsIgnoreCase(ONE)
                        && !checkBlankorEmpty((String) stringObjectMap.get(BACK_UP_APPROVER_SK))
                        && checkUserinVacation(stringObjectMap.get(USER_SK).toString(), user)
                        && !checkUserisLoggedinUser(stringObjectMap.get(USER_SK).toString(), userAccountNGroup))
                .map(stringObjectMap -> {
                            stringObjectMap = updateBackupApprover(stringObjectMap, userAccountNGroup, user);
                            return stringObjectMap;
                        }
                )
                .collect(Collectors.toList());
        return recordsList;
    }

    public static Boolean checkUserinVacation(String user_sk, User user) {
        Boolean vacatationstatus = Boolean.FALSE;
        if (checkBlankorEmpty(user_sk)) {
            List<Map<String, Object>> inactiveprofile = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, USER_SK + COLON + user_sk + AND + STATUS + COLON + STATUS_INACTIVE + AND + NOT + RETURN_ON + COLON + NULL_VALUE, null, new String[]{USER_SK}, null, null
                    , null, null, 1, user);
            if (!inactiveprofile.isEmpty()) {
                vacatationstatus = Boolean.TRUE;
            }
        }
        return vacatationstatus;
    }

    public static Boolean checkUserisLoggedinUser(String user_sk, UserAccountNGroup user) {
        return user.getUser_sk().equalsIgnoreCase(user_sk);
    }

    public static Map<String, Object> updateBackupApprover(Map<String, Object> approverrecord, UserAccountNGroup userAccountNGroup, User user) {
        if (checkBlankorEmpty((String) approverrecord.get(Approver_sk))) {
            //backup approver implementation
            List<Map<String, Object>> backupapprovers = fetchWhooshRecords(INDEXERNAME_FETCH_BACKUP_APPROVER,
                    Approver_sk + COLON + approverrecord.get(Approver_sk).toString(),
                    null, null, SEQUENCE, null, null, null, 0, user);
            approverrecord = mapBackupRecord(approverrecord, backupapprovers, userAccountNGroup, user);
        }
        return approverrecord;
    }

    public static Map<String, Object> mapBackupRecord(Map<String, Object> approverrecord,
                                                      List<Map<String, Object>> backuprecords, UserAccountNGroup userAccountNGroup, User user) {
        if (!backuprecords.isEmpty()) {
            boolean userMapped = false;
            int mainloopCount = 1, subloopCount = 1;

            int maxSequence = getmaxSequence(backuprecords);

            while (mainloopCount <= backuprecords.size() && !userMapped) {  //stop when backup user is found or loop exceds the backuprecords size
                subloopCount = 1;
                String sequence = null;
                Optional<Map<String, Object>> backupRecord = Optional.empty();
                do {
                    backupRecord = getnextSequenceRecord(sequence, backuprecords);
                    if (backupRecord.isPresent()) {
                        if (backupRecord.isPresent() && (!checkBlankorEmpty((String) backupRecord.get().get(USER_SK))
                                || (userAccountNGroup.getUser_sk().equalsIgnoreCase(backupRecord.get().get(USER_SK).toString()) && !checkUserinVacation(backupRecord.get().get(USER_SK).toString(), user)))) {
                            userMapped = true;
                            if (checkBlankorEmpty((String) backupRecord.get().get(USER_SK))) {
                                approverrecord = combineApproverRecord(approverrecord, backupRecord.get(), userAccountNGroup);
                            } else {
                                approverrecord = combineApproverRecord(approverrecord, backupRecord.get(), userAccountNGroup);
                            }
                        }
                    }
                    if (sequence == null) {
                        sequence = "1";
                    } else {
                        sequence = String.valueOf(Integer.parseInt(sequence) + 1);
                    }
                    subloopCount += 1;
                } while (!userMapped && backuprecords.size() + 1 >= subloopCount && maxSequence >= Integer.parseInt(sequence));
                //stop when backupRecord not mapped && backRecords size greater than or equal to loopcount assuming one null sequence is allowed
                mainloopCount += 1;
            }
        }
        return approverrecord;
    }


    public static Map<String, Object> combineApproverRecord(Map<String, Object> approverRecord, Map<String, Object> backupRecord, UserAccountNGroup userAccountNGroup) {
        //fields need to be mapped
        approverRecord.put(GROUP_NAME, backupRecord.get(GROUP_NAME));
        approverRecord.put(FULL_NAME, backupRecord.get(FULL_NAME));
        approverRecord.put(ACCOUNT_GROUP_SK, backupRecord.get(ACCOUNT_GROUP_SK));
        if (!checkBlankorEmpty((String) backupRecord.get(USER_SK))
                && checkBlankorEmpty((String) backupRecord.get(ACCOUNT_GROUP_SK))
                && checkBlankorEmpty((String) backupRecord.get(GROUP_NAME))
                && isUserPartofGroup(userAccountNGroup, (String) backupRecord.get(GROUP_NAME))) {
            approverRecord.put(USER_SK, userAccountNGroup.getUser_sk());
            approverRecord.put(FULL_NAME, userAccountNGroup.getFull_name());
        } else {
            approverRecord.put(USER_SK, backupRecord.get(USER_SK));
            approverRecord.put(FULL_NAME, backupRecord.get(FULL_NAME));
        }
        return approverRecord;
    }


    public static Optional<Map<String, Object>> getnextSequenceRecord(String sequence, List<Map<String, Object>> backupRecords) {
        if (sequence == null) {
            return backupRecords.stream()
                    .filter(stringObjectMap -> stringObjectMap.get(SEQUENCE) == null)
                    .findAny();
        } else {
            return backupRecords.stream()
                    .filter(stringObjectMap -> stringObjectMap.get(SEQUENCE) != null)
                    .filter(stringObjectMap -> stringObjectMap.get(SEQUENCE).toString().equalsIgnoreCase(sequence))
                    .findAny();
        }
    }

    public static int getmaxSequence(List<Map<String, Object>> backupRecords) {
        OptionalInt maxSize = backupRecords.stream()
                .mapToInt(value -> value.get(SEQUENCE) == null ? NUM_ONE : Integer.parseInt(value.get(SEQUENCE).toString()))
                .max();
        return maxSize.isPresent() ? maxSize.getAsInt() : NUM_ONE;
    }


    public static Map<String, Object> createDmartCRConsolidated(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {
        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 66); // 34 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CR_NUMBER) ? getValue(params.get(CR_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_TYPE) ? getValue(params.get(TASK_TYPE)) : null);
                        callableStatement.setString(3, params.containsKey(TASKTYPE_NAME) ? getValue(params.get(TASKTYPE_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(ENTITYTYPE) ? getValue(params.get(ENTITYTYPE)) : null);
                        callableStatement.setString(5, params.containsKey(ENTITYNAME) ? getValue(params.get(ENTITYNAME)) : null);
                        callableStatement.setString(6, params.containsKey(LEVEL) ? getValue(params.get(LEVEL)) : null);
                        callableStatement.setString(7, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(8, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(9, params.containsKey(IS_START_NODE) ? getValue(params.get(IS_START_NODE)) : null);
                        callableStatement.setString(10, params.containsKey(PREDECESSOR_ENTITY_TYPE) ? getValue(params.get(PREDECESSOR_ENTITY_TYPE)) : null);
                        callableStatement.setString(11, params.containsKey(PREDECESSOR_ENTITY_NAME) ? getValue(params.get(PREDECESSOR_ENTITY_NAME)) : null);
                        callableStatement.setString(12, params.containsKey(ISACTIVE) ? getValue(params.get(ISACTIVE)) : null);
                        callableStatement.setString(13, params.containsKey(MILESTONE) ? getValue(params.get(MILESTONE)) : null);
                        callableStatement.setString(14, params.containsKey(APPROVALS_NEEDED) ? getValue(params.get(APPROVALS_NEEDED)) : null);
                        callableStatement.setString(15, params.containsKey(APPROVAL_NUMBER) ? getValue(params.get(APPROVAL_NUMBER)) : null);
                        callableStatement.setString(16, params.containsKey(APPROVAL_REQUESTED_ON) ? getValue(params.get(APPROVAL_REQUESTED_ON)) : null);
                        callableStatement.setString(17, params.containsKey(APPROVER_LOGIN) ? getValue(params.get(APPROVER_LOGIN)) : null);
                        callableStatement.setString(18, params.containsKey(APPROVER_NAME) ? getValue(params.get(APPROVER_NAME)) : null);
                        callableStatement.setString(19, params.containsKey(APPROVAL_STATUS) ? getValue(params.get(APPROVAL_STATUS)) : null);
                        callableStatement.setString(20, params.containsKey(ApproverComments) ? getValue(params.get(ApproverComments)) : null);
                        callableStatement.setString(21, params.containsKey(APPROVED_DATE_TIME) ? getValue(params.get(EFFECTED_ACCOUNTCODE)) : null);
                        callableStatement.setString(22, params.containsKey(APPROVED_BY) ? getValue(params.get(APPROVED_BY)) : null);
                        callableStatement.setString(23, params.containsKey(APPROVAL_CRITERIA_CODE) ? getValue(params.get(APPROVAL_CRITERIA_CODE)) : null);
                        callableStatement.setString(24, params.containsKey(APPROVAL_CRITERIA1) ? getValue(params.get(APPROVAL_CRITERIA1)) : null);
                        callableStatement.setString(25, params.containsKey(APPROVAL_CRITERIA2) ? getValue(params.get(APPROVAL_CRITERIA2)) : null);
                        callableStatement.setString(26, params.containsKey(BACKUP_APPROVAL1) ? getValue(params.get(BACKUP_APPROVAL1)) : null);
                        callableStatement.setString(27, params.containsKey(BACKUP_APPROVAL2) ? getValue(params.get(BACKUP_APPROVAL2)) : null);
                        callableStatement.setString(28, params.containsKey(BACKUP_APPROVAL3) ? getValue(params.get(BACKUP_APPROVAL3)) : null);
                        callableStatement.setString(29, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(30, params.containsKey(CREATED_ON) ? getValue(params.get(CREATED_ON)) : null);
                        callableStatement.setString(31, params.containsKey(ACCOUNT_CODE) ? getValue(params.get(ACCOUNT_CODE)) : null);
                        callableStatement.setString(32, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(33, params.containsKey(APPROVALSTATUS_SK) ? getValue(params.get(APPROVALSTATUS_SK)) : null);
                        callableStatement.setString(34, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartCRConsolidated(JdbcTemplate refTemplate, String spName, Map<String, Object> params, String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();

        try {

            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 66); // 34 parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            paramList.add(varString);
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);
                        callableStatement.setString(1, params.containsKey(CR_NUMBER) ? getValue(params.get(CR_NUMBER)) : null);
                        callableStatement.setString(2, params.containsKey(TASK_TYPE) ? getValue(params.get(TASK_TYPE)) : null);
                        callableStatement.setString(3, params.containsKey(TASKTYPE_NAME) ? getValue(params.get(TASKTYPE_NAME)) : null);
                        callableStatement.setString(4, params.containsKey(ENTITYTYPE) ? getValue(params.get(ENTITYTYPE)) : null);
                        callableStatement.setString(5, params.containsKey(ENTITYNAME) ? getValue(params.get(ENTITYNAME)) : null);
                        callableStatement.setString(6, params.containsKey(LEVEL) ? getValue(params.get(LEVEL)) : null);
                        callableStatement.setString(7, params.containsKey(SEQUENCE) ? getValue(params.get(SEQUENCE)) : null);
                        callableStatement.setString(8, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(9, params.containsKey(IS_START_NODE) ? getValue(params.get(IS_START_NODE)) : null);
                        callableStatement.setString(10, params.containsKey(PREDECESSOR_ENTITY_TYPE) ? getValue(params.get(PREDECESSOR_ENTITY_TYPE)) : null);
                        callableStatement.setString(11, params.containsKey(PREDECESSOR_ENTITY_NAME) ? getValue(params.get(PREDECESSOR_ENTITY_NAME)) : null);
                        callableStatement.setString(12, params.containsKey(ISACTIVE) ? getValue(params.get(ISACTIVE)) : null);
                        callableStatement.setString(13, params.containsKey(MILESTONE) ? getValue(params.get(MILESTONE)) : null);
                        callableStatement.setString(14, params.containsKey(APPROVALS_NEEDED) ? getValue(params.get(APPROVALS_NEEDED)) : null);
                        callableStatement.setString(15, params.containsKey(APPROVAL_NUMBER) ? getValue(params.get(APPROVAL_NUMBER)) : null);
                        callableStatement.setString(16, params.containsKey(APPROVAL_REQUESTED_ON) ? getValue(params.get(APPROVAL_REQUESTED_ON)) : null);
                        callableStatement.setString(17, params.containsKey(APPROVER_LOGIN) ? getValue(params.get(APPROVER_LOGIN)) : null);
                        callableStatement.setString(18, params.containsKey(APPROVER_NAME) ? getValue(params.get(APPROVER_NAME)) : null);
                        callableStatement.setString(19, params.containsKey(APPROVAL_STATUS) ? getValue(params.get(APPROVAL_STATUS)) : null);
                        callableStatement.setString(20, params.containsKey(ApproverComments) ? getValue(params.get(ApproverComments)) : null);
                        callableStatement.setString(21, params.containsKey(APPROVED_DATE_TIME) ? getValue(params.get(EFFECTED_ACCOUNTCODE)) : null);
                        callableStatement.setString(22, params.containsKey(APPROVED_BY) ? getValue(params.get(APPROVED_BY)) : null);
                        callableStatement.setString(23, params.containsKey(APPROVAL_CRITERIA_CODE) ? getValue(params.get(APPROVAL_CRITERIA_CODE)) : null);
                        callableStatement.setString(24, params.containsKey(APPROVAL_CRITERIA1) ? getValue(params.get(APPROVAL_CRITERIA1)) : null);
                        callableStatement.setString(25, params.containsKey(APPROVAL_CRITERIA2) ? getValue(params.get(APPROVAL_CRITERIA2)) : null);
                        callableStatement.setString(26, params.containsKey(BACKUP_APPROVAL1) ? getValue(params.get(BACKUP_APPROVAL1)) : null);
                        callableStatement.setString(27, params.containsKey(BACKUP_APPROVAL2) ? getValue(params.get(BACKUP_APPROVAL2)) : null);
                        callableStatement.setString(28, params.containsKey(BACKUP_APPROVAL3) ? getValue(params.get(BACKUP_APPROVAL3)) : null);
                        callableStatement.setString(29, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);
                        callableStatement.setString(30, params.containsKey(MODIFIED_ON) ? getValue(params.get(MODIFIED_ON)) : null);
                        callableStatement.setString(31, params.containsKey(ACCOUNT_CODE) ? getValue(params.get(ACCOUNT_CODE)) : null);
                        callableStatement.setString(32, params.containsKey(CR_SK) ? getValue(params.get(CR_SK)) : null);
                        callableStatement.setString(33, params.containsKey(APPROVALSTATUS_SK) ? getValue(params.get(APPROVALSTATUS_SK)) : null);
                        callableStatement.setString(34, params.containsKey(STATUS_SK) ? getValue(params.get(STATUS_SK)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }
        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Boolean isUserPartofGroup(UserAccountNGroup userAccountNGroup, String GroupName) {
        return userAccountNGroup.getUserGroups().parallelStream()
                .filter(stringObjectMap1 -> stringObjectMap1.get(GROUP_NAME) != null)
                .anyMatch(stringObjectMap1 -> stringObjectMap1.get(GROUP_NAME).toString().equalsIgnoreCase(GroupName));
    }

    public static List<Map<String, Object>> fetchUnapprovedRecords(List<Map<String, Object>> records, User user) {//fetch unapproved not denied or not canceled
        List<Map<String, Object>> unapprovedrecords = records.stream()
                .filter(stringObjectMap -> !checkBlankorEmpty((String) stringObjectMap.get(STATUS_CODE))
                                || (
                                !stringObjectMap.get(STATUS_CODE).toString().equalsIgnoreCase("APPR")
                                        && !stringObjectMap.get(STATUS_CODE).toString().equalsIgnoreCase("DND")
                                        && !stringObjectMap.get(STATUS_CODE).toString().equalsIgnoreCase("CL")
                        )
                ).collect(Collectors.toList());
        return mapFoundationApproverwithTransaction(unapprovedrecords, user);
    }

    public static List<Map<String, Object>> fetchapprovedRecords(List<Map<String, Object>> records) {//fetch unapproved not denied or not canceled
        return records.stream()
                .filter(stringObjectMap -> checkBlankorEmpty((String) stringObjectMap.get(STATUS_CODE))
                                && (
                                stringObjectMap.get(STATUS_CODE).toString().equalsIgnoreCase("APPR")
                                        || stringObjectMap.get(STATUS_CODE).toString().equalsIgnoreCase("DND")
                                        || stringObjectMap.get(STATUS_CODE).toString().equalsIgnoreCase("CL")
                        )
                ).collect(Collectors.toList());
    }

    public static List<Map<String, Object>> mapFoundationApproverwithTransaction(List<Map<String, Object>> unapprovedrecords, User user) {//fetch unapproved not denied or not canceled
        if (!unapprovedrecords.isEmpty()) {
            String approvalCriteria = (String) unapprovedrecords.get(0).get(APPROVAL_CRITERIA_SK);
            List<Map<String, Object>> approvers = fetchWhooshRecords(INDEXERNAME_FETCH_APPROVERS, APPROVAL_CRITERIA_SK + COLON + approvalCriteria + AND + STATUS_CODE + COLON + "A", null, null, null, null, null, null, 0, user);

            unapprovedrecords.forEach(tranapprovers -> {
                approvers.forEach(fdnapprovers -> {
                    if (checkBlankorEmpty((String) fdnapprovers.get(Approver_sk)) && checkBlankorEmpty((String) tranapprovers.get(Approver_sk))
                            && fdnapprovers.get(Approver_sk).toString().equalsIgnoreCase(tranapprovers.get(Approver_sk).toString())) {
                        tranapprovers.put(FULL_NAME, fdnapprovers.get(FULL_NAME));
                        tranapprovers.put(GROUP_NAME, fdnapprovers.get(GROUP_NAME));
                        tranapprovers.put(ACCOUNT_GROUP_SK, fdnapprovers.get(ACCOUNT_GROUP_SK));
                        tranapprovers.put(USER_SK, fdnapprovers.get(USER_SK));
                    }
                });
            });
        }
        return unapprovedrecords;
    }

    public static Map<String, Object> updateEscalations(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 22); // 12 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(ESCALATION_SK) ? getValue(params.get(ESCALATION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ESCALATION_CODE) ? getDBValidatedValue(params.get(ESCALATION_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(ESCALATION_NAME) ? getValue(params.get(ESCALATION_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(ACCOUNT_GROUP_SK) ? getDBValidatedValue(params.get(ACCOUNT_GROUP_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(7, params.containsKey(USER_SK) ? getDBValidatedValue(params.get(USER_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(EMAIL_ADDRESS) ? getDBValidatedValue(params.get(EMAIL_ADDRESS), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(10, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateUnits(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 16); // 9 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(UNIT_SK) ? getValue(params.get(UNIT_SK)) : null);
                        callableStatement.setString(2, params.containsKey(UNIT_CODE) ? getDBValidatedValue(params.get(UNIT_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(UNIT_NAME) ? getValue(params.get(UNIT_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(7, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(8, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(EXTERNAL_SYS_ID) ? getDBValidatedValue(params.get(EXTERNAL_SYS_ID), DATATYPE_VARCHAR) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateNotifications(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 28); // 14 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(NOTIFICATION_SK) ? getValue(params.get(NOTIFICATION_SK)) : null);
                        callableStatement.setString(2, params.containsKey(NOTIFICATION_CODE) ? getDBValidatedValue(params.get(NOTIFICATION_CODE), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT_SK) ? getDBValidatedValue(params.get(ACCOUNT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(4, params.containsKey(NOTIFICATION_NAME) ? getValue(params.get(NOTIFICATION_NAME)) : null);
                        callableStatement.setString(5, params.containsKey(DESCRIPTION) ? getDBValidatedValue(params.get(DESCRIPTION), DATATYPE_VARCHAR) : null);
                        callableStatement.setString(6, params.containsKey(ON_CREATION) ? getValue(params.get(ON_CREATION)) : null);
                        callableStatement.setString(7, params.containsKey(ON_EVERY) ? getDBValidatedValue(params.get(ON_EVERY), DATATYPE_FLOAT) : null);
                        callableStatement.setString(8, params.containsKey(ON_EVERY_UNIT_SK) ? getDBValidatedValue(params.get(ON_EVERY_UNIT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(9, params.containsKey(NO_OF_TIMES_BEFORE_ETA) ? getDBValidatedValue(params.get(NO_OF_TIMES_BEFORE_ETA), DATATYPE_INTEGER) : null);
                        callableStatement.setString(10, params.containsKey(FINAL_REMINDER) ? getDBValidatedValue(params.get(FINAL_REMINDER), DATATYPE_INTEGER) : null);
                        callableStatement.setString(11, params.containsKey(FINAL_REMINDER_UNIT_SK) ? getDBValidatedValue(params.get(FINAL_REMINDER_UNIT_SK), DATATYPE_INTEGER) : null);
                        callableStatement.setString(12, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(13, params.containsKey(CREATED_BY) ? getDBValidatedValue(params.get(CREATED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(14, params.containsKey(MODIFIED_BY) ? getDBValidatedValue(params.get(MODIFIED_BY), DATATYPE_INTEGER) : null);
                        callableStatement.setString(15, params.containsKey(ESCALATION_SK) ? getDBValidatedValue(params.get(ESCALATION_SK), DATATYPE_INTEGER) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateNotificationMapping(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 10); // 6 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(NOTIFICATION_MAPPING_SK) ? getValue(params.get(NOTIFICATION_MAPPING_SK)) : null);
                        callableStatement.setString(2, params.containsKey(ENTITYNAME) ? getValue(params.get(ENTITYNAME)) : null);
                        callableStatement.setString(3, params.containsKey(ENTITY_sk) ? getValue(params.get(ENTITY_sk)) : null);
                        callableStatement.setString(4, params.containsKey(NOTIFICATION_SK) ? getValue(params.get(NOTIFICATION_SK)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_BY) ? getValue(params.get(CREATED_BY)) : null);
                        callableStatement.setString(6, params.containsKey(MODIFIED_BY) ? getValue(params.get(MODIFIED_BY)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Boolean checkTicketExistinReferenceDB(String Ticket, User user, String dbType) throws IOException {
        String endpointName = "TicketExist";
        Map<String, Object> endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpointName, "V1", GET_METHOD, user);
        Map<String, String[]> params = new HashMap<>();
        params.put(TICKET_NUMBER, new String[]{Ticket});
        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), params);
        List<Map<String, Object>> tickets = SFInterfaceBase.runjdbcQueryWithPagination(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, dbType)
                , refdbquery
                , null
                , null
                , null
                , null
                , null
                , NUM_ZERO
                , NUM_ZERO
                , Boolean.FALSE);
        if (!tickets.isEmpty())
            return true;
        else
            return false;
    }

    public static JdbcTemplate fetchConnection(HttpServletRequest request, User user) throws IOException {
        JdbcTemplate jdbcTemplate;
        if (request.getParameterMap().containsKey(TICKET)) {
            jdbcTemplate = checkTicketExistinReferenceDB(request.getParameter(TICKET).toString(), user, SFInterfaceConstants.getDbRefConnectionName()) ?
                    SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()) :
                    (checkTicketExistinReferenceDB(request.getParameter(TICKET).toString(), user, SFInterfaceConstants.getDbRefReplicaConnectionName()) ?

                            SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefReplicaConnectionName())
                            :
                            SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName())
                    );
        } else {
            jdbcTemplate = SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName());
        }
        return jdbcTemplate;
    }

    public static List<String> fetchDedicatedInstances() {
        return Arrays.asList(SFInterfaceConstants.getDedicatedInstances().split(COMMA));
    }

    public static Map<String, Object> fetchprofileBasedonEmailID(String emailID, String instance) {
        User user = new User();
        user.setClientInstance(instance);
        List<Map<String, Object>> records = fetchWhooshRecords(INDEXERNAME_FETCH_PROFILE, EMAIL_ADDRESS + COLON + emailID, null
                , new String[]{NETWORK_LOGIN, ACCOUNT, MASTER_ACCOUNT}
                , null, null, null, null, NUM_ZERO, user);
        if (!records.isEmpty()) {
            if (records.get(NUM_ZERO).get(ACCOUNT).toString().equalsIgnoreCase(CTS) && !instance.equalsIgnoreCase("shared")) {
                return null;
            } else {
                Map<String, Object> profile = records.get(NUM_ZERO);
                profile.put(CLIENT_INSTANCE, instance);
                return profile;
            }
        }
        return null;
    }


    public static Map<String, Object> createDmartKBArticle(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 34); // 18 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(DOC_ID) ? getValue(params.get(DOC_ID)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(ARTICLE_TITLE) ? getValue(params.get(ARTICLE_TITLE)) : null);
                        callableStatement.setString(4, params.containsKey(ARTICLE_KEYWORDS) ? getValue(params.get(ARTICLE_KEYWORDS)) : null);
                        callableStatement.setString(5, params.containsKey(PHRASE_HISTORY) ? getValue(params.get(PHRASE_HISTORY)) : null);
                        callableStatement.setString(6, params.containsKey(TYPE_AHEAD_PHRASES) ? getValue(params.get(TYPE_AHEAD_PHRASES)) : null);
                        callableStatement.setString(7, params.containsKey(ARTICLE_OWNER_LOGINID) ? getValue(params.get(ARTICLE_OWNER_LOGINID)) : null);
                        callableStatement.setString(8, params.containsKey(EXPIRY_DATE) ? getValue(params.get(EXPIRY_DATE)) : null);
                        callableStatement.setString(9, params.containsKey(LOCK_STATUS) ? getValue(params.get(LOCK_STATUS)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(CREATED_BY_LOGINID) ? getValue(params.get(CREATED_BY_LOGINID)) : null);
                        callableStatement.setString(12, params.containsKey(CREATED_ON) ? getValue(params.get(CREATED_ON)) : null);
                        callableStatement.setString(13, params.containsKey(TYPE_AHEAD_CATEGORY1) ? getValue(params.get(TYPE_AHEAD_CATEGORY1)) : null);
                        callableStatement.setString(14, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(15, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(16, params.containsKey(FLR) ? getValue(params.get(FLR)) : null);
                        callableStatement.setString(17, params.containsKey(DOCUMENT_TYPE) ? getValue(params.get(DOCUMENT_TYPE)) : null);
                        callableStatement.setString(18, params.containsKey(CONTENT_TYPE) ? getValue(params.get(CONTENT_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartKBArticle(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 34); // 18 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5
            paramList.add(varString); //6
            paramList.add(varString); //7
            paramList.add(varString); //8
            paramList.add(varString); //9
            paramList.add(varString); //10
            paramList.add(varString); //11
            paramList.add(varString); //12
            paramList.add(varString); //13
            paramList.add(varString); //14
            paramList.add(varString); //15
            paramList.add(varString); //16
            paramList.add(varString); //17
            paramList.add(varString); //18

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(DOC_ID) ? getValue(params.get(DOC_ID)) : null);
                        callableStatement.setString(2, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(3, params.containsKey(ARTICLE_TITLE) ? getValue(params.get(ARTICLE_TITLE)) : null);
                        callableStatement.setString(4, params.containsKey(ARTICLE_KEYWORDS) ? getValue(params.get(ARTICLE_KEYWORDS)) : null);
                        callableStatement.setString(5, params.containsKey(PHRASE_HISTORY) ? getValue(params.get(PHRASE_HISTORY)) : null);
                        callableStatement.setString(6, params.containsKey(TYPE_AHEAD_PHRASES) ? getValue(params.get(TYPE_AHEAD_PHRASES)) : null);
                        callableStatement.setString(7, params.containsKey(ARTICLE_OWNER_LOGINID) ? getValue(params.get(ARTICLE_OWNER_LOGINID)) : null);
                        callableStatement.setString(8, params.containsKey(EXPIRY_DATE) ? getValue(params.get(EXPIRY_DATE)) : null);
                        callableStatement.setString(9, params.containsKey(LOCK_STATUS) ? getValue(params.get(LOCK_STATUS)) : null);
                        callableStatement.setString(10, params.containsKey(STATUS) ? getValue(params.get(STATUS)) : null);
                        callableStatement.setString(11, params.containsKey(MODIFIED_BY_LOGINID) ? getValue(params.get(MODIFIED_BY_LOGINID)) : null);
                        callableStatement.setString(12, params.containsKey(MODIFIED_ON) ? getValue(params.get(MODIFIED_ON)) : null);
                        callableStatement.setString(13, params.containsKey(TYPE_AHEAD_CATEGORY1) ? getValue(params.get(TYPE_AHEAD_CATEGORY1)) : null);
                        callableStatement.setString(14, params.containsKey(EXTERNAL_SYS_ID) ? getValue(params.get(EXTERNAL_SYS_ID)) : null);
                        callableStatement.setString(15, params.containsKey(BUSINESS_FUNCTION_SK) ? getValue(params.get(BUSINESS_FUNCTION_SK)) : null);
                        callableStatement.setString(16, params.containsKey(FLR) ? getValue(params.get(FLR)) : null);
                        callableStatement.setString(17, params.containsKey(DOCUMENT_TYPE) ? getValue(params.get(DOCUMENT_TYPE)) : null);
                        callableStatement.setString(18, params.containsKey(CONTENT_TYPE) ? getValue(params.get(CONTENT_TYPE)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static int booleancomparereverse(boolean x, boolean y) {
        return (x == y) ? 0 : (x ? -1 : 1);
    }


    public static String fetchNotification_sk(String approver_sk, User user, String endpointName) throws IOException {
        Map<String, String[]> params = new HashMap<>();
        params.put(ENTITYNAME, new String[]{FDN_APPROVERS});
        params.put(ENTITY_sk, new String[]{approver_sk});

        Map<String, Object> endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpointName, V1, GET_METHOD, user);
        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), params);
        List<Map<String, Object>> results = SFInterfaceBase.runjdbcQueryWithPagination(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName())
                , refdbquery
                , new String[]{NOTIFICATION_SK}
                , null
                , null
                , null
                , null
                , NUM_ZERO
                , NUM_ZERO
                , Boolean.FALSE);
        Optional<String> response = results.stream().
                map(stringObjectMap -> (String) stringObjectMap.get(NOTIFICATION_SK))
                .findFirst();
        return response.isPresent() ? response.get() : null;
    }

    public static List<Map<String, Object>> updateApprovers(List<Map<String, Object>> objects, User user, String endpointName1, HttpServletRequest request) throws Exception {
        Map<String, Object> ticketFields = new HashMap<>();
        final String[] createdby = {""};
        final String[] modifiedBy = {""};
        //   objects
        List<Map<String, Object>> tempObject = new ArrayList<>();
        objects.stream()
                .forEach(object -> {
                    List<Map<String, Object>> approvalcriteria = new ArrayList<>();
                    tempObject.clear();
                    tempObject.add(object);
                    ticketFields.put(APPROVERS.toLowerCase(), tempObject);
                    try {
                        approvalcriteria = createORUpdateEntitiess(ticketFields, endpointName1, SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), request, user);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    createdby[0] = (String) object.get(CREATED_BY);
                    modifiedBy[0] = (String) object.get(MODIFIED_BY);
                    object.put(Approver_sk, approvalcriteria.get(0).get(Approver_sk).toString());
                });
        //backUp APprover starts
        objects.stream()
                .forEach(stringObjectMap -> {
                    updateBackupApprover(stringObjectMap, request, user, createdby[0], modifiedBy[0]);
                    if (stringObjectMap.containsKey(NOTIFICATION_SK)) {
                        Map<String, Object> params = new HashMap<>();
                        params.put(NOTIFICATION_MAPPING_SK, stringObjectMap.get(NOTIFICATION_MAPPING_SK));
                        params.put(NOTIFICATION_SK, stringObjectMap.get(NOTIFICATION_SK));
                        params.put(CREATED_BY, createdby[0]);
                        params.put(MODIFIED_BY, modifiedBy[0]);
                        params.put(ENTITYNAME, FDN_APPROVERS);
                        params.put(ENTITY_sk, stringObjectMap.get(Approver_sk));
                        try {
                            updatenotificationMapping(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()),
                                    "UpdateNotificationMapping", user, params);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                });
        return objects;
    }

    public static void updateOTPSecret(JdbcTemplate jdbcTemplate, String user_sk, String otpsecret) throws IOException {
        try {
            Resource resource = resourceLoader.getResource("classpath:sql/update_otp_secret.txt");
            String sql = IOUtils.toString(resource.getInputStream(), "UTF-8");
            jdbcTemplate.execute(String.format(sql, user_sk, otpsecret));
        } catch (Exception e) {
            //return null;
        }
    }

    public static int updateUserPasswordbySecred(JdbcTemplate jdbcTemplate, String user_sk, String password, String secret) throws IOException {
        try {
            Resource resource = resourceLoader.getResource("classpath:sql/update_otp_password.txt");
            String sql = IOUtils.toString(resource.getInputStream(), "UTF-8");
            Map<String, Object> result = jdbcTemplate.queryForMap(String.format(sql, user_sk, password, secret));
            return Integer.parseInt(result.get("Status").toString());
        } catch (Exception e) {
            return NUM_ZERO;
        }
    }

    public static Boolean sendemail(String code, String toEmail, JdbcTemplate jdbcTemplate, User user) {
        String subject = "ServiceFocus Profile Registration";
        String content = "Your profile registration OTP code is:" + code;
        String proc = String.format("EXEC [WF_InsertMailSchedules] '%1$s',0,0,'%1$s','%2$s','%3$s'", toEmail, subject, content);
        jdbcTemplate.execute(proc);
        return true;
    }
       /*     RestTemplate restTemplate = new RestTemplate();
        Gson g = gson;
        HttpHeaders headers = new HttpHeaders();
        MultiValueMap body = new LinkedMultiValueMap<String, Object>();
        HttpEntity<MultiValueMap<String, String>> httpEntity;
        String constructurl = "";
        headers.add("atoken", SFInterfaceConstants.getaTokenValue());
        headers.add(CLIENT_INSTANCE, user.getClientInstance());

       httpEntity.put("ToEmail""krishnamoorthy@htcindia.com",
                "CCEMail":"Anand.Rajendran@caretech.com",
                "Subject":"Test",
                "MailBody":"test 12345646",
                "EntityName":"SLA",
                "Entity_sk":3
        ResponseEntity<String> response = restTemplate.exchange("http://" + url + finalConstructurl, HttpMethod.POST, finalHttpEntity, String.class);
*/
    // proc = "EXEC [WF_InsertMailSchedules] '%1$s',0,0,'%1$s','%2$s','%3$s'";

    public static Map<String, Object> createDmartKBUserFavoriteArticle(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 8); // 5 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3
            paramList.add(varString); //4
            paramList.add(varString); //5

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_LOGIN_ID) ? getValue(params.get(USER_LOGIN_ID)) : null);
                        callableStatement.setString(2, params.containsKey(KB_ARTICLE_ID) ? getValue(params.get(KB_ARTICLE_ID)) : null);
                        callableStatement.setString(3, params.containsKey(ARTICLE_TITLE) ? getValue(params.get(ARTICLE_TITLE)) : null);
                        callableStatement.setString(4, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);
                        callableStatement.setString(5, params.containsKey(CREATED_ON) ? getValue(params.get(CREATED_ON)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static Map<String, Object> updateDmartKBUserFavoriteArticle(JdbcTemplate refTemplate, String spName, Map<String, Object> params
            , String endpointName) throws IOException {

        Map<String, Object> queryObject = new HashMap<>();
        try {
            String procedureCall = SFInterfaceServices.getSPCallableStatement(spName, 4); // 3 Parameters

            SqlParameter varString = new SqlParameter(Types.VARCHAR);

            List<SqlParameter> paramList = new ArrayList<SqlParameter>();
            paramList.add(varString); //1
            paramList.add(varString); //2
            paramList.add(varString); //3

            Map<String, Object> resultMap = new LinkedHashMap<>();
            try {
                resultMap = refTemplate.call(new CallableStatementCreator() {
                    @Override
                    public CallableStatement createCallableStatement(Connection connection) throws SQLException {
                        CallableStatement callableStatement = connection.prepareCall(procedureCall);

                        callableStatement.setString(1, params.containsKey(USER_LOGIN_ID) ? getValue(params.get(USER_LOGIN_ID)) : null);
                        callableStatement.setString(2, params.containsKey(KB_ARTICLE_ID) ? getValue(params.get(KB_ARTICLE_ID)) : null);
                        callableStatement.setString(3, params.containsKey(ACCOUNT) ? getValue(params.get(ACCOUNT)) : null);

                        return callableStatement;
                    }
                }, paramList);
            } catch (Exception e) {
                SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
                queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
            }

            if (resultMap.containsKey(RESULT_SET_1)) {
                List<Object> queryList = (List<Object>) resultMap.get(RESULT_SET_1);
                queryObject = (Map<String, Object>) queryList.get(NUM_ZERO);
            }

        } catch (Exception e) {
            SFInterfaceLoggerBase.exception(LOGGER, endpointName, e);
            queryObject = SFInterfaceServices.ISPExceptionHandler(e, null, endpointName);
        }

        return queryObject;
    }

    public static void updateBackupApprover(Map<String, Object> stringObjectMap, HttpServletRequest request, User user, String createdby, String modifiedby) {
        if (stringObjectMap.containsKey("backupapprovers")
                && stringObjectMap.get("backupapprovers") != null
        ) {
            List<Map<String, Object>> backupRecords = fetchWhooshRecords(INDEXERNAME_FETCH_STATUS, ENTITYCODE + COLON + "BKPAPPR", null, null, null, null, null, null, user);


            Map<String, Object> ticketFields = new HashMap<>();
            List<Map<String, Object>> backupApprover = (List<Map<String, Object>>) stringObjectMap.get("backupapprovers");
            if (!backupApprover.isEmpty()) {
                backupApprover.forEach(stringObjectMap1 -> {
                    stringObjectMap1.put(CREATED_BY, createdby);
                    stringObjectMap1.put(MODIFIED_BY, modifiedby);
                    stringObjectMap1.put(Approver_sk, stringObjectMap.get(Approver_sk));
                    if (stringObjectMap1.containsKey(STATUS_SK)) {
                        stringObjectMap1.put(STATUS_SK, backupRecords.parallelStream()
                                .filter(stringObjectMap2 -> stringObjectMap2.get(STATUS_CODE).toString().equalsIgnoreCase((String) stringObjectMap1.get(STATUS_SK)))
                                .map(stringObjectMap2 -> stringObjectMap2.get(STATUS_SK))
                                .findFirst()
                                .get()
                        );
                    }
                });
                ticketFields.put("backupapprovers", backupApprover);
                try {
                    createORUpdateEntitiess(ticketFields, "fdn_backupapprovers", SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName()), request, user);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void updatenotificationMapping(JdbcTemplate jdbcTemplate, String endpointName, User user, Map<String, Object> params) throws IOException {
        Map<String, Object> endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpointName, V1, POST_METHOD, user);
        if (!endPointDomain.containsKey(ERRORCODE)) {
            String spName = endPointDomain.get(QUERY).toString();
            updateNotificationMapping(jdbcTemplate, spName, params, endpointName);
        }
    }

    public static List<Map<String, Object>> mapInstructionQuestions(String instruction_sk, User user) throws IOException {
        String endpointName = "Questions1";
        Map<String, String[]> params = new HashMap<>();
        params.put(ENTITYNAME, new String[]{FDN_INSTRUCTIONS});
        params.put(ENTITY_sk, new String[]{instruction_sk});

        Map<String, Object> endPointDomain = SFInterfaceBase.fetchEndpointDetails(endpointName, V1, GET_METHOD, user);
        String refdbquery = getDBQuery(endPointDomain.get(QUERY).toString(), params);
        List<Map<String, Object>> results = SFInterfaceBase.runjdbcQueryWithPagination(SFInterfaceConnectionBase.fetchJdbcTemplatebyType(user, SFInterfaceConstants.getDbRefConnectionName())
                , refdbquery
                , null
                , null
                , null
                , null
                , null
                , NUM_ZERO
                , NUM_ZERO
                , Boolean.FALSE);


        return results;
    }


}

